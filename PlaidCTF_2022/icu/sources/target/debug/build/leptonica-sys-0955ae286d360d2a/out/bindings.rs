/* automatically generated by rust-bindgen 0.56.0 */

pub const LIBLEPT_MAJOR_VERSION: u32 = 1;
pub const LIBLEPT_MINOR_VERSION: u32 = 82;
pub const LIBLEPT_PATCH_VERSION: u32 = 0;
pub const _STDIO_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 33;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const HAVE_LIBJPEG: u32 = 1;
pub const HAVE_LIBTIFF: u32 = 1;
pub const HAVE_LIBPNG: u32 = 1;
pub const HAVE_LIBZ: u32 = 1;
pub const HAVE_LIBGIF: u32 = 0;
pub const HAVE_LIBUNGIF: u32 = 0;
pub const HAVE_LIBWEBP: u32 = 0;
pub const HAVE_LIBWEBP_ANIM: u32 = 0;
pub const HAVE_LIBJP2K: u32 = 0;
pub const USE_BMPIO: u32 = 1;
pub const USE_PNMIO: u32 = 1;
pub const USE_JP2KHEADER: u32 = 1;
pub const USE_PDFIO: u32 = 1;
pub const USE_PSIO: u32 = 1;
pub const HAVE_FMEMOPEN: u32 = 1;
pub const HAVE_FSTATAT: u32 = 0;
pub const UNDEF: i32 = -1;
pub const TRUE: u32 = 1;
pub const FALSE: u32 = 0;
pub const NUMA_VERSION_NUMBER: u32 = 1;
pub const DNA_VERSION_NUMBER: u32 = 1;
pub const SARRAY_VERSION_NUMBER: u32 = 1;
pub const USE_INLINE_ACCESSORS: u32 = 1;
pub const DEWARP_VERSION_NUMBER: u32 = 4;
pub const GPLOT_VERSION_NUMBER: u32 = 1;
pub const NUM_GPLOT_STYLES: u32 = 5;
pub const NUM_GPLOT_OUTPUTS: u32 = 6;
pub const JB_TEMPLATE_EXT: &'static [u8; 15usize] = b".templates.png\0";
pub const JB_DATA_EXT: &'static [u8; 6usize] = b".data\0";
pub const SEL_VERSION_NUMBER: u32 = 1;
pub const KERNEL_VERSION_NUMBER: u32 = 2;
pub const PIX_SRC: u32 = 12;
pub const PIX_DST: u32 = 10;
pub const PIX_CLR: u32 = 0;
pub const PIX_SET: u32 = 15;
pub const PIX_PAINT: u32 = 14;
pub const PIX_MASK: u32 = 8;
pub const PIX_XOR: u32 = 6;
pub const PIXAA_VERSION_NUMBER: u32 = 2;
pub const PIXA_VERSION_NUMBER: u32 = 2;
pub const BOXA_VERSION_NUMBER: u32 = 2;
pub const BOXAA_VERSION_NUMBER: u32 = 3;
pub const PTA_VERSION_NUMBER: u32 = 1;
pub const FPIX_VERSION_NUMBER: u32 = 2;
pub const DPIX_VERSION_NUMBER: u32 = 2;
pub const PIXACOMP_VERSION_NUMBER: u32 = 2;
pub const RECOG_VERSION_NUMBER: u32 = 2;
pub type size_t = ::std::os::raw::c_ulong;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: size_t,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._codecvt as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._wide_data as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_list as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._freeres_buf as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type ssize_t = __ssize_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: size_t,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut size_t,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: size_t);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut size_t,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: size_t,
        __n: size_t,
        __stream: *mut FILE,
    ) -> size_t;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> size_t;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __tss_t = ::std::os::raw::c_uint;
pub type __thrd_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __once_flag {
    pub __data: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___once_flag() {
    assert_eq!(
        ::std::mem::size_of::<__once_flag>(),
        4usize,
        concat!("Size of: ", stringify!(__once_flag))
    );
    assert_eq!(
        ::std::mem::align_of::<__once_flag>(),
        4usize,
        concat!("Alignment of ", stringify!(__once_flag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__once_flag>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__once_flag),
            "::",
            stringify!(__data)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: size_t,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: size_t,
        __size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int);
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: size_t,
        __size: size_t,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(
        __pwcs: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn wcstombs(
        __s: *mut ::std::os::raw::c_char,
        __pwcs: *const wchar_t,
        __n: size_t,
    ) -> size_t;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type l_intptr_t = isize;
pub type l_uintptr_t = usize;
pub type l_ok = ::std::os::raw::c_int;
pub type l_int8 = ::std::os::raw::c_schar;
pub type l_uint8 = ::std::os::raw::c_uchar;
pub type l_int16 = ::std::os::raw::c_short;
pub type l_uint16 = ::std::os::raw::c_ushort;
pub type l_int32 = ::std::os::raw::c_int;
pub type l_uint32 = ::std::os::raw::c_uint;
pub type l_float32 = f32;
pub type l_float64 = f64;
pub type l_int64 = ::std::os::raw::c_longlong;
pub type l_uint64 = ::std::os::raw::c_ulonglong;
extern "C" {
    pub static mut LeptDebugOK: l_int32;
}
pub const L_NOT_FOUND: ::std::os::raw::c_uint = 0;
pub const L_FOUND: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
pub const UNIX_PATH_SEPCHAR: ::std::os::raw::c_uint = 0;
pub const WIN_PATH_SEPCHAR: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub type L_TIMER = *mut ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WallTimer {
    pub start_sec: l_int32,
    pub start_usec: l_int32,
    pub stop_sec: l_int32,
    pub stop_usec: l_int32,
}
#[test]
fn bindgen_test_layout_L_WallTimer() {
    assert_eq!(
        ::std::mem::size_of::<L_WallTimer>(),
        16usize,
        concat!("Size of: ", stringify!(L_WallTimer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WallTimer>(),
        4usize,
        concat!("Alignment of ", stringify!(L_WallTimer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).start_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(start_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).start_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(start_usec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).stop_sec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(stop_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WallTimer>())).stop_usec as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WallTimer),
            "::",
            stringify!(stop_usec)
        )
    );
}
pub type L_WALLTIMER = L_WallTimer;
pub const L_SEVERITY_EXTERNAL: ::std::os::raw::c_uint = 0;
pub const L_SEVERITY_ALL: ::std::os::raw::c_uint = 1;
pub const L_SEVERITY_DEBUG: ::std::os::raw::c_uint = 2;
pub const L_SEVERITY_INFO: ::std::os::raw::c_uint = 3;
pub const L_SEVERITY_WARNING: ::std::os::raw::c_uint = 4;
pub const L_SEVERITY_ERROR: ::std::os::raw::c_uint = 5;
pub const L_SEVERITY_NONE: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_3 = ::std::os::raw::c_uint;
extern "C" {
    pub static mut LeptMsgSeverity: l_int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numa {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub refcount: l_int32,
    pub startx: l_float32,
    pub delx: l_float32,
    pub array: *mut l_float32,
}
#[test]
fn bindgen_test_layout_Numa() {
    assert_eq!(
        ::std::mem::size_of::<Numa>(),
        32usize,
        concat!("Size of: ", stringify!(Numa))
    );
    assert_eq!(
        ::std::mem::align_of::<Numa>(),
        8usize,
        concat!("Alignment of ", stringify!(Numa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Numa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).startx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(startx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).delx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(delx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numa>())).array as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Numa),
            "::",
            stringify!(array)
        )
    );
}
pub type NUMA = Numa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Numaa {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub numa: *mut *mut Numa,
}
#[test]
fn bindgen_test_layout_Numaa() {
    assert_eq!(
        ::std::mem::size_of::<Numaa>(),
        16usize,
        concat!("Size of: ", stringify!(Numaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Numaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Numaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Numaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Numaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Numaa>())).numa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Numaa),
            "::",
            stringify!(numa)
        )
    );
}
pub type NUMAA = Numaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dna {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub refcount: l_int32,
    pub startx: l_float64,
    pub delx: l_float64,
    pub array: *mut l_float64,
}
#[test]
fn bindgen_test_layout_L_Dna() {
    assert_eq!(
        ::std::mem::size_of::<L_Dna>(),
        40usize,
        concat!("Size of: ", stringify!(L_Dna))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dna>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dna))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Dna), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).startx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(startx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).delx as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(delx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dna>())).array as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dna),
            "::",
            stringify!(array)
        )
    );
}
pub type L_DNA = L_Dna;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dnaa {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub dna: *mut *mut L_Dna,
}
#[test]
fn bindgen_test_layout_L_Dnaa() {
    assert_eq!(
        ::std::mem::size_of::<L_Dnaa>(),
        16usize,
        concat!("Size of: ", stringify!(L_Dnaa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dnaa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dnaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dnaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Dnaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dnaa>())).dna as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dnaa),
            "::",
            stringify!(dna)
        )
    );
}
pub type L_DNAA = L_Dnaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_DnaHash {
    pub nbuckets: l_int32,
    pub initsize: l_int32,
    pub dna: *mut *mut L_Dna,
}
#[test]
fn bindgen_test_layout_L_DnaHash() {
    assert_eq!(
        ::std::mem::size_of::<L_DnaHash>(),
        16usize,
        concat!("Size of: ", stringify!(L_DnaHash))
    );
    assert_eq!(
        ::std::mem::align_of::<L_DnaHash>(),
        8usize,
        concat!("Alignment of ", stringify!(L_DnaHash))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).nbuckets as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(nbuckets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).initsize as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(initsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_DnaHash>())).dna as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_DnaHash),
            "::",
            stringify!(dna)
        )
    );
}
pub type L_DNAHASH = L_DnaHash;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sarray {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub refcount: l_int32,
    pub array: *mut *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Sarray() {
    assert_eq!(
        ::std::mem::size_of::<Sarray>(),
        24usize,
        concat!("Size of: ", stringify!(Sarray))
    );
    assert_eq!(
        ::std::mem::align_of::<Sarray>(),
        8usize,
        concat!("Alignment of ", stringify!(Sarray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Sarray), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sarray>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Sarray),
            "::",
            stringify!(array)
        )
    );
}
pub type SARRAY = Sarray;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bytea {
    pub nalloc: size_t,
    pub size: size_t,
    pub refcount: l_int32,
    pub data: *mut l_uint8,
}
#[test]
fn bindgen_test_layout_L_Bytea() {
    assert_eq!(
        ::std::mem::size_of::<L_Bytea>(),
        32usize,
        concat!("Size of: ", stringify!(L_Bytea))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Bytea>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Bytea))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bytea>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bytea),
            "::",
            stringify!(data)
        )
    );
}
pub type L_BYTEA = L_Bytea;
pub const L_LINEAR_INTERP: ::std::os::raw::c_uint = 1;
pub const L_QUADRATIC_INTERP: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_4 = ::std::os::raw::c_uint;
pub const L_CONTINUED_BORDER: ::std::os::raw::c_uint = 1;
pub const L_SLOPE_BORDER: ::std::os::raw::c_uint = 2;
pub const L_MIRRORED_BORDER: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_5 = ::std::os::raw::c_uint;
pub const L_INTEGER_VALUE: ::std::os::raw::c_uint = 1;
pub const L_FLOAT_VALUE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_6 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_ByteBuffer {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub nwritten: l_int32,
    pub array: *mut l_uint8,
}
#[test]
fn bindgen_test_layout_L_ByteBuffer() {
    assert_eq!(
        ::std::mem::size_of::<L_ByteBuffer>(),
        24usize,
        concat!("Size of: ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        ::std::mem::align_of::<L_ByteBuffer>(),
        8usize,
        concat!("Alignment of ", stringify!(L_ByteBuffer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).n as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).nwritten as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(nwritten)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_ByteBuffer>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_ByteBuffer),
            "::",
            stringify!(array)
        )
    );
}
pub type L_BBUFFER = L_ByteBuffer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Hashmap {
    pub nitems: l_int32,
    pub ntogo: l_int32,
    pub maxocc: l_int32,
    pub hashtab: *mut *mut L_Hashitem,
    pub tabsize: l_int32,
}
#[test]
fn bindgen_test_layout_L_Hashmap() {
    assert_eq!(
        ::std::mem::size_of::<L_Hashmap>(),
        32usize,
        concat!("Size of: ", stringify!(L_Hashmap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Hashmap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Hashmap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).nitems as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(nitems)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).ntogo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(ntogo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).maxocc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(maxocc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).hashtab as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(hashtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashmap>())).tabsize as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashmap),
            "::",
            stringify!(tabsize)
        )
    );
}
pub type L_HASHMAP = L_Hashmap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Hashitem {
    pub key: l_uint64,
    pub val: l_uint64,
    pub count: l_int32,
    pub next: *mut L_Hashitem,
}
#[test]
fn bindgen_test_layout_L_Hashitem() {
    assert_eq!(
        ::std::mem::size_of::<L_Hashitem>(),
        32usize,
        concat!("Size of: ", stringify!(L_Hashitem))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Hashitem>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Hashitem))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashitem>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashitem>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashitem>())).count as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Hashitem>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Hashitem),
            "::",
            stringify!(next)
        )
    );
}
pub type L_HASHITEM = L_Hashitem;
pub const L_UNDEFINED: ::std::os::raw::c_uint = 0;
pub const L_HMAP_CHECK: ::std::os::raw::c_uint = 1;
pub const L_HMAP_CREATE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_7 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Heap {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub direction: l_int32,
}
#[test]
fn bindgen_test_layout_L_Heap() {
    assert_eq!(
        ::std::mem::size_of::<L_Heap>(),
        24usize,
        concat!("Size of: ", stringify!(L_Heap))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Heap>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Heap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).n as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(L_Heap), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Heap>())).direction as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Heap),
            "::",
            stringify!(direction)
        )
    );
}
pub type L_HEAP = L_Heap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DoubleLinkedList {
    pub prev: *mut DoubleLinkedList,
    pub next: *mut DoubleLinkedList,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_DoubleLinkedList() {
    assert_eq!(
        ::std::mem::size_of::<DoubleLinkedList>(),
        24usize,
        concat!("Size of: ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        ::std::mem::align_of::<DoubleLinkedList>(),
        8usize,
        concat!("Alignment of ", stringify!(DoubleLinkedList))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DoubleLinkedList>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DoubleLinkedList),
            "::",
            stringify!(data)
        )
    );
}
pub type DLLIST = DoubleLinkedList;
extern "C" {
    pub static MaxInitPtraSize: l_uint32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptra {
    pub nalloc: l_int32,
    pub imax: l_int32,
    pub nactual: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_L_Ptra() {
    assert_eq!(
        ::std::mem::size_of::<L_Ptra>(),
        24usize,
        concat!("Size of: ", stringify!(L_Ptra))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptra>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptra))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).imax as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(imax)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).nactual as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(nactual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptra>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptra),
            "::",
            stringify!(array)
        )
    );
}
pub type L_PTRA = L_Ptra;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Ptraa {
    pub nalloc: l_int32,
    pub ptra: *mut *mut L_Ptra,
}
#[test]
fn bindgen_test_layout_L_Ptraa() {
    assert_eq!(
        ::std::mem::size_of::<L_Ptraa>(),
        16usize,
        concat!("Size of: ", stringify!(L_Ptraa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Ptraa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Ptraa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptraa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptraa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Ptraa>())).ptra as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Ptraa),
            "::",
            stringify!(ptra)
        )
    );
}
pub type L_PTRAA = L_Ptraa;
pub const L_NO_COMPACTION: ::std::os::raw::c_uint = 1;
pub const L_COMPACTION: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_8 = ::std::os::raw::c_uint;
pub const L_AUTO_DOWNSHIFT: ::std::os::raw::c_uint = 0;
pub const L_MIN_DOWNSHIFT: ::std::os::raw::c_uint = 1;
pub const L_FULL_DOWNSHIFT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_9 = ::std::os::raw::c_uint;
pub const L_HANDLE_ONLY: ::std::os::raw::c_uint = 0;
pub const L_REMOVE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Queue {
    pub nalloc: l_int32,
    pub nhead: l_int32,
    pub nelem: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub stack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Queue() {
    assert_eq!(
        ::std::mem::size_of::<L_Queue>(),
        32usize,
        concat!("Size of: ", stringify!(L_Queue))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Queue>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Queue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nhead as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nhead)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).nelem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(nelem)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).array as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Queue>())).stack as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Queue),
            "::",
            stringify!(stack)
        )
    );
}
pub type L_QUEUE = L_Queue;
pub const L_INT_TYPE: ::std::os::raw::c_uint = 1;
pub const L_UINT_TYPE: ::std::os::raw::c_uint = 2;
pub const L_FLOAT_TYPE: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union Rb_Type {
    pub itype: l_int64,
    pub utype: l_uint64,
    pub ftype: l_float64,
    pub ptype: *mut ::std::os::raw::c_void,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_Rb_Type() {
    assert_eq!(
        ::std::mem::size_of::<Rb_Type>(),
        8usize,
        concat!("Size of: ", stringify!(Rb_Type))
    );
    assert_eq!(
        ::std::mem::align_of::<Rb_Type>(),
        8usize,
        concat!("Alignment of ", stringify!(Rb_Type))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).itype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(itype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).utype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(utype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).ftype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(ftype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Rb_Type>())).ptype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Rb_Type),
            "::",
            stringify!(ptype)
        )
    );
}
pub type RB_TYPE = Rb_Type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rbtree {
    pub root: *mut L_Rbtree_Node,
    pub keytype: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree() {
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree>(),
        16usize,
        concat!("Size of: ", stringify!(L_Rbtree))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree>())).root as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree),
            "::",
            stringify!(root)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree>())).keytype as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree),
            "::",
            stringify!(keytype)
        )
    );
}
pub type L_RBTREE = L_Rbtree;
pub type L_AMAP = L_Rbtree;
pub type L_ASET = L_Rbtree;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct L_Rbtree_Node {
    pub key: Rb_Type,
    pub value: Rb_Type,
    pub left: *mut L_Rbtree_Node,
    pub right: *mut L_Rbtree_Node,
    pub parent: *mut L_Rbtree_Node,
    pub color: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rbtree_Node() {
    assert_eq!(
        ::std::mem::size_of::<L_Rbtree_Node>(),
        48usize,
        concat!("Size of: ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rbtree_Node>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rbtree_Node))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).left as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(left)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).right as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(right)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).parent as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rbtree_Node>())).color as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rbtree_Node),
            "::",
            stringify!(color)
        )
    );
}
pub type L_RBTREE_NODE = L_Rbtree_Node;
pub type L_AMAP_NODE = L_Rbtree_Node;
pub type L_ASET_NODE = L_Rbtree_Node;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Stack {
    pub nalloc: l_int32,
    pub n: l_int32,
    pub array: *mut *mut ::std::os::raw::c_void,
    pub auxstack: *mut L_Stack,
}
#[test]
fn bindgen_test_layout_L_Stack() {
    assert_eq!(
        ::std::mem::size_of::<L_Stack>(),
        24usize,
        concat!("Size of: ", stringify!(L_Stack))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Stack>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Stack))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).n as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).array as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Stack>())).auxstack as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Stack),
            "::",
            stringify!(auxstack)
        )
    );
}
pub type L_STACK = L_Stack;
pub const SPLIT_ON_LEADING_WHITE: ::std::os::raw::c_uint = 1;
pub const SPLIT_ON_BLANK_LINE: ::std::os::raw::c_uint = 2;
pub const SPLIT_ON_BOTH: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_12 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Bmf {
    pub pixa: *mut Pixa,
    pub size: l_int32,
    pub directory: *mut ::std::os::raw::c_char,
    pub baseline1: l_int32,
    pub baseline2: l_int32,
    pub baseline3: l_int32,
    pub lineheight: l_int32,
    pub kernwidth: l_int32,
    pub spacewidth: l_int32,
    pub vertlinesep: l_int32,
    pub fonttab: *mut l_int32,
    pub baselinetab: *mut l_int32,
    pub widthtab: *mut l_int32,
}
#[test]
fn bindgen_test_layout_L_Bmf() {
    assert_eq!(
        ::std::mem::size_of::<L_Bmf>(),
        80usize,
        concat!("Size of: ", stringify!(L_Bmf))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Bmf>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Bmf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).pixa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).directory as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(directory)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline1 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline2 as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baseline3 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baseline3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).lineheight as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(lineheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).kernwidth as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(kernwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).spacewidth as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(spacewidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).vertlinesep as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(vertlinesep)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).fonttab as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(fonttab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).baselinetab as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(baselinetab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Bmf>())).widthtab as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Bmf),
            "::",
            stringify!(widthtab)
        )
    );
}
pub type L_BMF = L_Bmf;
pub const CCB_LOCAL_COORDS: ::std::os::raw::c_uint = 1;
pub const CCB_GLOBAL_COORDS: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_13 = ::std::os::raw::c_uint;
pub const CCB_SAVE_ALL_PTS: ::std::os::raw::c_uint = 1;
pub const CCB_SAVE_TURNING_PTS: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_14 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBord {
    pub pix: *mut Pix,
    pub boxa: *mut Boxa,
    pub start: *mut Pta,
    pub refcount: l_int32,
    pub local: *mut Ptaa,
    pub global: *mut Ptaa,
    pub step: *mut Numaa,
    pub splocal: *mut Pta,
    pub spglobal: *mut Pta,
}
#[test]
fn bindgen_test_layout_CCBord() {
    assert_eq!(
        ::std::mem::size_of::<CCBord>(),
        72usize,
        concat!("Size of: ", stringify!(CCBord))
    );
    assert_eq!(
        ::std::mem::align_of::<CCBord>(),
        8usize,
        concat!("Alignment of ", stringify!(CCBord))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).boxa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(boxa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).start as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).refcount as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).local as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(local)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).global as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).step as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).splocal as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(splocal)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBord>())).spglobal as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBord),
            "::",
            stringify!(spglobal)
        )
    );
}
pub type CCBORD = CCBord;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CCBorda {
    pub pix: *mut Pix,
    pub w: l_int32,
    pub h: l_int32,
    pub n: l_int32,
    pub nalloc: l_int32,
    pub ccb: *mut *mut CCBord,
}
#[test]
fn bindgen_test_layout_CCBorda() {
    assert_eq!(
        ::std::mem::size_of::<CCBorda>(),
        32usize,
        concat!("Size of: ", stringify!(CCBorda))
    );
    assert_eq!(
        ::std::mem::align_of::<CCBorda>(),
        8usize,
        concat!("Alignment of ", stringify!(CCBorda))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).w as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).h as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).nalloc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<CCBorda>())).ccb as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(CCBorda),
            "::",
            stringify!(ccb)
        )
    );
}
pub type CCBORDA = CCBorda;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Colorfill {
    pub pixs: *mut Pix,
    pub pixst: *mut Pix,
    pub nx: l_int32,
    pub ny: l_int32,
    pub tw: l_int32,
    pub th: l_int32,
    pub minarea: l_int32,
    pub boxas: *mut Boxa,
    pub pixas: *mut Pixa,
    pub pixam: *mut Pixa,
    pub naa: *mut Numaa,
    pub dnaa: *mut L_Dnaa,
    pub pixadb: *mut Pixa,
}
#[test]
fn bindgen_test_layout_L_Colorfill() {
    assert_eq!(
        ::std::mem::size_of::<L_Colorfill>(),
        88usize,
        concat!("Size of: ", stringify!(L_Colorfill))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Colorfill>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Colorfill))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixst as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).nx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).ny as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).tw as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(tw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).th as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(th)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).minarea as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(minarea)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).boxas as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(boxas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixas as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixam as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixam)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).naa as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(naa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).dnaa as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(dnaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Colorfill>())).pixadb as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Colorfill),
            "::",
            stringify!(pixadb)
        )
    );
}
pub type L_COLORFILL = L_Colorfill;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarpa {
    pub nalloc: l_int32,
    pub maxpage: l_int32,
    pub dewarp: *mut *mut L_Dewarp,
    pub dewarpcache: *mut *mut L_Dewarp,
    pub namodels: *mut Numa,
    pub napages: *mut Numa,
    pub redfactor: l_int32,
    pub sampling: l_int32,
    pub minlines: l_int32,
    pub maxdist: l_int32,
    pub max_linecurv: l_int32,
    pub min_diff_linecurv: l_int32,
    pub max_diff_linecurv: l_int32,
    pub max_edgeslope: l_int32,
    pub max_edgecurv: l_int32,
    pub max_diff_edgecurv: l_int32,
    pub useboth: l_int32,
    pub check_columns: l_int32,
    pub modelsready: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarpa() {
    assert_eq!(
        ::std::mem::size_of::<L_Dewarpa>(),
        96usize,
        concat!("Size of: ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarpa>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarpa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).nalloc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).maxpage as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(maxpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).dewarp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(dewarp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).dewarpcache as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(dewarpcache)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).namodels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(namodels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).napages as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(napages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).redfactor as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(redfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).sampling as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).minlines as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(minlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).maxdist as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(maxdist)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_linecurv as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).min_diff_linecurv as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(min_diff_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_diff_linecurv as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_diff_linecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_edgeslope as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_edgeslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_edgecurv as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_edgecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).max_diff_edgecurv as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(max_diff_edgecurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).useboth as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(useboth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).check_columns as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(check_columns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarpa>())).modelsready as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarpa),
            "::",
            stringify!(modelsready)
        )
    );
}
pub type L_DEWARPA = L_Dewarpa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Dewarp {
    pub dewa: *mut L_Dewarpa,
    pub pixs: *mut Pix,
    pub sampvdispar: *mut FPix,
    pub samphdispar: *mut FPix,
    pub sampydispar: *mut FPix,
    pub fullvdispar: *mut FPix,
    pub fullhdispar: *mut FPix,
    pub fullydispar: *mut FPix,
    pub namidys: *mut Numa,
    pub nacurves: *mut Numa,
    pub w: l_int32,
    pub h: l_int32,
    pub pageno: l_int32,
    pub sampling: l_int32,
    pub redfactor: l_int32,
    pub minlines: l_int32,
    pub nlines: l_int32,
    pub mincurv: l_int32,
    pub maxcurv: l_int32,
    pub leftslope: l_int32,
    pub rightslope: l_int32,
    pub leftcurv: l_int32,
    pub rightcurv: l_int32,
    pub nx: l_int32,
    pub ny: l_int32,
    pub hasref: l_int32,
    pub refpage: l_int32,
    pub vsuccess: l_int32,
    pub hsuccess: l_int32,
    pub ysuccess: l_int32,
    pub vvalid: l_int32,
    pub hvalid: l_int32,
    pub skip_horiz: l_int32,
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_Dewarp() {
    assert_eq!(
        ::std::mem::size_of::<L_Dewarp>(),
        176usize,
        concat!("Size of: ", stringify!(L_Dewarp))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Dewarp>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Dewarp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).dewa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(dewa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).pixs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampvdispar as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampvdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).samphdispar as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(samphdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampydispar as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampydispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullvdispar as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullvdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullhdispar as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullhdispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).fullydispar as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(fullydispar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).namidys as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(namidys)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nacurves as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nacurves)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).w as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).h as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).pageno as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(pageno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).sampling as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(sampling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).redfactor as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(redfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).minlines as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(minlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nlines as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nlines)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).mincurv as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(mincurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).maxcurv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(maxcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).leftslope as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(leftslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).rightslope as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(rightslope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).leftcurv as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(leftcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).rightcurv as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(rightcurv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).nx as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).ny as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hasref as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hasref)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).refpage as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(refpage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).vsuccess as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(vsuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hsuccess as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hsuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).ysuccess as *const _ as usize },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(ysuccess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).vvalid as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(vvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).hvalid as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(hvalid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).skip_horiz as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(skip_horiz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Dewarp>())).debug as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Dewarp),
            "::",
            stringify!(debug)
        )
    );
}
pub type L_DEWARP = L_Dewarp;
pub const GPLOT_STYLE_GPLOT_LINES: GPLOT_STYLE = 0;
pub const GPLOT_STYLE_GPLOT_POINTS: GPLOT_STYLE = 1;
pub const GPLOT_STYLE_GPLOT_IMPULSES: GPLOT_STYLE = 2;
pub const GPLOT_STYLE_GPLOT_LINESPOINTS: GPLOT_STYLE = 3;
pub const GPLOT_STYLE_GPLOT_DOTS: GPLOT_STYLE = 4;
pub type GPLOT_STYLE = ::std::os::raw::c_uint;
pub const GPLOT_OUTPUT_GPLOT_NONE: GPLOT_OUTPUT = 0;
pub const GPLOT_OUTPUT_GPLOT_PNG: GPLOT_OUTPUT = 1;
pub const GPLOT_OUTPUT_GPLOT_PS: GPLOT_OUTPUT = 2;
pub const GPLOT_OUTPUT_GPLOT_EPS: GPLOT_OUTPUT = 3;
pub const GPLOT_OUTPUT_GPLOT_LATEX: GPLOT_OUTPUT = 4;
pub const GPLOT_OUTPUT_GPLOT_PNM: GPLOT_OUTPUT = 5;
pub type GPLOT_OUTPUT = ::std::os::raw::c_uint;
pub const GPLOT_SCALING_GPLOT_LINEAR_SCALE: GPLOT_SCALING = 0;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X: GPLOT_SCALING = 1;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_Y: GPLOT_SCALING = 2;
pub const GPLOT_SCALING_GPLOT_LOG_SCALE_X_Y: GPLOT_SCALING = 3;
pub type GPLOT_SCALING = ::std::os::raw::c_uint;
extern "C" {
    pub static mut gplotstylenames: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub static mut gplotfileoutputs: [*const ::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GPlot {
    pub rootname: *mut ::std::os::raw::c_char,
    pub cmdname: *mut ::std::os::raw::c_char,
    pub cmddata: *mut Sarray,
    pub datanames: *mut Sarray,
    pub plotdata: *mut Sarray,
    pub plotlabels: *mut Sarray,
    pub plotstyles: *mut Numa,
    pub nplots: l_int32,
    pub outname: *mut ::std::os::raw::c_char,
    pub outformat: l_int32,
    pub scaling: l_int32,
    pub title: *mut ::std::os::raw::c_char,
    pub xlabel: *mut ::std::os::raw::c_char,
    pub ylabel: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_GPlot() {
    assert_eq!(
        ::std::mem::size_of::<GPlot>(),
        104usize,
        concat!("Size of: ", stringify!(GPlot))
    );
    assert_eq!(
        ::std::mem::align_of::<GPlot>(),
        8usize,
        concat!("Alignment of ", stringify!(GPlot))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).rootname as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(rootname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).cmdname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(cmdname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).cmddata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(cmddata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).datanames as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(datanames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plotdata as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotdata)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plotlabels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotlabels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).plotstyles as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(plotstyles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).nplots as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(nplots)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).outname as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(outname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).outformat as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(outformat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).scaling as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(scaling)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).title as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).xlabel as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(xlabel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<GPlot>())).ylabel as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(GPlot),
            "::",
            stringify!(ylabel)
        )
    );
}
pub type GPLOT = GPlot;
pub const IFF_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const IFF_BMP: ::std::os::raw::c_uint = 1;
pub const IFF_JFIF_JPEG: ::std::os::raw::c_uint = 2;
pub const IFF_PNG: ::std::os::raw::c_uint = 3;
pub const IFF_TIFF: ::std::os::raw::c_uint = 4;
pub const IFF_TIFF_PACKBITS: ::std::os::raw::c_uint = 5;
pub const IFF_TIFF_RLE: ::std::os::raw::c_uint = 6;
pub const IFF_TIFF_G3: ::std::os::raw::c_uint = 7;
pub const IFF_TIFF_G4: ::std::os::raw::c_uint = 8;
pub const IFF_TIFF_LZW: ::std::os::raw::c_uint = 9;
pub const IFF_TIFF_ZIP: ::std::os::raw::c_uint = 10;
pub const IFF_PNM: ::std::os::raw::c_uint = 11;
pub const IFF_PS: ::std::os::raw::c_uint = 12;
pub const IFF_GIF: ::std::os::raw::c_uint = 13;
pub const IFF_JP2: ::std::os::raw::c_uint = 14;
pub const IFF_WEBP: ::std::os::raw::c_uint = 15;
pub const IFF_LPDF: ::std::os::raw::c_uint = 16;
pub const IFF_TIFF_JPEG: ::std::os::raw::c_uint = 17;
pub const IFF_DEFAULT: ::std::os::raw::c_uint = 18;
pub const IFF_SPIX: ::std::os::raw::c_uint = 19;
pub type _bindgen_ty_15 = ::std::os::raw::c_uint;
pub const BMP_ID: ::std::os::raw::c_uint = 19778;
pub const TIFF_BIGEND_ID: ::std::os::raw::c_uint = 19789;
pub const TIFF_LITTLEEND_ID: ::std::os::raw::c_uint = 18761;
pub type _bindgen_ty_16 = ::std::os::raw::c_uint;
pub const L_JPEG_READ_LUMINANCE: ::std::os::raw::c_uint = 1;
pub const L_JPEG_CONTINUE_WITH_BAD_DATA: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_17 = ::std::os::raw::c_uint;
pub const L_J2K_CODEC: ::std::os::raw::c_uint = 1;
pub const L_JP2_CODEC: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_18 = ::std::os::raw::c_uint;
pub const L_DEFAULT_ENCODE: ::std::os::raw::c_uint = 0;
pub const L_JPEG_ENCODE: ::std::os::raw::c_uint = 1;
pub const L_G4_ENCODE: ::std::os::raw::c_uint = 2;
pub const L_FLATE_ENCODE: ::std::os::raw::c_uint = 3;
pub const L_JP2K_ENCODE: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_19 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Compressed_Data {
    pub type_: l_int32,
    pub datacomp: *mut l_uint8,
    pub nbytescomp: size_t,
    pub data85: *mut ::std::os::raw::c_char,
    pub nbytes85: size_t,
    pub cmapdata85: *mut ::std::os::raw::c_char,
    pub cmapdatahex: *mut ::std::os::raw::c_char,
    pub ncolors: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub bps: l_int32,
    pub spp: l_int32,
    pub minisblack: l_int32,
    pub predictor: l_int32,
    pub nbytes: size_t,
    pub res: l_int32,
}
#[test]
fn bindgen_test_layout_L_Compressed_Data() {
    assert_eq!(
        ::std::mem::size_of::<L_Compressed_Data>(),
        104usize,
        concat!("Size of: ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Compressed_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Compressed_Data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).datacomp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(datacomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytescomp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytescomp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).data85 as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(data85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytes85 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytes85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).cmapdata85 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(cmapdata85)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).cmapdatahex as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(cmapdatahex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).ncolors as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(ncolors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).w as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).h as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).bps as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(bps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).spp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(spp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).minisblack as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(minisblack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).predictor as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(predictor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).nbytes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(nbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Compressed_Data>())).res as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Compressed_Data),
            "::",
            stringify!(res)
        )
    );
}
pub type L_COMP_DATA = L_Compressed_Data;
pub const L_FIRST_IMAGE: ::std::os::raw::c_uint = 1;
pub const L_NEXT_IMAGE: ::std::os::raw::c_uint = 2;
pub const L_LAST_IMAGE: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_20 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Pdf_Data {
    pub title: *mut ::std::os::raw::c_char,
    pub n: l_int32,
    pub ncmap: l_int32,
    pub cida: *mut L_Ptra,
    pub id: *mut ::std::os::raw::c_char,
    pub obj1: *mut ::std::os::raw::c_char,
    pub obj2: *mut ::std::os::raw::c_char,
    pub obj3: *mut ::std::os::raw::c_char,
    pub obj4: *mut ::std::os::raw::c_char,
    pub obj5: *mut ::std::os::raw::c_char,
    pub poststream: *mut ::std::os::raw::c_char,
    pub trailer: *mut ::std::os::raw::c_char,
    pub xy: *mut Pta,
    pub wh: *mut Pta,
    pub mediabox: *mut Box,
    pub saprex: *mut Sarray,
    pub sacmap: *mut Sarray,
    pub objsize: *mut L_Dna,
    pub objloc: *mut L_Dna,
    pub xrefloc: l_int32,
}
#[test]
fn bindgen_test_layout_L_Pdf_Data() {
    assert_eq!(
        ::std::mem::size_of::<L_Pdf_Data>(),
        152usize,
        concat!("Size of: ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Pdf_Data>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Pdf_Data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).title as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(title)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).n as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).ncmap as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(ncmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).cida as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(cida)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj1 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj3 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj4 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).obj5 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(obj5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).poststream as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(poststream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).trailer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(trailer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).xy as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).wh as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(wh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).mediabox as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(mediabox)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).saprex as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(saprex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).sacmap as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(sacmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).objsize as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(objsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).objloc as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(objloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Pdf_Data>())).xrefloc as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Pdf_Data),
            "::",
            stringify!(xrefloc)
        )
    );
}
pub type L_PDF_DATA = L_Pdf_Data;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbClasser {
    pub safiles: *mut Sarray,
    pub method: l_int32,
    pub components: l_int32,
    pub maxwidth: l_int32,
    pub maxheight: l_int32,
    pub npages: l_int32,
    pub baseindex: l_int32,
    pub nacomps: *mut Numa,
    pub sizehaus: l_int32,
    pub rankhaus: l_float32,
    pub thresh: l_float32,
    pub weightfactor: l_float32,
    pub naarea: *mut Numa,
    pub w: l_int32,
    pub h: l_int32,
    pub nclass: l_int32,
    pub keep_pixaa: l_int32,
    pub pixaa: *mut Pixaa,
    pub pixat: *mut Pixa,
    pub pixatd: *mut Pixa,
    pub dahash: *mut L_DnaHash,
    pub nafgt: *mut Numa,
    pub ptac: *mut Pta,
    pub ptact: *mut Pta,
    pub naclass: *mut Numa,
    pub napage: *mut Numa,
    pub ptaul: *mut Pta,
    pub ptall: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbClasser() {
    assert_eq!(
        ::std::mem::size_of::<JbClasser>(),
        168usize,
        concat!("Size of: ", stringify!(JbClasser))
    );
    assert_eq!(
        ::std::mem::align_of::<JbClasser>(),
        8usize,
        concat!("Alignment of ", stringify!(JbClasser))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).safiles as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(safiles)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).method as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(method)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).components as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(components)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).maxwidth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).maxheight as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(maxheight)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).npages as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).baseindex as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(baseindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nacomps as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nacomps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).sizehaus as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(sizehaus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).rankhaus as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(rankhaus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).thresh as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(thresh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).weightfactor as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(weightfactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).naarea as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(naarea)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).w as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).h as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nclass as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).keep_pixaa as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(keep_pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixaa as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixat as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).pixatd as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(pixatd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).dahash as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(dahash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).nafgt as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(nafgt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptac as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptact as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptact)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).naclass as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(naclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).napage as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(napage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptaul as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptaul)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbClasser>())).ptall as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(JbClasser),
            "::",
            stringify!(ptall)
        )
    );
}
pub type JBCLASSER = JbClasser;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct JbData {
    pub pix: *mut Pix,
    pub npages: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub nclass: l_int32,
    pub latticew: l_int32,
    pub latticeh: l_int32,
    pub naclass: *mut Numa,
    pub napage: *mut Numa,
    pub ptaul: *mut Pta,
}
#[test]
fn bindgen_test_layout_JbData() {
    assert_eq!(
        ::std::mem::size_of::<JbData>(),
        56usize,
        concat!("Size of: ", stringify!(JbData))
    );
    assert_eq!(
        ::std::mem::align_of::<JbData>(),
        8usize,
        concat!("Alignment of ", stringify!(JbData))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).npages as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(npages)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).w as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(JbData), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).h as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(JbData), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).nclass as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(nclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).latticew as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(latticew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).latticeh as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(latticeh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).naclass as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(naclass)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).napage as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(napage)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<JbData>())).ptaul as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(JbData),
            "::",
            stringify!(ptaul)
        )
    );
}
pub type JBDATA = JbData;
pub const JB_RANKHAUS: ::std::os::raw::c_uint = 0;
pub const JB_CORRELATION: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_21 = ::std::os::raw::c_uint;
pub const JB_CONN_COMPS: ::std::os::raw::c_uint = 0;
pub const JB_CHARACTERS: ::std::os::raw::c_uint = 1;
pub const JB_WORDS: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_22 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sel {
    pub sy: l_int32,
    pub sx: l_int32,
    pub cy: l_int32,
    pub cx: l_int32,
    pub data: *mut *mut l_int32,
    pub name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_Sel() {
    assert_eq!(
        ::std::mem::size_of::<Sel>(),
        32usize,
        concat!("Size of: ", stringify!(Sel))
    );
    assert_eq!(
        ::std::mem::align_of::<Sel>(),
        8usize,
        concat!("Alignment of ", stringify!(Sel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).sy as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).sx as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(sx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).cy as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cy))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).cx as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(cx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).data as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sel>())).name as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Sel), "::", stringify!(name))
    );
}
pub type SEL = Sel;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sela {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub sel: *mut *mut Sel,
}
#[test]
fn bindgen_test_layout_Sela() {
    assert_eq!(
        ::std::mem::size_of::<Sela>(),
        16usize,
        concat!("Size of: ", stringify!(Sela))
    );
    assert_eq!(
        ::std::mem::align_of::<Sela>(),
        8usize,
        concat!("Alignment of ", stringify!(Sela))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Sela), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Sela),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Sela>())).sel as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Sela), "::", stringify!(sel))
    );
}
pub type SELA = Sela;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Kernel {
    pub sy: l_int32,
    pub sx: l_int32,
    pub cy: l_int32,
    pub cx: l_int32,
    pub data: *mut *mut l_float32,
}
#[test]
fn bindgen_test_layout_L_Kernel() {
    assert_eq!(
        ::std::mem::size_of::<L_Kernel>(),
        24usize,
        concat!("Size of: ", stringify!(L_Kernel))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Kernel>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Kernel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).sy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(sy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).sx as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(sx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).cy as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(cy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).cx as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(cx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Kernel>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Kernel),
            "::",
            stringify!(data)
        )
    );
}
pub type L_KERNEL = L_Kernel;
pub const SYMMETRIC_MORPH_BC: ::std::os::raw::c_uint = 0;
pub const ASYMMETRIC_MORPH_BC: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_23 = ::std::os::raw::c_uint;
pub const SEL_DONT_CARE: ::std::os::raw::c_uint = 0;
pub const SEL_HIT: ::std::os::raw::c_uint = 1;
pub const SEL_MISS: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_24 = ::std::os::raw::c_uint;
pub const L_RUN_OFF: ::std::os::raw::c_uint = 0;
pub const L_RUN_ON: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_25 = ::std::os::raw::c_uint;
pub const L_HORIZ: ::std::os::raw::c_uint = 1;
pub const L_VERT: ::std::os::raw::c_uint = 2;
pub const L_BOTH_DIRECTIONS: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_26 = ::std::os::raw::c_uint;
pub const L_MORPH_DILATE: ::std::os::raw::c_uint = 1;
pub const L_MORPH_ERODE: ::std::os::raw::c_uint = 2;
pub const L_MORPH_OPEN: ::std::os::raw::c_uint = 3;
pub const L_MORPH_CLOSE: ::std::os::raw::c_uint = 4;
pub const L_MORPH_HMT: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_27 = ::std::os::raw::c_uint;
pub const L_LINEAR_SCALE: ::std::os::raw::c_uint = 1;
pub const L_LOG_SCALE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_28 = ::std::os::raw::c_uint;
pub const L_TOPHAT_WHITE: ::std::os::raw::c_uint = 0;
pub const L_TOPHAT_BLACK: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_29 = ::std::os::raw::c_uint;
pub const L_ARITH_ADD: ::std::os::raw::c_uint = 1;
pub const L_ARITH_SUBTRACT: ::std::os::raw::c_uint = 2;
pub const L_ARITH_MULTIPLY: ::std::os::raw::c_uint = 3;
pub const L_ARITH_DIVIDE: ::std::os::raw::c_uint = 4;
pub const L_UNION: ::std::os::raw::c_uint = 5;
pub const L_INTERSECTION: ::std::os::raw::c_uint = 6;
pub const L_SUBTRACTION: ::std::os::raw::c_uint = 7;
pub const L_EXCLUSIVE_OR: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_30 = ::std::os::raw::c_uint;
pub const L_CHOOSE_MIN: ::std::os::raw::c_uint = 1;
pub const L_CHOOSE_MAX: ::std::os::raw::c_uint = 2;
pub const L_CHOOSE_MAXDIFF: ::std::os::raw::c_uint = 3;
pub const L_CHOOSE_MIN_BOOST: ::std::os::raw::c_uint = 4;
pub const L_CHOOSE_MAX_BOOST: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_31 = ::std::os::raw::c_uint;
pub const L_BOUNDARY_BG: ::std::os::raw::c_uint = 1;
pub const L_BOUNDARY_FG: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_32 = ::std::os::raw::c_uint;
pub const L_COMPARE_XOR: ::std::os::raw::c_uint = 1;
pub const L_COMPARE_SUBTRACT: ::std::os::raw::c_uint = 2;
pub const L_COMPARE_ABS_DIFF: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_33 = ::std::os::raw::c_uint;
pub const ADDED_BORDER: l_int32 = 32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pix {
    pub w: l_uint32,
    pub h: l_uint32,
    pub d: l_uint32,
    pub spp: l_uint32,
    pub wpl: l_uint32,
    pub refcount: l_uint32,
    pub xres: l_int32,
    pub yres: l_int32,
    pub informat: l_int32,
    pub special: l_int32,
    pub text: *mut ::std::os::raw::c_char,
    pub colormap: *mut PixColormap,
    pub data: *mut l_uint32,
}
#[test]
fn bindgen_test_layout_Pix() {
    assert_eq!(
        ::std::mem::size_of::<Pix>(),
        64usize,
        concat!("Size of: ", stringify!(Pix))
    );
    assert_eq!(
        ::std::mem::align_of::<Pix>(),
        8usize,
        concat!("Alignment of ", stringify!(Pix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).d as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(d))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).spp as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(spp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).wpl as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).refcount as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).xres as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(xres))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).yres as *const _ as usize },
        28usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(yres))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).informat as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(informat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).special as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(special)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).text as *const _ as usize },
        40usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(text))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).colormap as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Pix),
            "::",
            stringify!(colormap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pix>())).data as *const _ as usize },
        56usize,
        concat!("Offset of field: ", stringify!(Pix), "::", stringify!(data))
    );
}
pub type PIX = Pix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixColormap {
    pub array: *mut ::std::os::raw::c_void,
    pub depth: l_int32,
    pub nalloc: l_int32,
    pub n: l_int32,
}
#[test]
fn bindgen_test_layout_PixColormap() {
    assert_eq!(
        ::std::mem::size_of::<PixColormap>(),
        24usize,
        concat!("Size of: ", stringify!(PixColormap))
    );
    assert_eq!(
        ::std::mem::align_of::<PixColormap>(),
        8usize,
        concat!("Alignment of ", stringify!(PixColormap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).array as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(array)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).depth as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).nalloc as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixColormap>())).n as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixColormap),
            "::",
            stringify!(n)
        )
    );
}
pub type PIXCMAP = PixColormap;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RGBA_Quad {
    pub blue: l_uint8,
    pub green: l_uint8,
    pub red: l_uint8,
    pub alpha: l_uint8,
}
#[test]
fn bindgen_test_layout_RGBA_Quad() {
    assert_eq!(
        ::std::mem::size_of::<RGBA_Quad>(),
        4usize,
        concat!("Size of: ", stringify!(RGBA_Quad))
    );
    assert_eq!(
        ::std::mem::align_of::<RGBA_Quad>(),
        1usize,
        concat!("Alignment of ", stringify!(RGBA_Quad))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).blue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(blue)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).green as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(green)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).red as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(red)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<RGBA_Quad>())).alpha as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(RGBA_Quad),
            "::",
            stringify!(alpha)
        )
    );
}
pub type RGBA_QUAD = RGBA_Quad;
pub const COLOR_RED: ::std::os::raw::c_uint = 0;
pub const COLOR_GREEN: ::std::os::raw::c_uint = 1;
pub const COLOR_BLUE: ::std::os::raw::c_uint = 2;
pub const L_ALPHA_CHANNEL: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_34 = ::std::os::raw::c_uint;
pub const L_RED_SHIFT: l_int32 = 24;
pub const L_GREEN_SHIFT: l_int32 = 16;
pub const L_BLUE_SHIFT: l_int32 = 8;
pub const L_ALPHA_SHIFT: l_int32 = 0;
pub const L_DRAW_RED: ::std::os::raw::c_uint = 0;
pub const L_DRAW_GREEN: ::std::os::raw::c_uint = 1;
pub const L_DRAW_BLUE: ::std::os::raw::c_uint = 2;
pub const L_DRAW_SPECIFIED: ::std::os::raw::c_uint = 3;
pub const L_DRAW_RGB: ::std::os::raw::c_uint = 4;
pub const L_DRAW_RANDOM: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_35 = ::std::os::raw::c_uint;
pub const L_RED_WEIGHT: l_float32 = 0.30000001192092896;
pub const L_GREEN_WEIGHT: l_float32 = 0.5;
pub const L_BLUE_WEIGHT: l_float32 = 0.20000000298023224;
pub const REMOVE_CMAP_TO_BINARY: ::std::os::raw::c_uint = 0;
pub const REMOVE_CMAP_TO_GRAYSCALE: ::std::os::raw::c_uint = 1;
pub const REMOVE_CMAP_TO_FULL_COLOR: ::std::os::raw::c_uint = 2;
pub const REMOVE_CMAP_WITH_ALPHA: ::std::os::raw::c_uint = 3;
pub const REMOVE_CMAP_BASED_ON_SRC: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_36 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub refcount: l_uint32,
    pub pix: *mut *mut Pix,
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_Pixa() {
    assert_eq!(
        ::std::mem::size_of::<Pixa>(),
        32usize,
        concat!("Size of: ", stringify!(Pixa))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixa>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).pix as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pixa), "::", stringify!(pix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixa>())).boxa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXA = Pixa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixaa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub pixa: *mut *mut Pixa,
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_Pixaa() {
    assert_eq!(
        ::std::mem::size_of::<Pixaa>(),
        24usize,
        concat!("Size of: ", stringify!(Pixaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).pixa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixaa>())).boxa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixaa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXAA = Pixaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Box {
    pub x: l_int32,
    pub y: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub refcount: l_uint32,
}
#[test]
fn bindgen_test_layout_Box() {
    assert_eq!(
        ::std::mem::size_of::<Box>(),
        20usize,
        concat!("Size of: ", stringify!(Box))
    );
    assert_eq!(
        ::std::mem::align_of::<Box>(),
        4usize,
        concat!("Alignment of ", stringify!(Box))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).x as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).y as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).w as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).h as *const _ as usize },
        12usize,
        concat!("Offset of field: ", stringify!(Box), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Box>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Box),
            "::",
            stringify!(refcount)
        )
    );
}
pub type BOX = Box;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub refcount: l_uint32,
    pub box_: *mut *mut Box,
}
#[test]
fn bindgen_test_layout_Boxa() {
    assert_eq!(
        ::std::mem::size_of::<Boxa>(),
        24usize,
        concat!("Size of: ", stringify!(Boxa))
    );
    assert_eq!(
        ::std::mem::align_of::<Boxa>(),
        8usize,
        concat!("Alignment of ", stringify!(Boxa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Boxa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxa>())).box_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxa),
            "::",
            stringify!(box_)
        )
    );
}
pub type BOXA = Boxa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Boxaa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub boxa: *mut *mut Boxa,
}
#[test]
fn bindgen_test_layout_Boxaa() {
    assert_eq!(
        ::std::mem::size_of::<Boxaa>(),
        16usize,
        concat!("Size of: ", stringify!(Boxaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Boxaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Boxaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Boxaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Boxaa>())).boxa as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Boxaa),
            "::",
            stringify!(boxa)
        )
    );
}
pub type BOXAA = Boxaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pta {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub refcount: l_uint32,
    pub x: *mut l_float32,
    pub y: *mut l_float32,
}
#[test]
fn bindgen_test_layout_Pta() {
    assert_eq!(
        ::std::mem::size_of::<Pta>(),
        32usize,
        concat!("Size of: ", stringify!(Pta))
    );
    assert_eq!(
        ::std::mem::align_of::<Pta>(),
        8usize,
        concat!("Alignment of ", stringify!(Pta))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Pta),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pta),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).x as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pta>())).y as *const _ as usize },
        24usize,
        concat!("Offset of field: ", stringify!(Pta), "::", stringify!(y))
    );
}
pub type PTA = Pta;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Ptaa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub pta: *mut *mut Pta,
}
#[test]
fn bindgen_test_layout_Ptaa() {
    assert_eq!(
        ::std::mem::size_of::<Ptaa>(),
        16usize,
        concat!("Size of: ", stringify!(Ptaa))
    );
    assert_eq!(
        ::std::mem::align_of::<Ptaa>(),
        8usize,
        concat!("Alignment of ", stringify!(Ptaa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Ptaa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Ptaa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Ptaa>())).pta as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(Ptaa), "::", stringify!(pta))
    );
}
pub type PTAA = Ptaa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pixacc {
    pub w: l_int32,
    pub h: l_int32,
    pub offset: l_int32,
    pub pix: *mut Pix,
}
#[test]
fn bindgen_test_layout_Pixacc() {
    assert_eq!(
        ::std::mem::size_of::<Pixacc>(),
        24usize,
        concat!("Size of: ", stringify!(Pixacc))
    );
    assert_eq!(
        ::std::mem::align_of::<Pixacc>(),
        8usize,
        concat!("Alignment of ", stringify!(Pixacc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Pixacc), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Pixacc), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixacc),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Pixacc>())).pix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Pixacc),
            "::",
            stringify!(pix)
        )
    );
}
pub type PIXACC = Pixacc;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixTiling {
    pub pix: *mut Pix,
    pub nx: l_int32,
    pub ny: l_int32,
    pub w: l_int32,
    pub h: l_int32,
    pub xoverlap: l_int32,
    pub yoverlap: l_int32,
    pub strip: l_int32,
}
#[test]
fn bindgen_test_layout_PixTiling() {
    assert_eq!(
        ::std::mem::size_of::<PixTiling>(),
        40usize,
        concat!("Size of: ", stringify!(PixTiling))
    );
    assert_eq!(
        ::std::mem::align_of::<PixTiling>(),
        8usize,
        concat!("Alignment of ", stringify!(PixTiling))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).pix as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(pix)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).nx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(nx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).ny as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(ny)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).w as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).h as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).xoverlap as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(xoverlap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).yoverlap as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(yoverlap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixTiling>())).strip as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PixTiling),
            "::",
            stringify!(strip)
        )
    );
}
pub type PIXTILING = PixTiling;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPix {
    pub w: l_int32,
    pub h: l_int32,
    pub wpl: l_int32,
    pub refcount: l_uint32,
    pub xres: l_int32,
    pub yres: l_int32,
    pub data: *mut l_float32,
}
#[test]
fn bindgen_test_layout_FPix() {
    assert_eq!(
        ::std::mem::size_of::<FPix>(),
        32usize,
        concat!("Size of: ", stringify!(FPix))
    );
    assert_eq!(
        ::std::mem::align_of::<FPix>(),
        8usize,
        concat!("Alignment of ", stringify!(FPix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).wpl as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(FPix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).refcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).xres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).yres as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPix>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(FPix),
            "::",
            stringify!(data)
        )
    );
}
pub type FPIX = FPix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FPixa {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub refcount: l_uint32,
    pub fpix: *mut *mut FPix,
}
#[test]
fn bindgen_test_layout_FPixa() {
    assert_eq!(
        ::std::mem::size_of::<FPixa>(),
        24usize,
        concat!("Size of: ", stringify!(FPixa))
    );
    assert_eq!(
        ::std::mem::align_of::<FPixa>(),
        8usize,
        concat!("Alignment of ", stringify!(FPixa))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).n as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(FPixa), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).refcount as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FPixa>())).fpix as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FPixa),
            "::",
            stringify!(fpix)
        )
    );
}
pub type FPIXA = FPixa;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DPix {
    pub w: l_int32,
    pub h: l_int32,
    pub wpl: l_int32,
    pub refcount: l_uint32,
    pub xres: l_int32,
    pub yres: l_int32,
    pub data: *mut l_float64,
}
#[test]
fn bindgen_test_layout_DPix() {
    assert_eq!(
        ::std::mem::size_of::<DPix>(),
        32usize,
        concat!("Size of: ", stringify!(DPix))
    );
    assert_eq!(
        ::std::mem::align_of::<DPix>(),
        8usize,
        concat!("Alignment of ", stringify!(DPix))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).w as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(w))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).h as *const _ as usize },
        4usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(h))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).wpl as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(DPix), "::", stringify!(wpl))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).refcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).xres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).yres as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DPix>())).data as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(DPix),
            "::",
            stringify!(data)
        )
    );
}
pub type DPIX = DPix;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixComp {
    pub w: l_int32,
    pub h: l_int32,
    pub d: l_int32,
    pub xres: l_int32,
    pub yres: l_int32,
    pub comptype: l_int32,
    pub text: *mut ::std::os::raw::c_char,
    pub cmapflag: l_int32,
    pub data: *mut l_uint8,
    pub size: size_t,
}
#[test]
fn bindgen_test_layout_PixComp() {
    assert_eq!(
        ::std::mem::size_of::<PixComp>(),
        56usize,
        concat!("Size of: ", stringify!(PixComp))
    );
    assert_eq!(
        ::std::mem::align_of::<PixComp>(),
        8usize,
        concat!("Alignment of ", stringify!(PixComp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).w as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).h as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).xres as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(xres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).yres as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(yres)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).comptype as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(comptype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).text as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).cmapflag as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(cmapflag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixComp>())).size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PixComp),
            "::",
            stringify!(size)
        )
    );
}
pub type PIXC = PixComp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PixaComp {
    pub n: l_int32,
    pub nalloc: l_int32,
    pub offset: l_int32,
    pub pixc: *mut *mut PixComp,
    pub boxa: *mut Boxa,
}
#[test]
fn bindgen_test_layout_PixaComp() {
    assert_eq!(
        ::std::mem::size_of::<PixaComp>(),
        32usize,
        concat!("Size of: ", stringify!(PixaComp))
    );
    assert_eq!(
        ::std::mem::align_of::<PixaComp>(),
        8usize,
        concat!("Alignment of ", stringify!(PixaComp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).n as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).nalloc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(nalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).pixc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(pixc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<PixaComp>())).boxa as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PixaComp),
            "::",
            stringify!(boxa)
        )
    );
}
pub type PIXAC = PixaComp;
pub const L_NOCOPY: ::std::os::raw::c_uint = 0;
pub const L_INSERT: ::std::os::raw::c_uint = 0;
pub const L_COPY: ::std::os::raw::c_uint = 1;
pub const L_CLONE: ::std::os::raw::c_uint = 2;
pub const L_COPY_CLONE: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_37 = ::std::os::raw::c_uint;
pub const L_SHELL_SORT: ::std::os::raw::c_uint = 1;
pub const L_BIN_SORT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_38 = ::std::os::raw::c_uint;
pub const L_SORT_INCREASING: ::std::os::raw::c_uint = 1;
pub const L_SORT_DECREASING: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_39 = ::std::os::raw::c_uint;
pub const L_SORT_BY_X: ::std::os::raw::c_uint = 1;
pub const L_SORT_BY_Y: ::std::os::raw::c_uint = 2;
pub const L_SORT_BY_RIGHT: ::std::os::raw::c_uint = 3;
pub const L_SORT_BY_BOT: ::std::os::raw::c_uint = 4;
pub const L_SORT_BY_WIDTH: ::std::os::raw::c_uint = 5;
pub const L_SORT_BY_HEIGHT: ::std::os::raw::c_uint = 6;
pub const L_SORT_BY_MIN_DIMENSION: ::std::os::raw::c_uint = 7;
pub const L_SORT_BY_MAX_DIMENSION: ::std::os::raw::c_uint = 8;
pub const L_SORT_BY_PERIMETER: ::std::os::raw::c_uint = 9;
pub const L_SORT_BY_AREA: ::std::os::raw::c_uint = 10;
pub const L_SORT_BY_ASPECT_RATIO: ::std::os::raw::c_uint = 11;
pub type _bindgen_ty_40 = ::std::os::raw::c_uint;
pub const L_BLEND_WITH_INVERSE: ::std::os::raw::c_uint = 1;
pub const L_BLEND_TO_WHITE: ::std::os::raw::c_uint = 2;
pub const L_BLEND_TO_BLACK: ::std::os::raw::c_uint = 3;
pub const L_BLEND_GRAY: ::std::os::raw::c_uint = 4;
pub const L_BLEND_GRAY_WITH_INVERSE: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_41 = ::std::os::raw::c_uint;
pub const L_PAINT_LIGHT: ::std::os::raw::c_uint = 1;
pub const L_PAINT_DARK: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_42 = ::std::os::raw::c_uint;
pub const L_SET_PIXELS: ::std::os::raw::c_uint = 1;
pub const L_CLEAR_PIXELS: ::std::os::raw::c_uint = 2;
pub const L_FLIP_PIXELS: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_43 = ::std::os::raw::c_uint;
pub const L_SELECT_IF_LT: ::std::os::raw::c_uint = 1;
pub const L_SELECT_IF_GT: ::std::os::raw::c_uint = 2;
pub const L_SELECT_IF_LTE: ::std::os::raw::c_uint = 3;
pub const L_SELECT_IF_GTE: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_44 = ::std::os::raw::c_uint;
pub const L_SELECT_BY_WIDTH: ::std::os::raw::c_uint = 1;
pub const L_SELECT_BY_HEIGHT: ::std::os::raw::c_uint = 2;
pub const L_SELECT_BY_MAX_DIMENSION: ::std::os::raw::c_uint = 3;
pub const L_SELECT_BY_AREA: ::std::os::raw::c_uint = 4;
pub const L_SELECT_BY_PERIMETER: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_45 = ::std::os::raw::c_uint;
pub const L_SELECT_WIDTH: ::std::os::raw::c_uint = 1;
pub const L_SELECT_HEIGHT: ::std::os::raw::c_uint = 2;
pub const L_SELECT_XVAL: ::std::os::raw::c_uint = 3;
pub const L_SELECT_YVAL: ::std::os::raw::c_uint = 4;
pub const L_SELECT_IF_EITHER: ::std::os::raw::c_uint = 5;
pub const L_SELECT_IF_BOTH: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_46 = ::std::os::raw::c_uint;
pub const L_CHECK_WIDTH: ::std::os::raw::c_uint = 1;
pub const L_CHECK_HEIGHT: ::std::os::raw::c_uint = 2;
pub const L_CHECK_BOTH: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_47 = ::std::os::raw::c_uint;
pub const L_SELECT_RED: ::std::os::raw::c_uint = 1;
pub const L_SELECT_GREEN: ::std::os::raw::c_uint = 2;
pub const L_SELECT_BLUE: ::std::os::raw::c_uint = 3;
pub const L_SELECT_MIN: ::std::os::raw::c_uint = 4;
pub const L_SELECT_MAX: ::std::os::raw::c_uint = 5;
pub const L_SELECT_AVERAGE: ::std::os::raw::c_uint = 6;
pub const L_SELECT_HUE: ::std::os::raw::c_uint = 7;
pub const L_SELECT_SATURATION: ::std::os::raw::c_uint = 8;
pub const L_SELECT_WEIGHTED: ::std::os::raw::c_uint = 9;
pub type _bindgen_ty_48 = ::std::os::raw::c_uint;
pub const L_INTERMED_DIFF: ::std::os::raw::c_uint = 1;
pub const L_AVE_MAX_DIFF_2: ::std::os::raw::c_uint = 2;
pub const L_MAX_DIFF: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_49 = ::std::os::raw::c_uint;
pub const L_LS_BYTE: ::std::os::raw::c_uint = 1;
pub const L_MS_BYTE: ::std::os::raw::c_uint = 2;
pub const L_AUTO_BYTE: ::std::os::raw::c_uint = 3;
pub const L_CLIP_TO_FF: ::std::os::raw::c_uint = 4;
pub const L_LS_TWO_BYTES: ::std::os::raw::c_uint = 5;
pub const L_MS_TWO_BYTES: ::std::os::raw::c_uint = 6;
pub const L_CLIP_TO_FFFF: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_50 = ::std::os::raw::c_uint;
pub const L_ROTATE_AREA_MAP: ::std::os::raw::c_uint = 1;
pub const L_ROTATE_SHEAR: ::std::os::raw::c_uint = 2;
pub const L_ROTATE_SAMPLING: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_51 = ::std::os::raw::c_uint;
pub const L_BRING_IN_WHITE: ::std::os::raw::c_uint = 1;
pub const L_BRING_IN_BLACK: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_52 = ::std::os::raw::c_uint;
pub const L_SHEAR_ABOUT_CORNER: ::std::os::raw::c_uint = 1;
pub const L_SHEAR_ABOUT_CENTER: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_53 = ::std::os::raw::c_uint;
pub const L_TR_SC_RO: ::std::os::raw::c_uint = 1;
pub const L_SC_RO_TR: ::std::os::raw::c_uint = 2;
pub const L_RO_TR_SC: ::std::os::raw::c_uint = 3;
pub const L_TR_RO_SC: ::std::os::raw::c_uint = 4;
pub const L_RO_SC_TR: ::std::os::raw::c_uint = 5;
pub const L_SC_TR_RO: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_54 = ::std::os::raw::c_uint;
pub const L_FILL_WHITE: ::std::os::raw::c_uint = 1;
pub const L_FILL_BLACK: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_55 = ::std::os::raw::c_uint;
pub const L_SET_WHITE: ::std::os::raw::c_uint = 1;
pub const L_SET_BLACK: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_56 = ::std::os::raw::c_uint;
pub const L_GET_WHITE_VAL: ::std::os::raw::c_uint = 1;
pub const L_GET_BLACK_VAL: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_57 = ::std::os::raw::c_uint;
pub const L_WHITE_IS_MAX: ::std::os::raw::c_uint = 1;
pub const L_BLACK_IS_MAX: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_58 = ::std::os::raw::c_uint;
pub const DEFAULT_CLIP_LOWER_1: ::std::os::raw::c_uint = 10;
pub const DEFAULT_CLIP_UPPER_1: ::std::os::raw::c_uint = 10;
pub const DEFAULT_CLIP_LOWER_2: ::std::os::raw::c_uint = 5;
pub const DEFAULT_CLIP_UPPER_2: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_59 = ::std::os::raw::c_uint;
pub const L_MANHATTAN_DISTANCE: ::std::os::raw::c_uint = 1;
pub const L_EUCLIDEAN_DISTANCE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_60 = ::std::os::raw::c_uint;
pub const L_NEGATIVE: ::std::os::raw::c_uint = 1;
pub const L_NON_NEGATIVE: ::std::os::raw::c_uint = 2;
pub const L_POSITIVE: ::std::os::raw::c_uint = 3;
pub const L_NON_POSITIVE: ::std::os::raw::c_uint = 4;
pub const L_ZERO: ::std::os::raw::c_uint = 5;
pub const L_ALL: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_61 = ::std::os::raw::c_uint;
pub const L_MEAN_ABSVAL: ::std::os::raw::c_uint = 1;
pub const L_MEDIAN_VAL: ::std::os::raw::c_uint = 2;
pub const L_MODE_VAL: ::std::os::raw::c_uint = 3;
pub const L_MODE_COUNT: ::std::os::raw::c_uint = 4;
pub const L_ROOT_MEAN_SQUARE: ::std::os::raw::c_uint = 5;
pub const L_STANDARD_DEVIATION: ::std::os::raw::c_uint = 6;
pub const L_VARIANCE: ::std::os::raw::c_uint = 7;
pub type _bindgen_ty_62 = ::std::os::raw::c_uint;
pub const L_CHOOSE_CONSECUTIVE: ::std::os::raw::c_uint = 1;
pub const L_CHOOSE_SKIP_BY: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_63 = ::std::os::raw::c_uint;
pub const L_TEXT_ORIENT_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const L_TEXT_ORIENT_UP: ::std::os::raw::c_uint = 1;
pub const L_TEXT_ORIENT_LEFT: ::std::os::raw::c_uint = 2;
pub const L_TEXT_ORIENT_DOWN: ::std::os::raw::c_uint = 3;
pub const L_TEXT_ORIENT_RIGHT: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_64 = ::std::os::raw::c_uint;
pub const L_HORIZONTAL_EDGES: ::std::os::raw::c_uint = 0;
pub const L_VERTICAL_EDGES: ::std::os::raw::c_uint = 1;
pub const L_ALL_EDGES: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_65 = ::std::os::raw::c_uint;
pub const L_HORIZONTAL_LINE: ::std::os::raw::c_uint = 0;
pub const L_POS_SLOPE_LINE: ::std::os::raw::c_uint = 1;
pub const L_VERTICAL_LINE: ::std::os::raw::c_uint = 2;
pub const L_NEG_SLOPE_LINE: ::std::os::raw::c_uint = 3;
pub const L_OBLIQUE_LINE: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_66 = ::std::os::raw::c_uint;
pub const L_PORTRAIT_MODE: ::std::os::raw::c_uint = 0;
pub const L_LANDSCAPE_MODE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_67 = ::std::os::raw::c_uint;
pub const L_FROM_LEFT: ::std::os::raw::c_uint = 0;
pub const L_FROM_RIGHT: ::std::os::raw::c_uint = 1;
pub const L_FROM_TOP: ::std::os::raw::c_uint = 2;
pub const L_FROM_BOT: ::std::os::raw::c_uint = 3;
pub const L_SCAN_NEGATIVE: ::std::os::raw::c_uint = 4;
pub const L_SCAN_POSITIVE: ::std::os::raw::c_uint = 5;
pub const L_SCAN_BOTH: ::std::os::raw::c_uint = 6;
pub const L_SCAN_HORIZONTAL: ::std::os::raw::c_uint = 7;
pub const L_SCAN_VERTICAL: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_68 = ::std::os::raw::c_uint;
pub const L_ADJUST_SKIP: ::std::os::raw::c_uint = 0;
pub const L_ADJUST_LEFT: ::std::os::raw::c_uint = 1;
pub const L_ADJUST_RIGHT: ::std::os::raw::c_uint = 2;
pub const L_ADJUST_LEFT_AND_RIGHT: ::std::os::raw::c_uint = 3;
pub const L_ADJUST_TOP: ::std::os::raw::c_uint = 4;
pub const L_ADJUST_BOT: ::std::os::raw::c_uint = 5;
pub const L_ADJUST_TOP_AND_BOT: ::std::os::raw::c_uint = 6;
pub const L_ADJUST_CHOOSE_MIN: ::std::os::raw::c_uint = 7;
pub const L_ADJUST_CHOOSE_MAX: ::std::os::raw::c_uint = 8;
pub const L_SET_LEFT: ::std::os::raw::c_uint = 9;
pub const L_SET_RIGHT: ::std::os::raw::c_uint = 10;
pub const L_SET_TOP: ::std::os::raw::c_uint = 11;
pub const L_SET_BOT: ::std::os::raw::c_uint = 12;
pub const L_GET_LEFT: ::std::os::raw::c_uint = 13;
pub const L_GET_RIGHT: ::std::os::raw::c_uint = 14;
pub const L_GET_TOP: ::std::os::raw::c_uint = 15;
pub const L_GET_BOT: ::std::os::raw::c_uint = 16;
pub type _bindgen_ty_69 = ::std::os::raw::c_uint;
pub const L_USE_MINSIZE: ::std::os::raw::c_uint = 1;
pub const L_USE_MAXSIZE: ::std::os::raw::c_uint = 2;
pub const L_SUB_ON_LOC_DIFF: ::std::os::raw::c_uint = 3;
pub const L_SUB_ON_SIZE_DIFF: ::std::os::raw::c_uint = 4;
pub const L_USE_CAPPED_MIN: ::std::os::raw::c_uint = 5;
pub const L_USE_CAPPED_MAX: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_70 = ::std::os::raw::c_uint;
pub const L_COMBINE: ::std::os::raw::c_uint = 1;
pub const L_REMOVE_SMALL: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_71 = ::std::os::raw::c_uint;
pub const L_GEOMETRIC_UNION: ::std::os::raw::c_uint = 1;
pub const L_GEOMETRIC_INTERSECTION: ::std::os::raw::c_uint = 2;
pub const L_LARGEST_AREA: ::std::os::raw::c_uint = 3;
pub const L_SMALLEST_AREA: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_72 = ::std::os::raw::c_uint;
pub const L_USE_ALL_BOXES: ::std::os::raw::c_uint = 1;
pub const L_USE_SAME_PARITY_BOXES: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_73 = ::std::os::raw::c_uint;
pub const L_UPPER_LEFT: ::std::os::raw::c_uint = 1;
pub const L_UPPER_RIGHT: ::std::os::raw::c_uint = 2;
pub const L_LOWER_LEFT: ::std::os::raw::c_uint = 3;
pub const L_LOWER_RIGHT: ::std::os::raw::c_uint = 4;
pub const L_BOX_CENTER: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_74 = ::std::os::raw::c_uint;
pub const L_WARP_TO_LEFT: ::std::os::raw::c_uint = 1;
pub const L_WARP_TO_RIGHT: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_75 = ::std::os::raw::c_uint;
pub const L_LINEAR_WARP: ::std::os::raw::c_uint = 1;
pub const L_QUADRATIC_WARP: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_76 = ::std::os::raw::c_uint;
pub const L_INTERPOLATED: ::std::os::raw::c_uint = 1;
pub const L_SAMPLED: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_77 = ::std::os::raw::c_uint;
pub const L_THIN_FG: ::std::os::raw::c_uint = 1;
pub const L_THIN_BG: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_78 = ::std::os::raw::c_uint;
pub const L_HORIZONTAL_RUNS: ::std::os::raw::c_uint = 0;
pub const L_VERTICAL_RUNS: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_79 = ::std::os::raw::c_uint;
pub const L_SOBEL_EDGE: ::std::os::raw::c_uint = 1;
pub const L_TWO_SIDED_EDGE: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_80 = ::std::os::raw::c_uint;
pub const L_SUBPIXEL_ORDER_RGB: ::std::os::raw::c_uint = 1;
pub const L_SUBPIXEL_ORDER_BGR: ::std::os::raw::c_uint = 2;
pub const L_SUBPIXEL_ORDER_VRGB: ::std::os::raw::c_uint = 3;
pub const L_SUBPIXEL_ORDER_VBGR: ::std::os::raw::c_uint = 4;
pub type _bindgen_ty_81 = ::std::os::raw::c_uint;
pub const L_HS_HISTO: ::std::os::raw::c_uint = 1;
pub const L_HV_HISTO: ::std::os::raw::c_uint = 2;
pub const L_SV_HISTO: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_82 = ::std::os::raw::c_uint;
pub const L_INCLUDE_REGION: ::std::os::raw::c_uint = 1;
pub const L_EXCLUDE_REGION: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_83 = ::std::os::raw::c_uint;
pub const L_ADD_ABOVE: ::std::os::raw::c_uint = 1;
pub const L_ADD_BELOW: ::std::os::raw::c_uint = 2;
pub const L_ADD_LEFT: ::std::os::raw::c_uint = 3;
pub const L_ADD_RIGHT: ::std::os::raw::c_uint = 4;
pub const L_ADD_AT_TOP: ::std::os::raw::c_uint = 5;
pub const L_ADD_AT_BOT: ::std::os::raw::c_uint = 6;
pub const L_ADD_AT_LEFT: ::std::os::raw::c_uint = 7;
pub const L_ADD_AT_RIGHT: ::std::os::raw::c_uint = 8;
pub type _bindgen_ty_84 = ::std::os::raw::c_uint;
pub const L_PLOT_AT_TOP: ::std::os::raw::c_uint = 1;
pub const L_PLOT_AT_MID_HORIZ: ::std::os::raw::c_uint = 2;
pub const L_PLOT_AT_BOT: ::std::os::raw::c_uint = 3;
pub const L_PLOT_AT_LEFT: ::std::os::raw::c_uint = 4;
pub const L_PLOT_AT_MID_VERT: ::std::os::raw::c_uint = 5;
pub const L_PLOT_AT_RIGHT: ::std::os::raw::c_uint = 6;
pub type _bindgen_ty_85 = ::std::os::raw::c_uint;
pub const L_USE_INNER: ::std::os::raw::c_uint = 1;
pub const L_USE_OUTER: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_86 = ::std::os::raw::c_uint;
pub const L_DISPLAY_WITH_XZGV: ::std::os::raw::c_uint = 1;
pub const L_DISPLAY_WITH_XLI: ::std::os::raw::c_uint = 2;
pub const L_DISPLAY_WITH_XV: ::std::os::raw::c_uint = 3;
pub const L_DISPLAY_WITH_IV: ::std::os::raw::c_uint = 4;
pub const L_DISPLAY_WITH_OPEN: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_87 = ::std::os::raw::c_uint;
pub const L_NO_CHROMA_SAMPLING_JPEG: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_88 = ::std::os::raw::c_uint;
pub const L_CLIP_TO_ZERO: ::std::os::raw::c_uint = 1;
pub const L_TAKE_ABSVAL: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_89 = ::std::os::raw::c_uint;
pub const L_LESS_THAN_ZERO: ::std::os::raw::c_uint = 1;
pub const L_EQUAL_TO_ZERO: ::std::os::raw::c_uint = 2;
pub const L_GREATER_THAN_ZERO: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_90 = ::std::os::raw::c_uint;
pub const L_ADD_TRAIL_SLASH: ::std::os::raw::c_uint = 1;
pub const L_REMOVE_TRAIL_SLASH: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_91 = ::std::os::raw::c_uint;
pub type alloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: size_t) -> *mut ::std::os::raw::c_void>;
pub type dealloc_fn =
    ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Recog {
    pub scalew: l_int32,
    pub scaleh: l_int32,
    pub linew: l_int32,
    pub templ_use: l_int32,
    pub maxarraysize: l_int32,
    pub setsize: l_int32,
    pub threshold: l_int32,
    pub maxyshift: l_int32,
    pub charset_type: l_int32,
    pub charset_size: l_int32,
    pub min_nopad: l_int32,
    pub num_samples: l_int32,
    pub minwidth_u: l_int32,
    pub maxwidth_u: l_int32,
    pub minheight_u: l_int32,
    pub maxheight_u: l_int32,
    pub minwidth: l_int32,
    pub maxwidth: l_int32,
    pub ave_done: l_int32,
    pub train_done: l_int32,
    pub max_wh_ratio: l_float32,
    pub max_ht_ratio: l_float32,
    pub min_splitw: l_int32,
    pub max_splith: l_int32,
    pub sa_text: *mut Sarray,
    pub dna_tochar: *mut L_Dna,
    pub centtab: *mut l_int32,
    pub sumtab: *mut l_int32,
    pub pixaa_u: *mut Pixaa,
    pub ptaa_u: *mut Ptaa,
    pub naasum_u: *mut Numaa,
    pub pixaa: *mut Pixaa,
    pub ptaa: *mut Ptaa,
    pub naasum: *mut Numaa,
    pub pixa_u: *mut Pixa,
    pub pta_u: *mut Pta,
    pub nasum_u: *mut Numa,
    pub pixa: *mut Pixa,
    pub pta: *mut Pta,
    pub nasum: *mut Numa,
    pub pixa_tr: *mut Pixa,
    pub pixadb_ave: *mut Pixa,
    pub pixa_id: *mut Pixa,
    pub pixdb_ave: *mut Pix,
    pub pixdb_range: *mut Pix,
    pub pixadb_boot: *mut Pixa,
    pub pixadb_split: *mut Pixa,
    pub bmf: *mut L_Bmf,
    pub bmf_size: l_int32,
    pub did: *mut L_Rdid,
    pub rch: *mut L_Rch,
    pub rcha: *mut L_Rcha,
}
#[test]
fn bindgen_test_layout_L_Recog() {
    assert_eq!(
        ::std::mem::size_of::<L_Recog>(),
        320usize,
        concat!("Size of: ", stringify!(L_Recog))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Recog>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Recog))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).scalew as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(scalew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).scaleh as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(scaleh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).linew as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(linew)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).templ_use as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(templ_use)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxarraysize as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxarraysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).setsize as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(setsize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).threshold as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxyshift as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxyshift)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).charset_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(charset_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).charset_size as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(charset_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).min_nopad as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(min_nopad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).num_samples as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(num_samples)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minwidth_u as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minwidth_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxwidth_u as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxwidth_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minheight_u as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minheight_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxheight_u as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxheight_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).minwidth as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(minwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).maxwidth as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(maxwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ave_done as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ave_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).train_done as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(train_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_wh_ratio as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_wh_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_ht_ratio as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_ht_ratio)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).min_splitw as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(min_splitw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).max_splith as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(max_splith)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).sa_text as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(sa_text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).dna_tochar as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(dna_tochar)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).centtab as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(centtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).sumtab as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(sumtab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixaa_u as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixaa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ptaa_u as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ptaa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).naasum_u as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(naasum_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixaa as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).ptaa as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(ptaa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).naasum as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(naasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_u as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pta_u as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pta_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).nasum_u as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(nasum_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pta as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).nasum as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(nasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_tr as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_tr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_ave as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_ave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixa_id as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixa_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixdb_ave as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixdb_ave)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixdb_range as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixdb_range)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_boot as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_boot)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).pixadb_split as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(pixadb_split)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).bmf as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(bmf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).bmf_size as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(bmf_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).did as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(did)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).rch as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(rch)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Recog>())).rcha as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Recog),
            "::",
            stringify!(rcha)
        )
    );
}
pub type L_RECOG = L_Recog;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rch {
    pub index: l_int32,
    pub score: l_float32,
    pub text: *mut ::std::os::raw::c_char,
    pub sample: l_int32,
    pub xloc: l_int32,
    pub yloc: l_int32,
    pub width: l_int32,
}
#[test]
fn bindgen_test_layout_L_Rch() {
    assert_eq!(
        ::std::mem::size_of::<L_Rch>(),
        32usize,
        concat!("Size of: ", stringify!(L_Rch))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rch>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rch))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).index as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).score as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(score)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).text as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).sample as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(sample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).xloc as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(xloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).yloc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(yloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rch>())).width as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rch),
            "::",
            stringify!(width)
        )
    );
}
pub type L_RCH = L_Rch;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rcha {
    pub naindex: *mut Numa,
    pub nascore: *mut Numa,
    pub satext: *mut Sarray,
    pub nasample: *mut Numa,
    pub naxloc: *mut Numa,
    pub nayloc: *mut Numa,
    pub nawidth: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rcha() {
    assert_eq!(
        ::std::mem::size_of::<L_Rcha>(),
        56usize,
        concat!("Size of: ", stringify!(L_Rcha))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rcha>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rcha))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).naindex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(naindex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nascore as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nascore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).satext as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(satext)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nasample as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nasample)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).naxloc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(naxloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nayloc as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nayloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rcha>())).nawidth as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rcha),
            "::",
            stringify!(nawidth)
        )
    );
}
pub type L_RCHA = L_Rcha;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Rdid {
    pub pixs: *mut Pix,
    pub counta: *mut *mut l_int32,
    pub delya: *mut *mut l_int32,
    pub narray: l_int32,
    pub size: l_int32,
    pub setwidth: *mut l_int32,
    pub nasum: *mut Numa,
    pub namoment: *mut Numa,
    pub fullarrays: l_int32,
    pub beta: *mut l_float32,
    pub gamma: *mut l_float32,
    pub trellisscore: *mut l_float32,
    pub trellistempl: *mut l_int32,
    pub natempl: *mut Numa,
    pub naxloc: *mut Numa,
    pub nadely: *mut Numa,
    pub nawidth: *mut Numa,
    pub boxa: *mut Boxa,
    pub nascore: *mut Numa,
    pub natempl_r: *mut Numa,
    pub nasample_r: *mut Numa,
    pub naxloc_r: *mut Numa,
    pub nadely_r: *mut Numa,
    pub nawidth_r: *mut Numa,
    pub nascore_r: *mut Numa,
}
#[test]
fn bindgen_test_layout_L_Rdid() {
    assert_eq!(
        ::std::mem::size_of::<L_Rdid>(),
        192usize,
        concat!("Size of: ", stringify!(L_Rdid))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Rdid>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Rdid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).pixs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).counta as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(counta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).delya as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(delya)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).narray as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(narray)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).setwidth as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(setwidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nasum as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nasum)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).namoment as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(namoment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).fullarrays as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(fullarrays)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).beta as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).gamma as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(gamma)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).trellisscore as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(trellisscore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).trellistempl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(trellistempl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).natempl as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(natempl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).naxloc as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(naxloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nadely as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nadely)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nawidth as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nawidth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).boxa as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(boxa)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nascore as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nascore)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).natempl_r as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(natempl_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nasample_r as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nasample_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).naxloc_r as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(naxloc_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nadely_r as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nadely_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nawidth_r as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nawidth_r)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Rdid>())).nascore_r as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Rdid),
            "::",
            stringify!(nascore_r)
        )
    );
}
pub type L_RDID = L_Rdid;
pub const L_UNKNOWN: ::std::os::raw::c_uint = 0;
pub const L_ARABIC_NUMERALS: ::std::os::raw::c_uint = 1;
pub const L_LC_ROMAN_NUMERALS: ::std::os::raw::c_uint = 2;
pub const L_UC_ROMAN_NUMERALS: ::std::os::raw::c_uint = 3;
pub const L_LC_ALPHA: ::std::os::raw::c_uint = 4;
pub const L_UC_ALPHA: ::std::os::raw::c_uint = 5;
pub type _bindgen_ty_92 = ::std::os::raw::c_uint;
pub const L_USE_ALL_TEMPLATES: ::std::os::raw::c_uint = 0;
pub const L_USE_AVERAGE_TEMPLATES: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_93 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_RegParams {
    pub fp: *mut FILE,
    pub testname: *mut ::std::os::raw::c_char,
    pub tempfile: *mut ::std::os::raw::c_char,
    pub mode: l_int32,
    pub index: l_int32,
    pub success: l_int32,
    pub display: l_int32,
    pub tstart: L_TIMER,
}
#[test]
fn bindgen_test_layout_L_RegParams() {
    assert_eq!(
        ::std::mem::size_of::<L_RegParams>(),
        48usize,
        concat!("Size of: ", stringify!(L_RegParams))
    );
    assert_eq!(
        ::std::mem::align_of::<L_RegParams>(),
        8usize,
        concat!("Alignment of ", stringify!(L_RegParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).fp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(fp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).testname as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(testname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).tempfile as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(tempfile)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).mode as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).index as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).success as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(success)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).display as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(display)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_RegParams>())).tstart as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_RegParams),
            "::",
            stringify!(tstart)
        )
    );
}
pub type L_REGPARAMS = L_RegParams;
pub const L_REG_GENERATE: ::std::os::raw::c_uint = 0;
pub const L_REG_COMPARE: ::std::os::raw::c_uint = 1;
pub const L_REG_DISPLAY: ::std::os::raw::c_uint = 2;
pub type _bindgen_ty_94 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_StrCode {
    pub fileno: l_int32,
    pub ifunc: l_int32,
    pub function: *mut SARRAY,
    pub data: *mut SARRAY,
    pub descr: *mut SARRAY,
    pub n: l_int32,
}
#[test]
fn bindgen_test_layout_L_StrCode() {
    assert_eq!(
        ::std::mem::size_of::<L_StrCode>(),
        40usize,
        concat!("Size of: ", stringify!(L_StrCode))
    );
    assert_eq!(
        ::std::mem::align_of::<L_StrCode>(),
        8usize,
        concat!("Alignment of ", stringify!(L_StrCode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).fileno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).ifunc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(ifunc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).function as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(function)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).descr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(descr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_StrCode>())).n as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_StrCode),
            "::",
            stringify!(n)
        )
    );
}
pub type L_STRCODE = L_StrCode;
pub const L_STR_TYPE: ::std::os::raw::c_uint = 0;
pub const L_STR_NAME: ::std::os::raw::c_uint = 1;
pub const L_STR_READER: ::std::os::raw::c_uint = 2;
pub const L_STR_MEMREADER: ::std::os::raw::c_uint = 3;
pub type _bindgen_ty_95 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_Sudoku {
    pub num: l_int32,
    pub locs: *mut l_int32,
    pub current: l_int32,
    pub init: *mut l_int32,
    pub state: *mut l_int32,
    pub nguess: l_int32,
    pub finished: l_int32,
    pub failure: l_int32,
}
#[test]
fn bindgen_test_layout_L_Sudoku() {
    assert_eq!(
        ::std::mem::size_of::<L_Sudoku>(),
        56usize,
        concat!("Size of: ", stringify!(L_Sudoku))
    );
    assert_eq!(
        ::std::mem::align_of::<L_Sudoku>(),
        8usize,
        concat!("Alignment of ", stringify!(L_Sudoku))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).locs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(locs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).current as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(current)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).init as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).nguess as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(nguess)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).finished as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(finished)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_Sudoku>())).failure as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_Sudoku),
            "::",
            stringify!(failure)
        )
    );
}
pub type L_SUDOKU = L_Sudoku;
pub const L_SUDOKU_INIT: ::std::os::raw::c_uint = 0;
pub const L_SUDOKU_STATE: ::std::os::raw::c_uint = 1;
pub type _bindgen_ty_96 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct L_WShed {
    pub pixs: *mut Pix,
    pub pixm: *mut Pix,
    pub mindepth: l_int32,
    pub pixlab: *mut Pix,
    pub pixt: *mut Pix,
    pub lines8: *mut *mut ::std::os::raw::c_void,
    pub linem1: *mut *mut ::std::os::raw::c_void,
    pub linelab32: *mut *mut ::std::os::raw::c_void,
    pub linet1: *mut *mut ::std::os::raw::c_void,
    pub pixad: *mut Pixa,
    pub ptas: *mut Pta,
    pub nasi: *mut Numa,
    pub nash: *mut Numa,
    pub namh: *mut Numa,
    pub nalevels: *mut Numa,
    pub nseeds: l_int32,
    pub nother: l_int32,
    pub lut: *mut l_int32,
    pub links: *mut *mut Numa,
    pub arraysize: l_int32,
    pub debug: l_int32,
}
#[test]
fn bindgen_test_layout_L_WShed() {
    assert_eq!(
        ::std::mem::size_of::<L_WShed>(),
        152usize,
        concat!("Size of: ", stringify!(L_WShed))
    );
    assert_eq!(
        ::std::mem::align_of::<L_WShed>(),
        8usize,
        concat!("Alignment of ", stringify!(L_WShed))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).mindepth as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(mindepth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixlab as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixlab)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixt as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).lines8 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(lines8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linem1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linem1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linelab32 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linelab32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).linet1 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(linet1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).pixad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(pixad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).ptas as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(ptas)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nasi as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nasi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nash as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nash)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).namh as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(namh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nalevels as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nalevels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nseeds as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nseeds)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).nother as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(nother)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).lut as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(lut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).links as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(links)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).arraysize as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(arraysize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<L_WShed>())).debug as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(L_WShed),
            "::",
            stringify!(debug)
        )
    );
}
pub type L_WSHED = L_WShed;
extern "C" {
    pub fn pixCleanBackgroundToWhite(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormSimple(pixs: *mut PIX, pixim: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBackgroundNormGrayArray(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormRGBArrays(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormGrayArrayMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormRGBArraysMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        bgval: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundGrayMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundRGBMap(
        pixs: *mut PIX,
        pixim: *mut PIX,
        pixg: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundGrayMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixm: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBackgroundRGBMapMorph(
        pixs: *mut PIX,
        pixim: *mut PIX,
        reduction: l_int32,
        size: l_int32,
        ppixmr: *mut *mut PIX,
        ppixmg: *mut *mut PIX,
        ppixmb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFillMapHoles(pix: *mut PIX, nx: l_int32, ny: l_int32, filltype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixExtendByReplication(pixs: *mut PIX, addw: l_int32, addh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSmoothConnectedRegions(pixs: *mut PIX, pixm: *mut PIX, factor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetInvBackgroundMap(
        pixs: *mut PIX,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundGrayMap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyInvBackgroundRGBMap(
        pixs: *mut PIX,
        pixmr: *mut PIX,
        pixmg: *mut PIX,
        pixmb: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixApplyVariableGrayMap(pixs: *mut PIX, pixg: *mut PIX, target: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        mapval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGlobalNormNoSatRGB(
        pixd: *mut PIX,
        pixs: *mut PIX,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        factor: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdSpreadNorm(
        pixs: *mut PIX,
        filtertype: l_int32,
        edgethresh: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
        targetthresh: l_int32,
        ppixth: *mut *mut PIX,
        ppixb: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBackgroundNormFlex(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastNorm(
        pixd: *mut PIX,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        mindiff: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffine(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAffineGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixAffinePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getAffineXformCoeffs(ptas: *mut PTA, ptad: *mut PTA, pvc: *mut *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn affineInvertXform(vc: *mut l_float32, pvci: *mut *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn affineXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn affineXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn linearInterpolatePixelColor(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        colorval: l_uint32,
        pval: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn linearInterpolatePixelGray(
        datas: *mut l_uint32,
        wpls: l_int32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        grayval: l_int32,
        pval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn gaussjordan(a: *mut *mut l_float32, b: *mut l_float32, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAffineSequential(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        bw: l_int32,
        bh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn createMatrix2dTranslate(transx: l_float32, transy: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dScale(scalex: l_float32, scaley: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn createMatrix2dRotate(xc: l_float32, yc: l_float32, angle: l_float32) -> *mut l_float32;
}
extern "C" {
    pub fn ptaTranslate(ptas: *mut PTA, transx: l_float32, transy: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaScale(ptas: *mut PTA, scalex: l_float32, scaley: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn ptaRotate(ptas: *mut PTA, xc: l_float32, yc: l_float32, angle: l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaTranslate(boxas: *mut BOXA, transx: l_float32, transy: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaScale(boxas: *mut BOXA, scalex: l_float32, scaley: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaRotate(
        boxas: *mut BOXA,
        xc: l_float32,
        yc: l_float32,
        angle: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn ptaAffineTransform(ptas: *mut PTA, mat: *mut l_float32) -> *mut PTA;
}
extern "C" {
    pub fn boxaAffineTransform(boxas: *mut BOXA, mat: *mut l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn l_productMatVec(
        mat: *mut l_float32,
        vecs: *mut l_float32,
        vecd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat2(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat3(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_productMat4(
        mat1: *mut l_float32,
        mat2: *mut l_float32,
        mat3: *mut l_float32,
        mat4: *mut l_float32,
        matd: *mut l_float32,
        size: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_getDataBit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_clearDataBit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_setDataBitVal(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataDibit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataDibit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataQbit(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_clearDataQbit(line: *mut ::std::os::raw::c_void, n: l_int32);
}
extern "C" {
    pub fn l_getDataByte(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataByte(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataTwoBytes(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataTwoBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn l_getDataFourBytes(line: *const ::std::os::raw::c_void, n: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_setDataFourBytes(line: *mut ::std::os::raw::c_void, n: l_int32, val: l_int32);
}
extern "C" {
    pub fn barcodeDispatchDecoder(
        barstr: *mut ::std::os::raw::c_char,
        format: l_int32,
        debugflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn barcodeFormatIsSupported(format: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixFindBaselines(pixs: *mut PIX, ppta: *mut *mut PTA, pixadb: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixDeskewLocal(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetLocalSkewTransform(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pptas: *mut *mut PTA,
        pptad: *mut *mut PTA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetLocalSkewAngles(
        pixs: *mut PIX,
        nslices: l_int32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pa: *mut l_float32,
        pb: *mut l_float32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bbufferCreate(indata: *const l_uint8, nalloc: l_int32) -> *mut L_BBUFFER;
}
extern "C" {
    pub fn bbufferDestroy(pbb: *mut *mut L_BBUFFER);
}
extern "C" {
    pub fn bbufferDestroyAndSaveData(
        pbb: *mut *mut L_BBUFFER,
        pnbytes: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn bbufferRead(bb: *mut L_BBUFFER, src: *mut l_uint8, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferReadStream(bb: *mut L_BBUFFER, fp: *mut FILE, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferExtendArray(bb: *mut L_BBUFFER, nbytes: l_int32) -> l_ok;
}
extern "C" {
    pub fn bbufferWrite(
        bb: *mut L_BBUFFER,
        dest: *mut l_uint8,
        nbytes: size_t,
        pnout: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn bbufferWriteStream(
        bb: *mut L_BBUFFER,
        fp: *mut FILE,
        nbytes: size_t,
        pnout: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBilateral(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGray(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
        ncomps: l_int32,
        reduction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilateralGrayExact(
        pixs: *mut PIX,
        spatial_kel: *mut L_KERNEL,
        range_kel: *mut L_KERNEL,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockBilateralExact(
        pixs: *mut PIX,
        spatial_stdev: l_float32,
        range_stdev: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRangeKernel(range_stdev: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn pixBilinearSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinear(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixBilinearPtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getBilinearXformCoeffs(ptas: *mut PTA, ptad: *mut PTA, pvc: *mut *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn bilinearXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn bilinearXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOtsuAdaptiveThreshold(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOtsuThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        bgval: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskedThreshOnBackgroundNorm(
        pixs: *mut PIX,
        pixim: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        thresh: l_int32,
        mincount: l_int32,
        smoothx: l_int32,
        smoothy: l_int32,
        scorefract: l_float32,
        pthresh: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSauvolaBinarizeTiled(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        nx: l_int32,
        ny: l_int32,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSauvolaBinarize(
        pixs: *mut PIX,
        whsize: l_int32,
        factor: l_float32,
        addborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixsd: *mut *mut PIX,
        ppixth: *mut *mut PIX,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSauvolaOnContrastNorm(
        pixs: *mut PIX,
        mindiff: l_int32,
        ppixn: *mut *mut PIX,
        ppixth: *mut *mut PIX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThreshOnDoubleNorm(pixs: *mut PIX, mindiff: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdByConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        start: l_int32,
        end: l_int32,
        incr: l_int32,
        thresh48: l_float32,
        threshdiff: l_float32,
        pglobthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixThresholdByHisto(
        pixs: *mut PIX,
        factor: l_int32,
        halfw: l_int32,
        delta: l_float32,
        pthresh: *mut l_int32,
        ppixd: *mut *mut PIX,
        ppixhisto: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixExpandBinaryReplicate(pixs: *mut PIX, xfact: l_int32, yfact: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandBinaryPower2(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceBinary2(pixs: *mut PIX, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinaryCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReduceRankBinary2(pixs: *mut PIX, level: l_int32, intab: *mut l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn makeSubsampleTab2x() -> *mut l_uint8;
}
extern "C" {
    pub fn pixBlend(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendMask(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGray(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        type_: l_int32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayInverse(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColor(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendColorByChannel(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
        transparent: l_int32,
        transpix: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendGrayAdapt(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
        shift: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFadeWithGray(
        pixs: *mut PIX,
        pixb: *mut PIX,
        factor: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendHardLight(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x: l_int32,
        y: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendCmap(
        pixs: *mut PIX,
        pixb: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBlendWithGrayMask(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        pixg: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBackgroundToColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyByColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        box_: *mut BOX,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAlphaBlendUniform(pixs: *mut PIX, color: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaToBlend(pixs: *mut PIX, fract: l_float32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetAlphaOverWhite(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearEdgeFade(
        pixs: *mut PIX,
        dir: l_int32,
        fadeto: l_int32,
        distfract: l_float32,
        maxfade: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn bmfCreate(dir: *const ::std::os::raw::c_char, fontsize: l_int32) -> *mut L_BMF;
}
extern "C" {
    pub fn bmfDestroy(pbmf: *mut *mut L_BMF);
}
extern "C" {
    pub fn bmfGetPix(bmf: *mut L_BMF, chr: ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn bmfGetWidth(bmf: *mut L_BMF, chr: ::std::os::raw::c_char, pw: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn bmfGetBaseline(
        bmf: *mut L_BMF,
        chr: ::std::os::raw::c_char,
        pbaseline: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetFont(
        dir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
        pbl0: *mut l_int32,
        pbl1: *mut l_int32,
        pbl2: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSaveFont(
        indir: *const ::std::os::raw::c_char,
        outdir: *const ::std::os::raw::c_char,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamBmp(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemBmp(cdata: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamBmp(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemBmp(pfdata: *mut *mut l_uint8, pfsize: *mut size_t, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn l_bootnum_gen1() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen2() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen3() -> *mut PIXA;
}
extern "C" {
    pub fn l_bootnum_gen4(nsamp: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn boxCreate(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCreateValid(x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxCopy(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxClone(box_: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxDestroy(pbox: *mut *mut BOX);
}
extern "C" {
    pub fn boxGetGeometry(
        box_: *mut BOX,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSetGeometry(box_: *mut BOX, x: l_int32, y: l_int32, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxGetSideLocations(
        box_: *mut BOX,
        pl: *mut l_int32,
        pr: *mut l_int32,
        pt: *mut l_int32,
        pb: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSetSideLocations(
        box_: *mut BOX,
        l: l_int32,
        r: l_int32,
        t: l_int32,
        b: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxGetRefcount(box_: *mut BOX) -> l_int32;
}
extern "C" {
    pub fn boxChangeRefcount(box_: *mut BOX, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxIsValid(box_: *mut BOX, pvalid: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaCreate(n: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCopy(boxa: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaDestroy(pboxa: *mut *mut BOXA);
}
extern "C" {
    pub fn boxaAddBox(boxa: *mut BOXA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaExtendArray(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaExtendArrayToSize(boxa: *mut BOXA, size: size_t) -> l_ok;
}
extern "C" {
    pub fn boxaGetCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetValidCount(boxa: *mut BOXA) -> l_int32;
}
extern "C" {
    pub fn boxaGetBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetValidBox(boxa: *mut BOXA, index: l_int32, accessflag: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindInvalidBoxes(boxa: *mut BOXA) -> *mut NUMA;
}
extern "C" {
    pub fn boxaGetBoxGeometry(
        boxa: *mut BOXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaIsFull(boxa: *mut BOXA, pfull: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaReplaceBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaInsertBox(boxa: *mut BOXA, index: l_int32, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaRemoveBox(boxa: *mut BOXA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaRemoveBoxAndSave(boxa: *mut BOXA, index: l_int32, pbox: *mut *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaSaveValid(boxas: *mut BOXA, copyflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaInitFull(boxa: *mut BOXA, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxaClear(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaCreate(n: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaCopy(baas: *mut BOXAA, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaDestroy(pbaa: *mut *mut BOXAA);
}
extern "C" {
    pub fn boxaaAddBoxa(baa: *mut BOXAA, ba: *mut BOXA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendArray(baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendArrayToSize(baa: *mut BOXAA, size: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaGetCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxCount(baa: *mut BOXAA) -> l_int32;
}
extern "C" {
    pub fn boxaaGetBoxa(baa: *mut BOXAA, index: l_int32, accessflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaGetBox(
        baa: *mut BOXAA,
        iboxa: l_int32,
        ibox: l_int32,
        accessflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaaInitFull(baa: *mut BOXAA, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaExtendWithInit(baa: *mut BOXAA, maxindex: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaReplaceBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaInsertBoxa(baa: *mut BOXAA, index: l_int32, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaaRemoveBoxa(baa: *mut BOXAA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaAddBox(
        baa: *mut BOXAA,
        index: l_int32,
        box_: *mut BOX,
        accessflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadStream(fp: *mut FILE) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaReadMem(data: *const l_uint8, size: size_t) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaWrite(filename: *const ::std::os::raw::c_char, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaWriteStream(fp: *mut FILE, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, baa: *mut BOXAA) -> l_ok;
}
extern "C" {
    pub fn boxaRead(filename: *const ::std::os::raw::c_char) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadStream(fp: *mut FILE) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReadMem(data: *const l_uint8, size: size_t) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWriteDebug(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWrite(filename: *const ::std::os::raw::c_char, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteStream(fp: *mut FILE, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteStderr(boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn boxPrintStreamInfo(fp: *mut FILE, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn boxContains(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxIntersects(box1: *mut BOX, box2: *mut BOX, presult: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaContainedInBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaContainedInBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaContainedInBoxa(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        pcontained: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaIntersectsBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaIntersectsBoxCount(boxa: *mut BOXA, box_: *mut BOX, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaClipToBox(boxas: *mut BOXA, box_: *mut BOX) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlaps(boxas: *mut BOXA, pixadb: *mut PIXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaCombineOverlapsInPair(
        boxas1: *mut BOXA,
        boxas2: *mut BOXA,
        pboxad1: *mut *mut BOXA,
        pboxad2: *mut *mut BOXA,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxOverlapRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxBoundingRegion(box1: *mut BOX, box2: *mut BOX) -> *mut BOX;
}
extern "C" {
    pub fn boxOverlapFraction(box1: *mut BOX, box2: *mut BOX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxOverlapArea(box1: *mut BOX, box2: *mut BOX, parea: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaHandleOverlaps(
        boxas: *mut BOXA,
        op: l_int32,
        range: l_int32,
        min_overlap: l_float32,
        max_ratio: l_float32,
        pnamap: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxOverlapDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_ovl: *mut l_int32,
        pv_ovl: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSeparationDistance(
        box1: *mut BOX,
        box2: *mut BOX,
        ph_sep: *mut l_int32,
        pv_sep: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxCompareSize(
        box1: *mut BOX,
        box2: *mut BOX,
        type_: l_int32,
        prel: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxContainsPt(
        box_: *mut BOX,
        x: l_float32,
        y: l_float32,
        pcontains: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetNearestToPt(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetNearestToLine(boxa: *mut BOXA, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaFindNearestBoxes(
        boxa: *mut BOXA,
        dist_select: l_int32,
        range: l_int32,
        pnaaindex: *mut *mut NUMAA,
        pnaadist: *mut *mut NUMAA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetNearestByDirection(
        boxa: *mut BOXA,
        i: l_int32,
        dir: l_int32,
        dist_select: l_int32,
        range: l_int32,
        pindex: *mut l_int32,
        pdist: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxGetCenter(box_: *mut BOX, pcx: *mut l_float32, pcy: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxIntersectByLine(
        box_: *mut BOX,
        x: l_int32,
        y: l_int32,
        slope: l_float32,
        px1: *mut l_int32,
        py1: *mut l_int32,
        px2: *mut l_int32,
        py2: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxClipToRectangle(box_: *mut BOX, wi: l_int32, hi: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxClipToRectangleParams(
        box_: *mut BOX,
        w: l_int32,
        h: l_int32,
        pxstart: *mut l_int32,
        pystart: *mut l_int32,
        pxend: *mut l_int32,
        pyend: *mut l_int32,
        pbw: *mut l_int32,
        pbh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxRelocateOneSide(
        boxd: *mut BOX,
        boxs: *mut BOX,
        loc: l_int32,
        sideflag: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaAdjustSides(
        boxas: *mut BOXA,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustBoxSides(
        boxa: *mut BOXA,
        index: l_int32,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxAdjustSides(
        boxd: *mut BOX,
        boxs: *mut BOX,
        delleft: l_int32,
        delright: l_int32,
        deltop: l_int32,
        delbot: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSetSide(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        side: l_int32,
        val: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxSetSide(boxs: *mut BOX, side: l_int32, val: l_int32, thresh: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaAdjustWidthToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaAdjustHeightToTarget(
        boxad: *mut BOXA,
        boxas: *mut BOXA,
        sides: l_int32,
        target: l_int32,
        thresh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxEqual(box1: *mut BOX, box2: *mut BOX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaEqual(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxSimilar(
        box1: *mut BOX,
        box2: *mut BOX,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        psimilar: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaSimilar(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        leftdiff: l_int32,
        rightdiff: l_int32,
        topdiff: l_int32,
        botdiff: l_int32,
        debug: l_int32,
        psimilar: *mut l_int32,
        pnasim: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaJoin(boxad: *mut BOXA, boxas: *mut BOXA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaaJoin(baad: *mut BOXAA, baas: *mut BOXAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaSplitEvenOdd(
        boxa: *mut BOXA,
        fillflag: l_int32,
        pboxae: *mut *mut BOXA,
        pboxao: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaMergeEvenOdd(boxae: *mut BOXA, boxao: *mut BOXA, fillflag: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaTransform(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransform(
        box_: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaTransformOrdered(
        boxas: *mut BOXA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxTransformOrdered(
        boxs: *mut BOX,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        order: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaRotateOrth(boxas: *mut BOXA, w: l_int32, h: l_int32, rotation: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxRotateOrth(box_: *mut BOX, w: l_int32, h: l_int32, rotation: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaShiftWithPta(boxas: *mut BOXA, pta: *mut PTA, dir: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaBinSort(
        boxas: *mut BOXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSortByIndex(boxas: *mut BOXA, naindex: *mut NUMA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSort2d(
        boxas: *mut BOXA,
        pnaad: *mut *mut NUMAA,
        delta1: l_int32,
        delta2: l_int32,
        minh1: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSort2dByIndex(boxas: *mut BOXA, naa: *mut NUMAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaExtractAsNuma(
        boxa: *mut BOXA,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        keepinvalid: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractAsPta(
        boxa: *mut BOXA,
        pptal: *mut *mut PTA,
        pptat: *mut *mut PTA,
        pptar: *mut *mut PTA,
        pptab: *mut *mut PTA,
        pptaw: *mut *mut PTA,
        pptah: *mut *mut PTA,
        keepinvalid: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractCorners(boxa: *mut BOXA, loc: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn boxaGetRankVals(
        boxa: *mut BOXA,
        fract: l_float32,
        px: *mut l_int32,
        py: *mut l_int32,
        pr: *mut l_int32,
        pb: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetMedianVals(
        boxa: *mut BOXA,
        px: *mut l_int32,
        py: *mut l_int32,
        pr: *mut l_int32,
        pb: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetAverageSize(boxa: *mut BOXA, pw: *mut l_float32, ph: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn boxaaGetExtent(
        baa: *mut BOXAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
        pboxa: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaFlattenToBoxa(
        baa: *mut BOXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaFlattenAligned(
        baa: *mut BOXAA,
        num: l_int32,
        fillerbox: *mut BOX,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaEncapsulateAligned(boxa: *mut BOXA, num: l_int32, copyflag: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaTranspose(baas: *mut BOXAA) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaaAlignBox(
        baa: *mut BOXAA,
        box_: *mut BOX,
        delta: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMaskConnComp(
        pixs: *mut PIX,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskBoxa(pixd: *mut PIX, pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxa(pixs: *mut PIX, boxa: *mut BOXA, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetBlackOrWhiteBoxa(pixs: *mut PIX, boxa: *mut BOXA, op: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIX;
}
extern "C" {
    pub fn pixBlendBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxa(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixDrawBoxaRandom(pixs: *mut PIX, boxa: *mut BOXA, width: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn boxaaDisplay(
        pixs: *mut PIX,
        baa: *mut BOXAA,
        linewba: l_int32,
        linewb: l_int32,
        colorba: l_uint32,
        colorb: l_uint32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayBoxaa(
        pixas: *mut PIXA,
        baa: *mut BOXAA,
        colorflag: l_int32,
        width: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSplitIntoBoxa(
        pixs: *mut PIX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixSplitComponentIntoBoxa(
        pix: *mut PIX,
        box_: *mut BOX,
        minsum: l_int32,
        skipdist: l_int32,
        delta: l_int32,
        maxbg: l_int32,
        maxcomps: l_int32,
        remainder: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn makeMosaicStrips(w: l_int32, h: l_int32, direction: l_int32, size: l_int32)
        -> *mut BOXA;
}
extern "C" {
    pub fn boxaCompareRegions(
        boxa1: *mut BOXA,
        boxa2: *mut BOXA,
        areathresh: l_int32,
        pnsame: *mut l_int32,
        pdiffarea: *mut l_float32,
        pdiffxor: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSelectLargeULComp(
        pixs: *mut PIX,
        areaslop: l_float32,
        yslop: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectLargeULBox(boxas: *mut BOXA, areaslop: l_float32, yslop: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn boxaSelectRange(
        boxas: *mut BOXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaaSelectRange(
        baas: *mut BOXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn boxaSelectBySize(
        boxas: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeSizeIndicator(
        boxa: *mut BOXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByArea(
        boxas: *mut BOXA,
        area: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeAreaIndicator(boxa: *mut BOXA, area: l_int32, relation: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectByWHRatio(
        boxas: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaMakeWHRatioIndicator(
        boxa: *mut BOXA,
        ratio: l_float32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn boxaSelectWithIndicator(
        boxas: *mut BOXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermutePseudorandom(boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPermuteRandom(boxad: *mut BOXA, boxas: *mut BOXA) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSwapBoxes(boxa: *mut BOXA, i: l_int32, j: l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaConvertToPta(boxa: *mut BOXA, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBoxa(pta: *mut PTA, ncorners: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxConvertToPta(box_: *mut BOX, ncorners: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToBox(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn boxaGetExtent(
        boxa: *mut BOXA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbox: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetCoverage(
        boxa: *mut BOXA,
        wc: l_int32,
        hc: l_int32,
        exactflag: l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaSizeRange(
        baa: *mut BOXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaSizeRange(
        boxa: *mut BOXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaLocationRange(
        boxa: *mut BOXA,
        pminx: *mut l_int32,
        pminy: *mut l_int32,
        pmaxx: *mut l_int32,
        pmaxy: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetSizes(boxa: *mut BOXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn boxaGetArea(boxa: *mut BOXA, parea: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn boxaDisplayTiled(
        boxas: *mut BOXA,
        pixa: *mut PIXA,
        first: l_int32,
        last: l_int32,
        maxwidth: l_int32,
        linewidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn boxaSmoothSequenceMedian(
        boxas: *mut BOXA,
        halfwin: l_int32,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
        debug: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaWindowedMedian(boxas: *mut BOXA, halfwin: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaModifyWithBoxa(
        boxas: *mut BOXA,
        boxam: *mut BOXA,
        subflag: l_int32,
        maxdiff: l_int32,
        extrapixels: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcilePairWidth(
        boxas: *mut BOXA,
        delw: l_int32,
        op: l_int32,
        factor: l_float32,
        na: *mut NUMA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSizeConsistency(
        boxas: *mut BOXA,
        type_: l_int32,
        threshp: l_float32,
        threshm: l_float32,
        pfvarp: *mut l_float32,
        pfvarm: *mut l_float32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaReconcileAllByMedian(
        boxas: *mut BOXA,
        select1: l_int32,
        select2: l_int32,
        thresh: l_int32,
        extra: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileSidesByMedian(
        boxas: *mut BOXA,
        select: l_int32,
        thresh: l_int32,
        extra: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaReconcileSizeByMedian(
        boxas: *mut BOXA,
        type_: l_int32,
        dfract: l_float32,
        sfract: l_float32,
        factor: l_float32,
        pnadelw: *mut *mut NUMA,
        pnadelh: *mut *mut NUMA,
        pratiowh: *mut l_float32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPlotSides(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnal: *mut *mut NUMA,
        pnat: *mut *mut NUMA,
        pnar: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaPlotSizes(
        boxa: *mut BOXA,
        plotname: *const ::std::os::raw::c_char,
        pnaw: *mut *mut NUMA,
        pnah: *mut *mut NUMA,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaFillSequence(boxas: *mut BOXA, useflag: l_int32, debug: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn boxaSizeVariation(
        boxa: *mut BOXA,
        type_: l_int32,
        pdel_evenodd: *mut l_float32,
        prms_even: *mut l_float32,
        prms_odd: *mut l_float32,
        prms_all: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaMedianDimensions(
        boxas: *mut BOXA,
        pmedw: *mut l_int32,
        pmedh: *mut l_int32,
        pmedwe: *mut l_int32,
        pmedwo: *mut l_int32,
        pmedhe: *mut l_int32,
        pmedho: *mut l_int32,
        pnadelw: *mut *mut NUMA,
        pnadelh: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaCreate(nbytes: size_t) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromMem(data: *const l_uint8, size: size_t) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromFile(fname: *const ::std::os::raw::c_char) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaInitFromStream(fp: *mut FILE) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaCopy(bas: *mut L_BYTEA, copyflag: l_int32) -> *mut L_BYTEA;
}
extern "C" {
    pub fn l_byteaDestroy(pba: *mut *mut L_BYTEA);
}
extern "C" {
    pub fn l_byteaGetSize(ba: *mut L_BYTEA) -> size_t;
}
extern "C" {
    pub fn l_byteaGetData(ba: *mut L_BYTEA, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaCopyData(ba: *mut L_BYTEA, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_byteaAppendData(ba: *mut L_BYTEA, newdata: *const l_uint8, newbytes: size_t) -> l_ok;
}
extern "C" {
    pub fn l_byteaAppendString(ba: *mut L_BYTEA, str_: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn l_byteaJoin(ba1: *mut L_BYTEA, pba2: *mut *mut L_BYTEA) -> l_ok;
}
extern "C" {
    pub fn l_byteaSplit(ba1: *mut L_BYTEA, splitloc: size_t, pba2: *mut *mut L_BYTEA) -> l_ok;
}
extern "C" {
    pub fn l_byteaFindEachSequence(
        ba: *mut L_BYTEA,
        sequence: *const l_uint8,
        seqlen: size_t,
        pda: *mut *mut L_DNA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaWrite(
        fname: *const ::std::os::raw::c_char,
        ba: *mut L_BYTEA,
        startloc: size_t,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn l_byteaWriteStream(
        fp: *mut FILE,
        ba: *mut L_BYTEA,
        startloc: size_t,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn ccbaCreate(pixs: *mut PIX, n: l_int32) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaDestroy(pccba: *mut *mut CCBORDA);
}
extern "C" {
    pub fn ccbCreate(pixs: *mut PIX) -> *mut CCBORD;
}
extern "C" {
    pub fn ccbDestroy(pccb: *mut *mut CCBORD);
}
extern "C" {
    pub fn ccbaAddCcb(ccba: *mut CCBORDA, ccb: *mut CCBORD) -> l_ok;
}
extern "C" {
    pub fn ccbaGetCount(ccba: *mut CCBORDA) -> l_int32;
}
extern "C" {
    pub fn ccbaGetCcb(ccba: *mut CCBORDA, index: l_int32) -> *mut CCBORD;
}
extern "C" {
    pub fn pixGetAllCCBorders(pixs: *mut PIX) -> *mut CCBORDA;
}
extern "C" {
    pub fn pixGetOuterBordersPtaa(pixs: *mut PIX) -> *mut PTAA;
}
extern "C" {
    pub fn pixGetOuterBorder(ccb: *mut CCBORD, pixs: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateGlobalLocs(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateStepChains(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaStepChainsToPixCoords(ccba: *mut CCBORDA, coordtype: l_int32) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateSPGlobalLocs(ccba: *mut CCBORDA, ptsflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn ccbaGenerateSinglePath(ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn getCutPathForHole(
        pix: *mut PIX,
        pta: *mut PTA,
        boxinner: *mut BOX,
        pdir: *mut l_int32,
        plen: *mut l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ccbaDisplayBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplaySPBorder(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage1(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaDisplayImage2(ccba: *mut CCBORDA) -> *mut PIX;
}
extern "C" {
    pub fn ccbaWrite(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaWriteStream(fp: *mut FILE, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaRead(filename: *const ::std::os::raw::c_char) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaReadStream(fp: *mut FILE) -> *mut CCBORDA;
}
extern "C" {
    pub fn ccbaWriteSVG(filename: *const ::std::os::raw::c_char, ccba: *mut CCBORDA) -> l_ok;
}
extern "C" {
    pub fn ccbaWriteSVGString(ccba: *mut CCBORDA) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixaThinConnected(
        pixas: *mut PIXA,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixThinConnected(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThinConnectedBySet(
        pixs: *mut PIX,
        type_: l_int32,
        sela: *mut SELA,
        maxiters: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaMakeThinSets(index: l_int32, debug: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn pixFindCheckerboardCorners(
        pixs: *mut PIX,
        size: l_int32,
        dilation: l_int32,
        nsels: l_int32,
        ppix_corners: *mut *mut PIX,
        ppta_corners: *mut *mut PTA,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbCorrelation(
        dirin: *const ::std::os::raw::c_char,
        thresh: l_float32,
        weight: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn jbRankHaus(
        dirin: *const ::std::os::raw::c_char,
        size: l_int32,
        rank: l_float32,
        components: l_int32,
        rootname: *const ::std::os::raw::c_char,
        firstpage: l_int32,
        npages: l_int32,
        renderflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn jbWordsInTextlines(
        dirin: *const ::std::os::raw::c_char,
        reduction: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weight: l_float32,
        pnatl: *mut *mut NUMA,
        firstpage: l_int32,
        npages: l_int32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn pixGetWordsInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
        pnai: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetWordBoxesInTextlines(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        pnai: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindWordAndCharacterBoxes(
        pixs: *mut PIX,
        boxs: *mut BOX,
        thresh: l_int32,
        pboxaw: *mut *mut BOXA,
        pboxaac: *mut *mut BOXAA,
        debugdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaExtractSortedPattern(boxa: *mut BOXA, na: *mut NUMA) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCompareImagesByBoxes(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        nperline: l_int32,
        nreq: l_int32,
        maxshiftx: l_int32,
        maxshifty: l_int32,
        delx: l_int32,
        dely: l_int32,
        psame: *mut l_int32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorContent(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        mingray: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorMagnitude(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorFraction(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        factor: l_int32,
        ppixfract: *mut l_float32,
        pcolorfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorShiftWhitePoint(
        pixs: *mut PIX,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorPixels(
        pixs: *mut PIX,
        threshdiff: l_int32,
        mindist: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverGrayPixels(pixs: *mut PIX, maxlimit: l_int32, satlimit: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaskOverColorRange(
        pixs: *mut PIX,
        rmin: l_int32,
        rmax: l_int32,
        gmin: l_int32,
        gmax: l_int32,
        bmin: l_int32,
        bmax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindColorRegions(
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_int32,
        lightthresh: l_int32,
        darkthresh: l_int32,
        mindiff: l_int32,
        colordiff: l_int32,
        edgefract: l_float32,
        pcolorfract: *mut l_float32,
        pcolormask1: *mut *mut PIX,
        pcolormask2: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixNumSignificantGrayColors(
        pixs: *mut PIX,
        darkthresh: l_int32,
        lightthresh: l_int32,
        minfract: l_float32,
        factor: l_int32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorsForQuantization(
        pixs: *mut PIX,
        thresh: l_int32,
        pncolors: *mut l_int32,
        piscolor: *mut l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixNumColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToCmapLossless(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetMostPopulatedColors(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
        parray: *mut *mut l_uint32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSimpleColorQuantize(
        pixs: *mut PIX,
        sigbits: l_int32,
        factor: l_int32,
        ncolors: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBHistogram(pixs: *mut PIX, sigbits: l_int32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn makeRGBIndexTables(
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
        sigbits: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn getRGBFromIndex(
        index: l_uint32,
        sigbits: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixHasHighlightRed(
        pixs: *mut PIX,
        factor: l_int32,
        minfract: l_float32,
        fthresh: l_float32,
        phasred: *mut l_int32,
        pratio: *mut l_float32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn l_colorfillCreate(pixs: *mut PIX, nx: l_int32, ny: l_int32) -> *mut L_COLORFILL;
}
extern "C" {
    pub fn l_colorfillDestroy(pcf: *mut *mut L_COLORFILL);
}
extern "C" {
    pub fn pixColorContentByLocation(
        cf: *mut L_COLORFILL,
        rref: l_int32,
        gref: l_int32,
        bref: l_int32,
        minmax: l_int32,
        maxdiff: l_int32,
        minarea: l_int32,
        smooth: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorFill(
        pixs: *mut PIX,
        minmax: l_int32,
        maxdiff: l_int32,
        smooth: l_int32,
        minarea: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeColorfillTestData(
        w: l_int32,
        h: l_int32,
        nseeds: l_int32,
        range: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixColorGrayRegions(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorGray(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        thresh: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSnapColorCmap(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
        diff: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixLinearMapToTargetColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelLinearMapToTargetColor(
        scolor: l_uint32,
        srcmap: l_uint32,
        dstmap: l_uint32,
        pdcolor: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixShiftByComponent(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        dstval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixelShiftByComponent(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        srcval: l_uint32,
        dstval: l_uint32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixelFractionalShift(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMapWithInvariantHue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        srcval: l_uint32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixcmapCreate(depth: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateRandom(
        depth: l_int32,
        hasblack: l_int32,
        haswhite: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCreateLinear(d: l_int32, nlevels: l_int32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapCopy(cmaps: *const PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapDestroy(pcmap: *mut *mut PIXCMAP);
}
extern "C" {
    pub fn pixcmapIsValid(cmap: *const PIXCMAP, pix: *mut PIX, pvalid: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddColor(cmap: *mut PIXCMAP, rval: l_int32, gval: l_int32, bval: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixcmapAddRGBA(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddNewColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddNearestColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapUsableColor(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pusable: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapAddBlackOrWhite(cmap: *mut PIXCMAP, color: l_int32, pindex: *mut l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixcmapSetBlackAndWhite(
        cmap: *mut PIXCMAP,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetCount(cmap: *const PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetFreeCount(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetDepth(cmap: *mut PIXCMAP) -> l_int32;
}
extern "C" {
    pub fn pixcmapGetMinDepth(cmap: *mut PIXCMAP, pmindepth: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapClear(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetColor32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRGBA(
        cmap: *mut PIXCMAP,
        index: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRGBA32(cmap: *mut PIXCMAP, index: l_int32, pval32: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixcmapResetColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapSetAlpha(cmap: *mut PIXCMAP, index: l_int32, aval: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixcmapHasColor(cmap: *mut PIXCMAP, pcolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapIsOpaque(cmap: *mut PIXCMAP, popaque: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapNonOpaqueColorsInfo(
        cmap: *mut PIXCMAP,
        pntrans: *mut l_int32,
        pmax_trans: *mut l_int32,
        pmin_opaque: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapIsBlackAndWhite(cmap: *mut PIXCMAP, pblackwhite: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapCountGrayColors(cmap: *mut PIXCMAP, pngray: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRankIntensity(
        cmap: *mut PIXCMAP,
        rankval: l_float32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetNearestIndex(
        cmap: *mut PIXCMAP,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetNearestGrayIndex(
        cmap: *mut PIXCMAP,
        val: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetDistanceToColor(
        cmap: *mut PIXCMAP,
        index: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pdist: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGetRangeValues(
        cmap: *mut PIXCMAP,
        select: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pminindex: *mut l_int32,
        pmaxindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapGrayToFalseColor(gamma: l_float32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapGrayToColor(color: l_uint32) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapColorToGray(
        cmaps: *mut PIXCMAP,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo4(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertTo8(cmaps: *mut PIXCMAP) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapRead(filename: *const ::std::os::raw::c_char) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadStream(fp: *mut FILE) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapReadMem(data: *const l_uint8, size: size_t) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapWrite(filename: *const ::std::os::raw::c_char, cmap: *const PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapWriteStream(fp: *mut FILE, cmap: *const PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        cmap: *const PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapToArrays(
        cmap: *const PIXCMAP,
        prmap: *mut *mut l_int32,
        pgmap: *mut *mut l_int32,
        pbmap: *mut *mut l_int32,
        pamap: *mut *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapToRGBTable(
        cmap: *mut PIXCMAP,
        ptab: *mut *mut l_uint32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapSerializeToMemory(
        cmap: *mut PIXCMAP,
        cpc: l_int32,
        pncolors: *mut l_int32,
        pdata: *mut *mut l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapDeserializeFromMemory(
        data: *mut l_uint8,
        cpc: l_int32,
        ncolors: l_int32,
    ) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixcmapConvertToHex(data: *mut l_uint8, ncolors: l_int32)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixcmapGammaTRC(
        cmap: *mut PIXCMAP,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapContrastTRC(cmap: *mut PIXCMAP, factor: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixcmapShiftIntensity(cmap: *mut PIXCMAP, fraction: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixcmapShiftByComponent(cmap: *mut PIXCMAP, srcval: l_uint32, dstval: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixColorMorph(
        pixs: *mut PIX,
        type_: l_int32,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuant(pixs: *mut PIX, colors: l_int32, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeColorQuantGeneral(
        pixs: *mut PIX,
        colors: l_int32,
        ditherflag: l_int32,
        validthresh: l_float32,
        colorthresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeRGBToIndexTables(
        cqlevels: l_int32,
        prtab: *mut *mut l_uint32,
        pgtab: *mut *mut l_uint32,
        pbtab: *mut *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn getOctcubeIndexFromRGB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        rtab: *mut l_uint32,
        gtab: *mut l_uint32,
        btab: *mut l_uint32,
        pindex: *mut l_uint32,
    );
}
extern "C" {
    pub fn pixOctreeQuantByPopulation(
        pixs: *mut PIX,
        level: l_int32,
        ditherflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctreeQuantNumColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        subsample: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantMixedWithGray(
        pixs: *mut PIX,
        depth: l_int32,
        graylevels: l_int32,
        delta: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuant256(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant1(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuant2(
        pixs: *mut PIX,
        level: l_int32,
        na: *mut NUMA,
        ncolors: l_int32,
        pnerrors: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsOctcubeQuantMixed(
        pixs: *mut PIX,
        level: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
        minfract: l_float32,
        maxspan: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFixedOctcubeQuantGenRGB(pixs: *mut PIX, level: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeQuantFromCmap(
        pixs: *mut PIX,
        cmap: *mut PIXCMAP,
        mindepth: l_int32,
        level: l_int32,
        metric: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOctcubeHistogram(pixs: *mut PIX, level: l_int32, pncolors: *mut l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixcmapToOctcubeLUT(cmap: *mut PIXCMAP, level: l_int32, metric: l_int32)
        -> *mut l_int32;
}
extern "C" {
    pub fn pixRemoveUnusedColors(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixNumberOccupiedOctcubes(
        pix: *mut PIX,
        level: l_int32,
        mincount: l_int32,
        minfract: l_float32,
        pncolors: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMedianCutQuant(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantGeneral(
        pixs: *mut PIX,
        ditherflag: l_int32,
        outdepth: l_int32,
        maxcolors: l_int32,
        sigbits: l_int32,
        maxsub: l_int32,
        checkbw: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFewColorsMedianCutQuantMixed(
        pixs: *mut PIX,
        ncolor: l_int32,
        ngray: l_int32,
        maxncolors: l_int32,
        darkthresh: l_int32,
        lightthresh: l_int32,
        diffthresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMedianCutHisto(pixs: *mut PIX, sigbits: l_int32, subsample: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn pixColorSegment(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        selsize: l_int32,
        finalcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorSegmentCluster(
        pixs: *mut PIX,
        maxdist: l_int32,
        maxcolors: l_int32,
        debugflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAssignToNearestColor(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        level: l_int32,
        countarray: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorSegmentClean(pixs: *mut PIX, selsize: l_int32, countarray: *mut l_int32)
        -> l_ok;
}
extern "C" {
    pub fn pixColorSegmentRemoveColors(
        pixd: *mut PIX,
        pixs: *mut PIX,
        finalcolors: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToHSV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertHSVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToHSV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        phval: *mut l_int32,
        psval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertHSVToRGB(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertRGBToHSV(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertHSVToRGB(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToHue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToSaturation(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToValue(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHS(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        satcenter: l_int32,
        sathw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskHV(
        pixs: *mut PIX,
        huecenter: l_int32,
        huehw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeRangeMaskSV(
        pixs: *mut PIX,
        satcenter: l_int32,
        sathw: l_int32,
        valcenter: l_int32,
        valhw: l_int32,
        regionflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHS(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnasat: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoHV(
        pixs: *mut PIX,
        factor: l_int32,
        pnahue: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeHistoSV(
        pixs: *mut PIX,
        factor: l_int32,
        pnasat: *mut *mut NUMA,
        pnaval: *mut *mut NUMA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHistoPeaksHSV(
        pixs: *mut PIX,
        type_: l_int32,
        width: l_int32,
        height: l_int32,
        npeaks: l_int32,
        erasefactor: l_float32,
        ppta: *mut *mut PTA,
        pnatot: *mut *mut NUMA,
        ppixa: *mut *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn displayHSVColorRange(
        hval: l_int32,
        sval: l_int32,
        vval: l_int32,
        huehw: l_int32,
        sathw: l_int32,
        nsamp: l_int32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToYUV(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertYUVToRGB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToYUV(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pyval: *mut l_int32,
        puval: *mut l_int32,
        pvval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertYUVToRGB(
        yval: l_int32,
        uval: l_int32,
        vval: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertRGBToYUV(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixcmapConvertYUVToRGB(cmap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToXYZ(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertXYZToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToXYZ(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pfxval: *mut l_float32,
        pfyval: *mut l_float32,
        pfzval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertXYZToRGB(
        fxval: l_float32,
        fyval: l_float32,
        fzval: l_float32,
        blackout: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaConvertXYZToLAB(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToXYZ(fpixas: *mut FPIXA) -> *mut FPIXA;
}
extern "C" {
    pub fn convertXYZToLAB(
        xval: l_float32,
        yval: l_float32,
        zval: l_float32,
        plval: *mut l_float32,
        paval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertLABToXYZ(
        lval: l_float32,
        aval: l_float32,
        bval: l_float32,
        pxval: *mut l_float32,
        pyval: *mut l_float32,
        pzval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertRGBToLAB(pixs: *mut PIX) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaConvertLABToRGB(fpixa: *mut FPIXA) -> *mut PIX;
}
extern "C" {
    pub fn convertRGBToLAB(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pflval: *mut l_float32,
        pfaval: *mut l_float32,
        pfbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertLABToRGB(
        flval: l_float32,
        faval: l_float32,
        fbval: l_float32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeGamutRGB(scale: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixEqual(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixEqualWithAlpha(
        pix1: *mut PIX,
        pix2: *mut PIX,
        use_alpha: l_int32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixEqualWithCmap(pix1: *mut PIX, pix2: *mut PIX, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn cmapEqual(
        cmap1: *mut PIXCMAP,
        cmap2: *mut PIXCMAP,
        ncomps: l_int32,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixUsesCmapColor(pixs: *mut PIX, pcolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationBinary(pix1: *mut PIX, pix2: *mut PIX, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixDisplayDiffBinary(pix1: *mut PIX, pix2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCompareBinary(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        pfract: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGrayOrRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGray(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareRGB(
        pix1: *mut PIX,
        pix2: *mut PIX,
        comptype: l_int32,
        plottype: l_int32,
        psame: *mut l_int32,
        pdiff: *mut l_float32,
        prmsdiff: *mut l_float32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareTiled(
        pix1: *mut PIX,
        pix2: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixdiff: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareRankDifference(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTestForSimilarity(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        maxfract: l_float32,
        maxave: l_float32,
        psimilar: *mut l_int32,
        details: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetDifferenceStats(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        mindiff: l_int32,
        pfractdiff: *mut l_float32,
        pavediff: *mut l_float32,
        details: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetDifferenceHistogram(pix1: *mut PIX, pix2: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetPerceptualDiff(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        sampling: l_int32,
        dilation: l_int32,
        mindiff: l_int32,
        pfract: *mut l_float32,
        ppixdiff1: *mut *mut PIX,
        ppixdiff2: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPSNR(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        ppsnr: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaComparePhotoRegionsByHisto(
        pixa: *mut PIXA,
        minratio: l_float32,
        textthresh: l_float32,
        factor: l_int32,
        n: l_int32,
        simthresh: l_float32,
        pnai: *mut *mut NUMA,
        pscores: *mut *mut l_float32,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixComparePhotoRegionsByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        factor: l_int32,
        n: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenPhotoHistos(
        pixs: *mut PIX,
        box_: *mut BOX,
        factor: l_int32,
        thresh: l_float32,
        n: l_int32,
        pnaa: *mut *mut NUMAA,
        pw: *mut l_int32,
        ph: *mut l_int32,
        debugindex: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPadToCenterCentroid(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCentroid8(
        pixs: *mut PIX,
        factor: l_int32,
        pcx: *mut l_float32,
        pcy: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfPhotoImage(
        pix: *mut PIX,
        factor: l_int32,
        thresh: l_float32,
        n: l_int32,
        pnaa: *mut *mut NUMAA,
        pixadebug: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn compareTilesByHisto(
        naa1: *mut NUMAA,
        naa2: *mut NUMAA,
        minratio: l_float32,
        w1: l_int32,
        h1: l_int32,
        w2: l_int32,
        h2: l_int32,
        pscore: *mut l_float32,
        pixadebug: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCompareGrayByHisto(
        pix1: *mut PIX,
        pix2: *mut PIX,
        box1: *mut BOX,
        box2: *mut BOX,
        minratio: l_float32,
        maxgray: l_int32,
        factor: l_int32,
        n: l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCropAlignedToCentroid(
        pix1: *mut PIX,
        pix2: *mut PIX,
        factor: l_int32,
        pbox1: *mut *mut BOX,
        pbox2: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn l_compressGrayHistograms(
        naa: *mut NUMAA,
        w: l_int32,
        h: l_int32,
        psize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_uncompressGrayHistograms(
        bytea: *mut l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixCompareWithTranslation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        thresh: l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBestCorrelation(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        etransx: l_int32,
        etransy: l_int32,
        maxshift: l_int32,
        tab8: *mut l_int32,
        pdelx: *mut l_int32,
        pdely: *mut l_int32,
        pscore: *mut l_float32,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConnComp(pixs: *mut PIX, ppixa: *mut *mut PIXA, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompPixa(
        pixs: *mut PIX,
        ppixa: *mut *mut PIXA,
        connectivity: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConnCompBB(pixs: *mut PIX, connectivity: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixCountConnComp(pixs: *mut PIX, connectivity: l_int32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn nextOnPixelInRaster(
        pixs: *mut PIX,
        xstart: l_int32,
        ystart: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSeedfillBB(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill4BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill8BB(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixSeedfill(
        pixs: *mut PIX,
        stack: *mut L_STACK,
        x: l_int32,
        y: l_int32,
        connectivity: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSeedfill4(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfill8(pixs: *mut PIX, stack: *mut L_STACK, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn convertFilesTo1bpp(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        upscaling: l_int32,
        thresh: l_int32,
        firstpage: l_int32,
        npages: l_int32,
        dirout: *const ::std::os::raw::c_char,
        outformat: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixBlockconv(pix: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGray(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvAccum(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayUnnormalized(pixs: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvTiled(
        pix: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlockconvGrayTile(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedStats(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        ppixm: *mut *mut PIX,
        ppixms: *mut *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWindowedMean(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedMeanSquare(
        pixs: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        hasborder: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWindowedVariance(
        pixm: *mut PIX,
        pixms: *mut PIX,
        pfpixv: *mut *mut FPIX,
        pfpixrv: *mut *mut FPIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMeanSquareAccum(pixs: *mut PIX) -> *mut DPIX;
}
extern "C" {
    pub fn pixBlockrank(
        pixs: *mut PIX,
        pixacc: *mut PIX,
        wc: l_int32,
        hc: l_int32,
        rank: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixBlocksum(pixs: *mut PIX, pixacc: *mut PIX, wc: l_int32, hc: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCensusTransform(pixs: *mut PIX, halfsize: l_int32, pixacc: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolve(
        pixs: *mut PIX,
        kel: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveSep(
        pixs: *mut PIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        outdepth: l_int32,
        normflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGB(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixConvolveRGBSep(pixs: *mut PIX, kelx: *mut L_KERNEL, kely: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvolve(fpixs: *mut FPIX, kel: *mut L_KERNEL, normflag: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixConvolveSep(
        fpixs: *mut FPIX,
        kelx: *mut L_KERNEL,
        kely: *mut L_KERNEL,
        normflag: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvolveWithBias(
        pixs: *mut PIX,
        kel1: *mut L_KERNEL,
        kel2: *mut L_KERNEL,
        force8: l_int32,
        pbias: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setConvolveSampling(xfact: l_int32, yfact: l_int32);
}
extern "C" {
    pub fn pixAddGaussianNoise(pixs: *mut PIX, stdev: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn gaussDistribSampling() -> l_float32;
}
extern "C" {
    pub fn pixCorrelationScore(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationScoreThresholded(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        downcount: *mut l_int32,
        score_threshold: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixCorrelationScoreSimple(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCorrelationScoreShifted(
        pix1: *mut PIX,
        pix2: *mut PIX,
        area1: l_int32,
        area2: l_int32,
        delx: l_int32,
        dely: l_int32,
        tab: *mut l_int32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpCreate(pixs: *mut PIX, pageno: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpCreateRef(pageno: l_int32, refpage: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpDestroy(pdew: *mut *mut L_DEWARP);
}
extern "C" {
    pub fn dewarpaCreate(
        nptrs: l_int32,
        sampling: l_int32,
        redfactor: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaCreateFromPixacomp(
        pixac: *mut PIXAC,
        useboth: l_int32,
        sampling: l_int32,
        minlines: l_int32,
        maxdist: l_int32,
    ) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaDestroy(pdewa: *mut *mut L_DEWARPA);
}
extern "C" {
    pub fn dewarpaDestroyDewarp(dewa: *mut L_DEWARPA, pageno: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaInsertDewarp(dewa: *mut L_DEWARPA, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpaGetDewarp(dewa: *mut L_DEWARPA, index: l_int32) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpaSetCurvatures(
        dewa: *mut L_DEWARPA,
        max_linecurv: l_int32,
        min_diff_linecurv: l_int32,
        max_diff_linecurv: l_int32,
        max_edgecurv: l_int32,
        max_diff_edgecurv: l_int32,
        max_edgeslope: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaUseBothArrays(dewa: *mut L_DEWARPA, useboth: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetCheckColumns(dewa: *mut L_DEWARPA, check_columns: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetMaxDistance(dewa: *mut L_DEWARPA, maxdist: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadStream(fp: *mut FILE) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpReadMem(data: *const l_uint8, size: size_t) -> *mut L_DEWARP;
}
extern "C" {
    pub fn dewarpWrite(filename: *const ::std::os::raw::c_char, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpWriteStream(fp: *mut FILE, dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, dew: *mut L_DEWARP)
        -> l_ok;
}
extern "C" {
    pub fn dewarpaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadStream(fp: *mut FILE) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DEWARPA;
}
extern "C" {
    pub fn dewarpaWrite(filename: *const ::std::os::raw::c_char, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaWriteStream(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        dewa: *mut L_DEWARPA,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpBuildPageModel(
        dew: *mut L_DEWARP,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpFindVertDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA, rotflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpFindHorizDisparity(dew: *mut L_DEWARP, ptaa: *mut PTAA) -> l_ok;
}
extern "C" {
    pub fn dewarpGetTextlineCenters(pixs: *mut PIX, debugflag: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpRemoveShortLines(
        pixs: *mut PIX,
        ptaas: *mut PTAA,
        fract: l_float32,
        debugflag: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn dewarpFindHorizSlopeDisparity(
        dew: *mut L_DEWARP,
        pixb: *mut PIX,
        fractthresh: l_float32,
        parity: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpBuildLineModel(
        dew: *mut L_DEWARP,
        opensize: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaModelStatus(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pvsuccess: *mut l_int32,
        phsuccess: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaApplyDisparity(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        grayin: l_int32,
        x: l_int32,
        y: l_int32,
        ppixd: *mut *mut PIX,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaApplyDisparityBoxa(
        dewa: *mut L_DEWARPA,
        pageno: l_int32,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        mapdir: l_int32,
        x: l_int32,
        y: l_int32,
        pboxad: *mut *mut BOXA,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpMinimize(dew: *mut L_DEWARP) -> l_ok;
}
extern "C" {
    pub fn dewarpPopulateFullRes(dew: *mut L_DEWARP, pix: *mut PIX, x: l_int32, y: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePage(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixd: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePageInit(
        pixs: *mut PIX,
        thresh: l_int32,
        adaptive: l_int32,
        useboth: l_int32,
        check_columns: l_int32,
        ppixb: *mut *mut PIX,
        pdewa: *mut *mut L_DEWARPA,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpSinglePageRun(
        pixs: *mut PIX,
        pixb: *mut PIX,
        dewa: *mut L_DEWARPA,
        ppixd: *mut *mut PIX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaListPages(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaSetValidModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaInsertRefModels(dewa: *mut L_DEWARPA, notests: l_int32, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn dewarpaStripRefModels(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaRestoreModels(dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaInfo(fp: *mut FILE, dewa: *mut L_DEWARPA) -> l_ok;
}
extern "C" {
    pub fn dewarpaModelStats(
        dewa: *mut L_DEWARPA,
        pnnone: *mut l_int32,
        pnvsuccess: *mut l_int32,
        pnvvalid: *mut l_int32,
        pnhsuccess: *mut l_int32,
        pnhvalid: *mut l_int32,
        pnref: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpaShowArrays(
        dewa: *mut L_DEWARPA,
        scalefact: l_float32,
        first: l_int32,
        last: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpDebug(
        dew: *mut L_DEWARP,
        subdirs: *const ::std::os::raw::c_char,
        index: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dewarpShowResults(
        dewa: *mut L_DEWARPA,
        sa: *mut SARRAY,
        boxa: *mut BOXA,
        firstpage: l_int32,
        lastpage: l_int32,
        pdfout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaCreate(n: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaCreateFromDArray(
        darray: *mut l_float64,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaMakeSequence(
        startval: l_float64,
        increment: l_float64,
        size: l_int32,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaDestroy(pda: *mut *mut L_DNA);
}
extern "C" {
    pub fn l_dnaCopy(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaClone(da: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaEmpty(da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaAddNumber(da: *mut L_DNA, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaInsertNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaRemoveNumber(da: *mut L_DNA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaReplaceNumber(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetCount(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaSetCount(da: *mut L_DNA, newcount: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetDValue(da: *mut L_DNA, index: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetIValue(da: *mut L_DNA, index: l_int32, pival: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaSetValue(da: *mut L_DNA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaShiftValue(da: *mut L_DNA, index: l_int32, diff: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetIArray(da: *mut L_DNA) -> *mut l_int32;
}
extern "C" {
    pub fn l_dnaGetDArray(da: *mut L_DNA, copyflag: l_int32) -> *mut l_float64;
}
extern "C" {
    pub fn l_dnaGetRefcount(da: *mut L_DNA) -> l_int32;
}
extern "C" {
    pub fn l_dnaChangeRefcount(da: *mut L_DNA, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaGetParameters(
        da: *mut L_DNA,
        pstartx: *mut l_float64,
        pdelx: *mut l_float64,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaSetParameters(da: *mut L_DNA, startx: l_float64, delx: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaCopyParameters(dad: *mut L_DNA, das: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadStream(fp: *mut FILE) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaWrite(filename: *const ::std::os::raw::c_char, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteStream(fp: *mut FILE, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteStderr(da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaCreate(n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaCreateFull(nptr: l_int32, n: l_int32) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaTruncate(daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaDestroy(pdaa: *mut *mut L_DNAA);
}
extern "C" {
    pub fn l_dnaaAddDna(daa: *mut L_DNAA, da: *mut L_DNA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaaGetCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDnaCount(daa: *mut L_DNAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetNumberCount(daa: *mut L_DNAA) -> l_int32;
}
extern "C" {
    pub fn l_dnaaGetDna(daa: *mut L_DNAA, index: l_int32, accessflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaaReplaceDna(daa: *mut L_DNAA, index: l_int32, da: *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaGetValue(daa: *mut L_DNAA, i: l_int32, j: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaaAddNumber(daa: *mut L_DNAA, index: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn l_dnaaRead(filename: *const ::std::os::raw::c_char) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadStream(fp: *mut FILE) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaReadMem(data: *const l_uint8, size: size_t) -> *mut L_DNAA;
}
extern "C" {
    pub fn l_dnaaWrite(filename: *const ::std::os::raw::c_char, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaWriteStream(fp: *mut FILE, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, daa: *mut L_DNAA) -> l_ok;
}
extern "C" {
    pub fn l_dnaJoin(dad: *mut L_DNA, das: *mut L_DNA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_dnaaFlattenToDna(daa: *mut L_DNAA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaSelectRange(das: *mut L_DNA, first: l_int32, last: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaConvertToNuma(da: *mut L_DNA) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToDna(na: *mut NUMA) -> *mut L_DNA;
}
extern "C" {
    pub fn pixConvertDataToDna(pix: *mut PIX) -> *mut L_DNA;
}
extern "C" {
    pub fn l_asetCreateFromDna(da: *mut L_DNA) -> *mut L_ASET;
}
extern "C" {
    pub fn l_dnaRemoveDupsByAset(das: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaUnionByAset(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaIntersectionByAset(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA)
        -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromDna(da: *mut L_DNA) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn l_dnaRemoveDupsByHmap(
        das: *mut L_DNA,
        pdad: *mut *mut L_DNA,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaUnionByHmap(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA) -> l_ok;
}
extern "C" {
    pub fn l_dnaIntersectionByHmap(da1: *mut L_DNA, da2: *mut L_DNA, pdad: *mut *mut L_DNA)
        -> l_ok;
}
extern "C" {
    pub fn l_dnaMakeHistoByHmap(
        das: *mut L_DNA,
        pdav: *mut *mut L_DNA,
        pdac: *mut *mut L_DNA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_dnaDiffAdjValues(das: *mut L_DNA) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashCreate(nbuckets: l_int32, initsize: l_int32) -> *mut L_DNAHASH;
}
extern "C" {
    pub fn l_dnaHashDestroy(pdahash: *mut *mut L_DNAHASH);
}
extern "C" {
    pub fn l_dnaHashGetDna(dahash: *mut L_DNAHASH, key: l_uint64, copyflag: l_int32) -> *mut L_DNA;
}
extern "C" {
    pub fn l_dnaHashAdd(dahash: *mut L_DNAHASH, key: l_uint64, value: l_float64) -> l_ok;
}
extern "C" {
    pub fn pixMorphDwa_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_2(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_2(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSobelEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTwoSidedEdgeFilter(pixs: *mut PIX, orientflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureEdgeSmoothness(
        pixs: *mut PIX,
        side: l_int32,
        minjump: l_int32,
        minreversal: l_int32,
        pjpl: *mut l_float32,
        pjspl: *mut l_float32,
        prpl: *mut l_float32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetEdgeProfile(
        pixs: *mut PIX,
        side: l_int32,
        debugfile: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetLastOffPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetLastOnPixelInRun(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        direction: l_int32,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn encodeBase64(
        inarray: *const l_uint8,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeBase64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85(
        inarray: *const l_uint8,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85(
        inarray: *const ::std::os::raw::c_char,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn encodeAscii85WithComp(
        indata: *const l_uint8,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn decodeAscii85WithComp(
        instr: *const ::std::os::raw::c_char,
        insize: size_t,
        poutsize: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn reformatPacked64(
        inarray: *const ::std::os::raw::c_char,
        insize: l_int32,
        leadspace: l_int32,
        linechars: l_int32,
        addquotes: l_int32,
        poutsize: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixGammaTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGammaTRCWithAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        gamma: l_float32,
        minval: l_int32,
        maxval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaGammaTRC(gamma: l_float32, minval: l_int32, maxval: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixContrastTRC(pixd: *mut PIX, pixs: *mut PIX, factor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixContrastTRCMasked(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        factor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaContrastTRC(factor: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn pixEqualizeTRC(
        pixd: *mut PIX,
        pixs: *mut PIX,
        fract: l_float32,
        factor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaEqualizeTRC(pix: *mut PIX, fract: l_float32, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixTRCMap(pixs: *mut PIX, pixm: *mut PIX, na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixTRCMapGeneral(
        pixs: *mut PIX,
        pixm: *mut PIX,
        nar: *mut NUMA,
        nag: *mut NUMA,
        nab: *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixUnsharpMasking(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray(pixs: *mut PIX, halfwidth: l_int32, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGrayFast(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray1D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
        direction: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixUnsharpMaskingGray2D(
        pixs: *mut PIX,
        halfwidth: l_int32,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixModifyHue(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixModifySaturation(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMeasureSaturation(pixs: *mut PIX, factor: l_int32, psat: *mut l_float32) -> l_int32;
}
extern "C" {
    pub fn pixModifyBrightness(pixd: *mut PIX, pixs: *mut PIX, fract: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixMosaicColorShiftRGB(
        pixs: *mut PIX,
        roff: l_float32,
        goff: l_float32,
        boff: l_float32,
        delta: l_float32,
        nincr: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorShiftRGB(
        pixs: *mut PIX,
        rfract: l_float32,
        gfract: l_float32,
        bfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDarkenGray(
        pixd: *mut PIX,
        pixs: *mut PIX,
        thresh: l_int32,
        satlimit: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultConstantColor(
        pixs: *mut PIX,
        rfact: l_float32,
        gfact: l_float32,
        bfact: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMultMatrixColor(pixs: *mut PIX, kel: *mut L_KERNEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHalfEdgeByBandpass(
        pixs: *mut PIX,
        sm1h: l_int32,
        sm1v: l_int32,
        sm2h: l_int32,
        sm2v: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fhmtautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fhmtautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixHMTDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFHMTGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fhmtgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixItalicWords(
        pixs: *mut PIX,
        boxaw: *mut BOXA,
        pixw: *mut PIX,
        pboxa: *mut *mut BOXA,
        debugflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixOrientCorrect(
        pixs: *mut PIX,
        minupconf: l_float32,
        minratio: l_float32,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        protation: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOrientDetect(
        pixs: *mut PIX,
        pupconf: *mut l_float32,
        pleftconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makeOrientDecision(
        upconf: l_float32,
        leftconf: l_float32,
        minupconf: l_float32,
        minratio: l_float32,
        porient: *mut l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixUpDownDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        npixels: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMirrorDetect(
        pixs: *mut PIX,
        pconf: *mut l_float32,
        mincount: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen1(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fmorphautogen2(
        sela: *mut SELA,
        fileindex: l_int32,
        filename: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMorphDwa_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFMorphopGen_1(
        pixd: *mut PIX,
        pixs: *mut PIX,
        operation: l_int32,
        selname: *mut ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fmorphopgen_low_1(
        datad: *mut l_uint32,
        w: l_int32,
        h: l_int32,
        wpld: l_int32,
        datas: *mut l_uint32,
        wpls: l_int32,
        index: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn fpixCreate(width: l_int32, height: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCreateTemplate(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixClone(fpix: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixCopy(fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixDestroy(pfpix: *mut *mut FPIX);
}
extern "C" {
    pub fn fpixGetDimensions(fpix: *mut FPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixSetDimensions(fpix: *mut FPIX, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetWpl(fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixSetWpl(fpix: *mut FPIX, wpl: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetRefcount(fpix: *mut FPIX) -> l_int32;
}
extern "C" {
    pub fn fpixChangeRefcount(fpix: *mut FPIX, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixGetResolution(fpix: *mut FPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixSetResolution(fpix: *mut FPIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixCopyResolution(fpixd: *mut FPIX, fpixs: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixGetData(fpix: *mut FPIX) -> *mut l_float32;
}
extern "C" {
    pub fn fpixSetData(fpix: *mut FPIX, data: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixGetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixSetPixel(fpix: *mut FPIX, x: l_int32, y: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn fpixaCreate(n: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaCopy(fpixa: *mut FPIXA, copyflag: l_int32) -> *mut FPIXA;
}
extern "C" {
    pub fn fpixaDestroy(pfpixa: *mut *mut FPIXA);
}
extern "C" {
    pub fn fpixaAddFPix(fpixa: *mut FPIXA, fpix: *mut FPIX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixaGetCount(fpixa: *mut FPIXA) -> l_int32;
}
extern "C" {
    pub fn fpixaChangeRefcount(fpixa: *mut FPIXA, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn fpixaGetFPix(fpixa: *mut FPIXA, index: l_int32, accesstype: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixaGetFPixDimensions(
        fpixa: *mut FPIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaGetData(fpixa: *mut FPIXA, index: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn fpixaGetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixaSetPixel(
        fpixa: *mut FPIXA,
        index: l_int32,
        x: l_int32,
        y: l_int32,
        val: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixCreate(width: l_int32, height: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCreateTemplate(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixClone(dpix: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixCopy(dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixDestroy(pdpix: *mut *mut DPIX);
}
extern "C" {
    pub fn dpixGetDimensions(dpix: *mut DPIX, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixSetDimensions(dpix: *mut DPIX, w: l_int32, h: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetWpl(dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixSetWpl(dpix: *mut DPIX, wpl: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetRefcount(dpix: *mut DPIX) -> l_int32;
}
extern "C" {
    pub fn dpixChangeRefcount(dpix: *mut DPIX, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixGetResolution(dpix: *mut DPIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixSetResolution(dpix: *mut DPIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn dpixCopyResolution(dpixd: *mut DPIX, dpixs: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixGetData(dpix: *mut DPIX) -> *mut l_float64;
}
extern "C" {
    pub fn dpixSetData(dpix: *mut DPIX, data: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn dpixGetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, pval: *mut l_float64) -> l_ok;
}
extern "C" {
    pub fn dpixSetPixel(dpix: *mut DPIX, x: l_int32, y: l_int32, val: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixRead(filename: *const ::std::os::raw::c_char) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadStream(fp: *mut FILE) -> *mut FPIX;
}
extern "C" {
    pub fn fpixReadMem(data: *const l_uint8, size: size_t) -> *mut FPIX;
}
extern "C" {
    pub fn fpixWrite(filename: *const ::std::os::raw::c_char, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixWriteStream(fp: *mut FILE, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, fpix: *mut FPIX) -> l_ok;
}
extern "C" {
    pub fn fpixEndianByteSwap(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn dpixRead(filename: *const ::std::os::raw::c_char) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadStream(fp: *mut FILE) -> *mut DPIX;
}
extern "C" {
    pub fn dpixReadMem(data: *const l_uint8, size: size_t) -> *mut DPIX;
}
extern "C" {
    pub fn dpixWrite(filename: *const ::std::os::raw::c_char, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixWriteStream(fp: *mut FILE, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, dpix: *mut DPIX) -> l_ok;
}
extern "C" {
    pub fn dpixEndianByteSwap(dpixd: *mut DPIX, dpixs: *mut DPIX) -> *mut DPIX;
}
extern "C" {
    pub fn fpixPrintStream(fp: *mut FILE, fpix: *mut FPIX, factor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixConvertToFPix(pixs: *mut PIX, ncomps: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn pixConvertToDPix(pixs: *mut PIX, ncomps: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixConvertToPix(
        fpixs: *mut FPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixDisplayMaxDynamicRange(fpixs: *mut FPIX) -> *mut PIX;
}
extern "C" {
    pub fn fpixConvertToDPix(fpix: *mut FPIX) -> *mut DPIX;
}
extern "C" {
    pub fn dpixConvertToPix(
        dpixs: *mut DPIX,
        outdepth: l_int32,
        negvals: l_int32,
        errorflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn dpixConvertToFPix(dpix: *mut DPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixGetMin(
        fpix: *mut FPIX,
        pminval: *mut l_float32,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixGetMax(
        fpix: *mut FPIX,
        pmaxval: *mut l_float32,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixGetMin(
        dpix: *mut DPIX,
        pminval: *mut l_float64,
        pxminloc: *mut l_int32,
        pyminloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn dpixGetMax(
        dpix: *mut DPIX,
        pmaxval: *mut l_float64,
        pxmaxloc: *mut l_int32,
        pymaxloc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixScaleByInteger(fpixs: *mut FPIX, factor: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn dpixScaleByInteger(dpixs: *mut DPIX, factor: l_int32) -> *mut DPIX;
}
extern "C" {
    pub fn fpixLinearCombination(
        fpixd: *mut FPIX,
        fpixs1: *mut FPIX,
        fpixs2: *mut FPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMultConstant(fpix: *mut FPIX, addc: l_float32, multc: l_float32) -> l_ok;
}
extern "C" {
    pub fn dpixLinearCombination(
        dpixd: *mut DPIX,
        dpixs1: *mut DPIX,
        dpixs2: *mut DPIX,
        a: l_float32,
        b: l_float32,
    ) -> *mut DPIX;
}
extern "C" {
    pub fn dpixAddMultConstant(dpix: *mut DPIX, addc: l_float64, multc: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixSetAllArbitrary(fpix: *mut FPIX, inval: l_float32) -> l_ok;
}
extern "C" {
    pub fn dpixSetAllArbitrary(dpix: *mut DPIX, inval: l_float64) -> l_ok;
}
extern "C" {
    pub fn fpixAddBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRemoveBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddMirroredBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddContinuedBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAddSlopeBorder(
        fpixs: *mut FPIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRasterop(
        fpixd: *mut FPIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        fpixs: *mut FPIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixRotateOrth(fpixs: *mut FPIX, quads: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate180(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixRotate90(fpixs: *mut FPIX, direction: l_int32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipLR(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixFlipTB(fpixd: *mut FPIX, fpixs: *mut FPIX) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffinePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixAffine(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjectivePta(
        fpixs: *mut FPIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        border: l_int32,
        inval: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn fpixProjective(fpixs: *mut FPIX, vc: *mut l_float32, inval: l_float32) -> *mut FPIX;
}
extern "C" {
    pub fn linearInterpolatePixelFloat(
        datas: *mut l_float32,
        w: l_int32,
        h: l_int32,
        x: l_float32,
        y: l_float32,
        inval: l_float32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn fpixThresholdToPix(fpix: *mut FPIX, thresh: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixComponentFunction(
        pix: *mut PIX,
        rnum: l_float32,
        gnum: l_float32,
        bnum: l_float32,
        rdenom: l_float32,
        gdenom: l_float32,
        bdenom: l_float32,
    ) -> *mut FPIX;
}
extern "C" {
    pub fn pixReadStreamGif(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemGif(cdata: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteStreamGif(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemGif(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn gplotCreate(
        rootname: *const ::std::os::raw::c_char,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotDestroy(pgplot: *mut *mut GPLOT);
}
extern "C" {
    pub fn gplotAddPlot(
        gplot: *mut GPLOT,
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        plotlabel: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSetScaling(gplot: *mut GPLOT, scaling: l_int32) -> l_ok;
}
extern "C" {
    pub fn gplotMakeOutputPix(gplot: *mut GPLOT) -> *mut PIX;
}
extern "C" {
    pub fn gplotMakeOutput(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotGenCommandFile(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotGenDataFiles(gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn gplotSimple1(
        na: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimple2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimpleN(
        naa: *mut NUMAA,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn gplotSimplePix1(na: *mut NUMA, title: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimplePix2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        title: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimplePixN(naa: *mut NUMAA, title: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn gplotSimpleXY1(
        nax: *mut NUMA,
        nay: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotSimpleXY2(
        nax: *mut NUMA,
        nay1: *mut NUMA,
        nay2: *mut NUMA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotSimpleXYN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        outformat: l_int32,
        outroot: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
    ) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotGeneralPix1(
        na: *mut NUMA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotGeneralPix2(
        na1: *mut NUMA,
        na2: *mut NUMA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotGeneralPixN(
        nax: *mut NUMA,
        naay: *mut NUMAA,
        plotstyle: l_int32,
        rootname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        xlabel: *const ::std::os::raw::c_char,
        ylabel: *const ::std::os::raw::c_char,
    ) -> *mut PIX;
}
extern "C" {
    pub fn gplotRead(filename: *const ::std::os::raw::c_char) -> *mut GPLOT;
}
extern "C" {
    pub fn gplotWrite(filename: *const ::std::os::raw::c_char, gplot: *mut GPLOT) -> l_ok;
}
extern "C" {
    pub fn generatePtaLine(x1: l_int32, y1: l_int32, x2: l_int32, y2: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaWideLine(
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBox(box_: *mut BOX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaBoxa(boxa: *mut BOXA, width: l_int32, removedups: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBox(
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaaBoxa(boxa: *mut BOXA) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaaHashBoxa(
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn generatePtaPolyline(
        ptas: *mut PTA,
        width: l_int32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaGrid(
        w: l_int32,
        h: l_int32,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn convertPtaLineTo4cc(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledCircle(radius: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaFilledSquare(side: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn generatePtaLineFromPt(
        x: l_int32,
        y: l_int32,
        length: l_float64,
        radang: l_float64,
    ) -> *mut PTA;
}
extern "C" {
    pub fn locatePtRadially(
        xr: l_int32,
        yr: l_int32,
        dist: l_float64,
        radang: l_float64,
        px: *mut l_float64,
        py: *mut l_float64,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPlotFromNuma(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
        color: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePlotPtaFromNuma(
        na: *mut NUMA,
        size: l_int32,
        plotloc: l_int32,
        linewidth: l_int32,
        max: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPlotFromNumaGen(
        ppix: *mut *mut PIX,
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
        color: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePlotPtaFromNumaGen(
        na: *mut NUMA,
        orient: l_int32,
        linewidth: l_int32,
        refpos: l_int32,
        max: l_int32,
        drawref: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixRenderPta(pix: *mut PIX, pta: *mut PTA, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderPtaArb(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPtaBlend(
        pix: *mut PIX,
        pta: *mut PTA,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLineArb(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderLineBlend(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBox(pix: *mut PIX, box_: *mut BOX, width: l_int32, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxa(pix: *mut PIX, boxa: *mut BOXA, width: l_int32, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        removedups: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBox(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxArb(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxBlend(
        pix: *mut PIX,
        box_: *mut BOX,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashMaskArb(
        pix: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxa(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxaArb(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderHashBoxaBlend(
        pix: *mut PIX,
        boxa: *mut BOXA,
        spacing: l_int32,
        width: l_int32,
        orient: l_int32,
        outline: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        fract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolyline(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        op: l_int32,
        closeflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolylineArb(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        closeflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderPolylineBlend(
        pix: *mut PIX,
        ptas: *mut PTA,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
        fract: l_float32,
        closeflag: l_int32,
        removedups: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderGridArb(
        pix: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        width: l_int32,
        rval: l_uint8,
        gval: l_uint8,
        bval: l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRenderRandomCmapPtaa(
        pix: *mut PIX,
        ptaa: *mut PTAA,
        polyflag: l_int32,
        width: l_int32,
        closeflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderPolygon(
        ptas: *mut PTA,
        width: l_int32,
        pxmin: *mut l_int32,
        pymin: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFillPolygon(pixs: *mut PIX, pta: *mut PTA, xmin: l_int32, ymin: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRenderContours(
        pixs: *mut PIX,
        startval: l_int32,
        incr: l_int32,
        outdepth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn fpixAutoRenderContours(fpix: *mut FPIX, ncontours: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn fpixRenderContours(fpixs: *mut FPIX, incr: l_float32, proxim: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixGeneratePtaBoundary(pixs: *mut PIX, width: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn pixErodeGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGray3(pixs: *mut PIX, hsize: l_int32, vsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinary(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherToBinarySpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ditherToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        bufs1: *mut l_uint32,
        bufs2: *mut l_uint32,
        lowerclip: l_int32,
        upperclip: l_int32,
        lastlineflag: l_int32,
    );
}
extern "C" {
    pub fn pixThresholdToBinary(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn thresholdToBinaryLineLow(
        lined: *mut l_uint32,
        w: l_int32,
        lines: *mut l_uint32,
        d: l_int32,
        thresh: l_int32,
    );
}
extern "C" {
    pub fn pixVarThresholdToBinary(pixs: *mut PIX, pixg: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinary(pixs: *mut PIX, pixm: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixAdaptThresholdToBinaryGen(
        pixs: *mut PIX,
        pixm: *mut PIX,
        gamma: l_float32,
        blackval: l_int32,
        whiteval: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByValue(pixs: *mut PIX, val: l_int32, usecmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByBand(
        pixs: *mut PIX,
        lower: l_int32,
        upper: l_int32,
        inband: l_int32,
        usecmap: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bpp(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDitherTo2bppSpec(
        pixs: *mut PIX,
        lowerclip: l_int32,
        upperclip: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo2bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdTo4bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdOn8bpp(pixs: *mut PIX, nlevels: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdGrayArb(
        pixs: *mut PIX,
        edgevals: *const ::std::os::raw::c_char,
        outdepth: l_int32,
        use_average: l_int32,
        setblack: l_int32,
        setwhite: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn makeGrayQuantIndexTable(nlevels: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn makeGrayQuantTableArb(
        na: *mut NUMA,
        outdepth: l_int32,
        ptab: *mut *mut l_int32,
        pcmap: *mut *mut PIXCMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenerateMaskByBand32(
        pixs: *mut PIX,
        refval: l_uint32,
        delm: l_int32,
        delp: l_int32,
        fractm: l_float32,
        fractp: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateMaskByDiscr32(
        pixs: *mut PIX,
        refval1: l_uint32,
        refval2: l_uint32,
        distflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromHisto(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        minfract: l_float32,
        maxsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGrayQuantFromCmap(pixs: *mut PIX, cmap: *mut PIXCMAP, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn l_hmapCreate(ninit: l_int32, maxocc: l_int32) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn l_hmapDestroy(phmap: *mut *mut L_HASHMAP);
}
extern "C" {
    pub fn l_hmapLookup(
        hmap: *mut L_HASHMAP,
        key: l_uint64,
        val: l_uint64,
        op: l_int32,
    ) -> *mut L_HASHITEM;
}
extern "C" {
    pub fn l_hmapRehash(hmap: *mut L_HASHMAP) -> l_ok;
}
extern "C" {
    pub fn lheapCreate(n: l_int32, direction: l_int32) -> *mut L_HEAP;
}
extern "C" {
    pub fn lheapDestroy(plh: *mut *mut L_HEAP, freeflag: l_int32);
}
extern "C" {
    pub fn lheapAdd(lh: *mut L_HEAP, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lheapRemove(lh: *mut L_HEAP) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapGetCount(lh: *mut L_HEAP) -> l_int32;
}
extern "C" {
    pub fn lheapGetElement(lh: *mut L_HEAP, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lheapSort(lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn lheapSortStrictOrder(lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn lheapPrint(fp: *mut FILE, lh: *mut L_HEAP) -> l_ok;
}
extern "C" {
    pub fn jbRankHausInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        size: l_int32,
        rank: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInit(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbCorrelationInitWithoutComponents(
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        thresh: l_float32,
        weightfactor: l_float32,
    ) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbAddPages(classer: *mut JBCLASSER, safiles: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn jbAddPage(classer: *mut JBCLASSER, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn jbAddPageComponents(
        classer: *mut JBCLASSER,
        pixs: *mut PIX,
        boxas: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbClassifyRankHaus(classer: *mut JBCLASSER, boxa: *mut BOXA, pixas: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixRankHaustest(
        pix1: *mut PIX,
        pix2: *mut PIX,
        pix3: *mut PIX,
        pix4: *mut PIX,
        delx: l_float32,
        dely: l_float32,
        maxdiffw: l_int32,
        maxdiffh: l_int32,
        area1: l_int32,
        area3: l_int32,
        rank: l_float32,
        tab8: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn jbClassifyCorrelation(
        classer: *mut JBCLASSER,
        boxa: *mut BOXA,
        pixas: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbGetComponents(
        pixs: *mut PIX,
        components: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxad: *mut *mut BOXA,
        ppixad: *mut *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWordMaskByDilation(
        pixs: *mut PIX,
        ppixm: *mut *mut PIX,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWordBoxesByDilation(
        pixs: *mut PIX,
        minwidth: l_int32,
        minheight: l_int32,
        maxwidth: l_int32,
        maxheight: l_int32,
        pboxa: *mut *mut BOXA,
        psize: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn jbAccumulateComposites(
        pixaa: *mut PIXAA,
        pna: *mut *mut NUMA,
        pptat: *mut *mut PTA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn jbTemplatesFromComposites(pixac: *mut PIXA, na: *mut NUMA) -> *mut PIXA;
}
extern "C" {
    pub fn jbClasserCreate(method: l_int32, components: l_int32) -> *mut JBCLASSER;
}
extern "C" {
    pub fn jbClasserDestroy(pclasser: *mut *mut JBCLASSER);
}
extern "C" {
    pub fn jbDataSave(classer: *mut JBCLASSER) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataDestroy(pdata: *mut *mut JBDATA);
}
extern "C" {
    pub fn jbDataWrite(rootout: *const ::std::os::raw::c_char, jbdata: *mut JBDATA) -> l_ok;
}
extern "C" {
    pub fn jbDataRead(rootname: *const ::std::os::raw::c_char) -> *mut JBDATA;
}
extern "C" {
    pub fn jbDataRender(data: *mut JBDATA, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn jbGetULCorners(classer: *mut JBCLASSER, pixs: *mut PIX, boxa: *mut BOXA) -> l_ok;
}
extern "C" {
    pub fn jbGetLLCorners(classer: *mut JBCLASSER) -> l_ok;
}
extern "C" {
    pub fn readHeaderJp2k(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderJp2k(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemJp2k(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pcodec: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetJp2kResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixReadJp2k(
        filename: *const ::std::os::raw::c_char,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJp2k(
        fp: *mut FILE,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteJp2k(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamJp2k(
        fp: *mut FILE,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        codec: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemJp2k(
        data: *const l_uint8,
        size: size_t,
        reduction: l_uint32,
        box_: *mut BOX,
        hint: l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemJp2k(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        quality: l_int32,
        nlevels: l_int32,
        hint: l_int32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadJpeg(
        filename: *const ::std::os::raw::c_char,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamJpeg(
        fp: *mut FILE,
        cmapflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderJpeg(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderJpeg(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetJpegResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn fgetJpegComment(fp: *mut FILE, pcomment: *mut *mut l_uint8) -> l_int32;
}
extern "C" {
    pub fn pixWriteJpeg(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamJpeg(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemJpeg(
        data: *const l_uint8,
        size: size_t,
        cmflag: l_int32,
        reduction: l_int32,
        pnwarn: *mut l_int32,
        hint: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemJpeg(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
        pycck: *mut l_int32,
        pcmyk: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readResolutionMemJpeg(
        data: *const l_uint8,
        size: size_t,
        pxres: *mut l_int32,
        pyres: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemJpeg(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetChromaSampling(pix: *mut PIX, sampling: l_int32) -> l_ok;
}
extern "C" {
    pub fn kernelCreate(height: l_int32, width: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDestroy(pkel: *mut *mut L_KERNEL);
}
extern "C" {
    pub fn kernelCopy(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelGetElement(
        kel: *mut L_KERNEL,
        row: l_int32,
        col: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn kernelSetElement(kel: *mut L_KERNEL, row: l_int32, col: l_int32, val: l_float32)
        -> l_ok;
}
extern "C" {
    pub fn kernelGetParameters(
        kel: *mut L_KERNEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn kernelSetOrigin(kel: *mut L_KERNEL, cy: l_int32, cx: l_int32) -> l_ok;
}
extern "C" {
    pub fn kernelGetSum(kel: *mut L_KERNEL, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn kernelGetMinMax(kel: *mut L_KERNEL, pmin: *mut l_float32, pmax: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn kernelNormalize(kels: *mut L_KERNEL, normsum: l_float32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelInvert(kels: *mut L_KERNEL) -> *mut L_KERNEL;
}
extern "C" {
    pub fn create2dFloatArray(sy: l_int32, sx: l_int32) -> *mut *mut l_float32;
}
extern "C" {
    pub fn kernelRead(fname: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelReadStream(fp: *mut FILE) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelWrite(fname: *const ::std::os::raw::c_char, kel: *mut L_KERNEL) -> l_ok;
}
extern "C" {
    pub fn kernelWriteStream(fp: *mut FILE, kel: *mut L_KERNEL) -> l_ok;
}
extern "C" {
    pub fn kernelCreateFromString(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        kdata: *const ::std::os::raw::c_char,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelCreateFromPix(pix: *mut PIX, cy: l_int32, cx: l_int32) -> *mut L_KERNEL;
}
extern "C" {
    pub fn kernelDisplayInPix(kel: *mut L_KERNEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn parseStringForNumbers(
        str_: *const ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn makeFlatKernel(
        height: l_int32,
        width: l_int32,
        cy: l_int32,
        cx: l_int32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernel(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        max: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn makeGaussianKernelSep(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        max: l_float32,
        pkelx: *mut *mut L_KERNEL,
        pkely: *mut *mut L_KERNEL,
    ) -> l_ok;
}
extern "C" {
    pub fn makeDoGKernel(
        halfh: l_int32,
        halfw: l_int32,
        stdev: l_float32,
        ratio: l_float32,
    ) -> *mut L_KERNEL;
}
extern "C" {
    pub fn getImagelibVersions() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn listDestroy(phead: *mut *mut DLLIST);
}
extern "C" {
    pub fn listAddToHead(phead: *mut *mut DLLIST, data: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn listAddToTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listInsertBefore(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listInsertAfter(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
        data: *mut ::std::os::raw::c_void,
    ) -> l_ok;
}
extern "C" {
    pub fn listRemoveElement(
        phead: *mut *mut DLLIST,
        elem: *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromHead(phead: *mut *mut DLLIST) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listRemoveFromTail(
        phead: *mut *mut DLLIST,
        ptail: *mut *mut DLLIST,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn listFindElement(head: *mut DLLIST, data: *mut ::std::os::raw::c_void) -> *mut DLLIST;
}
extern "C" {
    pub fn listFindTail(head: *mut DLLIST) -> *mut DLLIST;
}
extern "C" {
    pub fn listGetCount(head: *mut DLLIST) -> l_int32;
}
extern "C" {
    pub fn listReverse(phead: *mut *mut DLLIST) -> l_ok;
}
extern "C" {
    pub fn listJoin(phead1: *mut *mut DLLIST, phead2: *mut *mut DLLIST) -> l_ok;
}
extern "C" {
    pub fn l_amapCreate(keytype: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn l_amapFind(m: *mut L_AMAP, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_amapInsert(m: *mut L_AMAP, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_amapDelete(m: *mut L_AMAP, key: RB_TYPE);
}
extern "C" {
    pub fn l_amapDestroy(pm: *mut *mut L_AMAP);
}
extern "C" {
    pub fn l_amapGetFirst(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetNext(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetLast(m: *mut L_AMAP) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapGetPrev(n: *mut L_AMAP_NODE) -> *mut L_AMAP_NODE;
}
extern "C" {
    pub fn l_amapSize(m: *mut L_AMAP) -> l_int32;
}
extern "C" {
    pub fn l_asetCreate(keytype: l_int32) -> *mut L_ASET;
}
extern "C" {
    pub fn l_asetFind(s: *mut L_ASET, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_asetInsert(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDelete(s: *mut L_ASET, key: RB_TYPE);
}
extern "C" {
    pub fn l_asetDestroy(ps: *mut *mut L_ASET);
}
extern "C" {
    pub fn l_asetGetFirst(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetNext(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetLast(s: *mut L_ASET) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetGetPrev(n: *mut L_ASET_NODE) -> *mut L_ASET_NODE;
}
extern "C" {
    pub fn l_asetSize(s: *mut L_ASET) -> l_int32;
}
extern "C" {
    pub fn generateBinaryMaze(
        w: l_int32,
        h: l_int32,
        xi: l_int32,
        yi: l_int32,
        wallps: l_float32,
        ranis: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSearchBinaryMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixSearchGrayMaze(
        pixs: *mut PIX,
        xi: l_int32,
        yi: l_int32,
        xf: l_int32,
        yf: l_int32,
        ppixd: *mut *mut PIX,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDilate(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixErode(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixHMT(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpen(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixClose(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafe(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseGeneralized(pixd: *mut PIX, pixs: *mut PIX, sel: *mut SEL) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrick(pixd: *mut PIX, pixs: *mut PIX, hsize: l_int32, vsize: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selectComposableSels(
        size: l_int32,
        direction: l_int32,
        psel1: *mut *mut SEL,
        psel2: *mut *mut SEL,
    ) -> l_int32;
}
extern "C" {
    pub fn selectComposableSizes(
        size: l_int32,
        pfactor1: *mut l_int32,
        pfactor2: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDilateCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseSafeCompBrick(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn resetMorphBoundaryCondition(bc: l_int32);
}
extern "C" {
    pub fn getMorphBorderPixelColor(type_: l_int32, depth: l_int32) -> l_uint32;
}
extern "C" {
    pub fn pixExtractBoundary(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceByComponent(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByComponent(
        pixas: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixMorphSequenceByRegion(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaMorphSequenceByRegion(
        pixs: *mut PIX,
        pixam: *mut PIXA,
        sequence: *const ::std::os::raw::c_char,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixUnionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixIntersectionOfMorphOps(pixs: *mut PIX, sela: *mut SELA, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectiveConnCompFill(
        pixs: *mut PIX,
        connectivity: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        dsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayMatchedPattern(
        pixs: *mut PIX,
        pixp: *mut PIX,
        pixe: *mut PIX,
        x0: l_int32,
        y0: l_int32,
        color: l_uint32,
        scale: l_float32,
        nlevels: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtendByMorph(
        pixas: *mut PIXA,
        type_: l_int32,
        niters: l_int32,
        sel: *mut SEL,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaExtendByScaling(
        pixas: *mut PIXA,
        nasc: *mut NUMA,
        type_: l_int32,
        include: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSeedfillMorph(
        pixs: *mut PIX,
        pixm: *mut PIX,
        maxiters: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunHistogramMorph(
        pixs: *mut PIX,
        runtype: l_int32,
        direction: l_int32,
        maxsize: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixTophat(pixs: *mut PIX, hsize: l_int32, vsize: l_int32, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixHDome(pixs: *mut PIX, height: l_int32, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFastTophat(
        pixs: *mut PIX,
        xsize: l_int32,
        ysize: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphGradient(
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
        smoothing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaCentroids(pixa: *mut PIXA) -> *mut PTA;
}
extern "C" {
    pub fn pixCentroid(
        pix: *mut PIX,
        centtab: *mut l_int32,
        sumtab: *mut l_int32,
        pxave: *mut l_float32,
        pyave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDilateBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDilateCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixErodeCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixOpenCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCloseCompBrickExtendDwa(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getExtendedCompositeParameters(
        size: l_int32,
        pn: *mut l_int32,
        pextra: *mut l_int32,
        pactualsize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMorphCompSequenceDwa(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn morphSequenceVerify(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn pixGrayMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixColorMorphSequence(
        pixs: *mut PIX,
        sequence: *const ::std::os::raw::c_char,
        dispsep: l_int32,
        dispy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn numaCreate(n: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromIArray(iarray: *mut l_int32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromFArray(
        farray: *mut l_float32,
        size: l_int32,
        copyflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaCreateFromString(str_: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaDestroy(pna: *mut *mut NUMA);
}
extern "C" {
    pub fn numaCopy(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaClone(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaEmpty(na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaAddNumber(na: *mut NUMA, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaInsertNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaRemoveNumber(na: *mut NUMA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaReplaceNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetCount(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSetCount(na: *mut NUMA, newcount: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetFValue(na: *mut NUMA, index: l_int32, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetIValue(na: *mut NUMA, index: l_int32, pival: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaSetValue(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaShiftValue(na: *mut NUMA, index: l_int32, diff: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetIArray(na: *mut NUMA) -> *mut l_int32;
}
extern "C" {
    pub fn numaGetFArray(na: *mut NUMA, copyflag: l_int32) -> *mut l_float32;
}
extern "C" {
    pub fn numaGetRefcount(na: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaChangeRefcount(na: *mut NUMA, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetParameters(na: *mut NUMA, pstartx: *mut l_float32, pdelx: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn numaSetParameters(na: *mut NUMA, startx: l_float32, delx: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaCopyParameters(nad: *mut NUMA, nas: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaConvertToSarray(
        na: *mut NUMA,
        size1: l_int32,
        size2: l_int32,
        addzeros: l_int32,
        type_: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn numaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadStream(fp: *mut FILE) -> *mut NUMA;
}
extern "C" {
    pub fn numaReadMem(data: *const l_uint8, size: size_t) -> *mut NUMA;
}
extern "C" {
    pub fn numaWriteDebug(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWrite(filename: *const ::std::os::raw::c_char, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteStream(fp: *mut FILE, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteStderr(na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaaCreate(n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaCreateFull(nptr: l_int32, n: l_int32) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaTruncate(naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaDestroy(pnaa: *mut *mut NUMAA);
}
extern "C" {
    pub fn numaaAddNuma(naa: *mut NUMAA, na: *mut NUMA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaGetCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumaCount(naa: *mut NUMAA, index: l_int32) -> l_int32;
}
extern "C" {
    pub fn numaaGetNumberCount(naa: *mut NUMAA) -> l_int32;
}
extern "C" {
    pub fn numaaGetPtrArray(naa: *mut NUMAA) -> *mut *mut NUMA;
}
extern "C" {
    pub fn numaaGetNuma(naa: *mut NUMAA, index: l_int32, accessflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaaReplaceNuma(naa: *mut NUMAA, index: l_int32, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaaGetValue(
        naa: *mut NUMAA,
        i: l_int32,
        j: l_int32,
        pfval: *mut l_float32,
        pival: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaaAddNumber(naa: *mut NUMAA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaaRead(filename: *const ::std::os::raw::c_char) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadStream(fp: *mut FILE) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaReadMem(data: *const l_uint8, size: size_t) -> *mut NUMAA;
}
extern "C" {
    pub fn numaaWrite(filename: *const ::std::os::raw::c_char, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaWriteStream(fp: *mut FILE, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, naa: *mut NUMAA) -> l_ok;
}
extern "C" {
    pub fn numaArithOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaLogicalOp(nad: *mut NUMA, na1: *mut NUMA, na2: *mut NUMA, op: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaInvert(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimilar(
        na1: *mut NUMA,
        na2: *mut NUMA,
        maxdiff: l_float32,
        psimilar: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaAddToNumber(na: *mut NUMA, index: l_int32, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMin(na: *mut NUMA, pminval: *mut l_float32, piminloc: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMax(na: *mut NUMA, pmaxval: *mut l_float32, pimaxloc: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetSum(na: *mut NUMA, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetPartialSums(na: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSumOnInterval(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        psum: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHasOnlyIntegers(na: *mut NUMA, pallints: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMean(na: *mut NUMA, pave: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMeanAbsval(na: *mut NUMA, paveabs: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaSubsample(nas: *mut NUMA, subfactor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeDelta(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeSequence(startval: l_float32, increment: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeConstant(val: l_float32, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeAbsval(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        val: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSpecifiedBorder(
        nas: *mut NUMA,
        left: l_int32,
        right: l_int32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRemoveBorder(nas: *mut NUMA, left: l_int32, right: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaCountNonzeroRuns(na: *mut NUMA, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetNonzeroRange(
        na: *mut NUMA,
        eps: l_float32,
        pfirst: *mut l_int32,
        plast: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetCountRelativeToZero(na: *mut NUMA, type_: l_int32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaClipToInterval(nas: *mut NUMA, first: l_int32, last: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeThresholdIndicator(
        nas: *mut NUMA,
        thresh: l_float32,
        type_: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaUniformSampling(nas: *mut NUMA, nsamp: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaReverse(nad: *mut NUMA, nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaLowPassIntervals(nas: *mut NUMA, thresh: l_float32, maxn: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaThresholdEdges(
        nas: *mut NUMA,
        thresh1: l_float32,
        thresh2: l_float32,
        maxn: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSpanValues(
        na: *mut NUMA,
        span: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaGetEdgeValues(
        na: *mut NUMA,
        edge: l_int32,
        pstart: *mut l_int32,
        pend: *mut l_int32,
        psign: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn numaInterpolateEqxVal(
        startx: l_float32,
        deltax: l_float32,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateArbxVal(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        xval: l_float32,
        pyval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateEqxInterval(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInterpolateArbxInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        type_: l_int32,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaFitMax(
        na: *mut NUMA,
        pmaxval: *mut l_float32,
        naloc: *mut NUMA,
        pmaxloc: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDifferentiateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        pnadx: *mut *mut NUMA,
        pnady: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaIntegrateInterval(
        nax: *mut NUMA,
        nay: *mut NUMA,
        x0: l_float32,
        x1: l_float32,
        npts: l_int32,
        psum: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSortGeneral(
        na: *mut NUMA,
        pnasort: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        pnainvert: *mut *mut NUMA,
        sortorder: l_int32,
        sorttype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSortAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortIndexAutoSelect(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaChooseSortType(nas: *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn numaSort(naout: *mut NUMA, nain: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaBinSort(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetSortIndex(na: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetBinSortIndex(nas: *mut NUMA, sortorder: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSortByIndex(nas: *mut NUMA, naindex: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaIsSorted(nas: *mut NUMA, sortorder: l_int32, psorted: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn numaSortPair(
        nax: *mut NUMA,
        nay: *mut NUMA,
        sortorder: l_int32,
        pnasx: *mut *mut NUMA,
        pnasy: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaInvertMap(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaAddSorted(na: *mut NUMA, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn numaFindSortedLoc(na: *mut NUMA, val: l_float32, pindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaPseudorandomSequence(size: l_int32, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaRandomPermutation(nas: *mut NUMA, seed: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetRankValue(
        na: *mut NUMA,
        fract: l_float32,
        nasort: *mut NUMA,
        usebins: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetMedian(na: *mut NUMA, pval: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetBinnedMedian(na: *mut NUMA, pval: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaGetMeanDevFromMedian(na: *mut NUMA, med: l_float32, pdev: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn numaGetMedianDevFromMedian(
        na: *mut NUMA,
        pmed: *mut l_float32,
        pdev: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetMode(na: *mut NUMA, pval: *mut l_float32, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn numaJoin(nad: *mut NUMA, nas: *mut NUMA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaJoin(naad: *mut NUMAA, naas: *mut NUMAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn numaaFlattenToNuma(naa: *mut NUMAA) -> *mut NUMA;
}
extern "C" {
    pub fn numaErode(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaDilate(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaOpen(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaClose(nas: *mut NUMA, size: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaTransform(nas: *mut NUMA, shift: l_float32, scale: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSimpleStats(
        na: *mut NUMA,
        first: l_int32,
        last: l_int32,
        pmean: *mut l_float32,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedStats(
        nas: *mut NUMA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedMean(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedMeanSquare(nas: *mut NUMA, wc: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaWindowedVariance(
        nam: *mut NUMA,
        nams: *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaWindowedMedian(nas: *mut NUMA, halfwin: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaConvertToInt(nas: *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pbinsize: *mut l_int32,
        pbinstart: *mut l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramAuto(na: *mut NUMA, maxbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaMakeHistogramClipped(
        na: *mut NUMA,
        binsize: l_float32,
        maxsize: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaRebinHistogram(nas: *mut NUMA, newsize: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaNormalizeHistogram(nas: *mut NUMA, tsum: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaGetStatsUsingHistogram(
        na: *mut NUMA,
        maxbins: l_int32,
        pmin: *mut l_float32,
        pmax: *mut l_float32,
        pmean: *mut l_float32,
        pvariance: *mut l_float32,
        pmedian: *mut l_float32,
        rank: l_float32,
        prval: *mut l_float32,
        phisto: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetHistogramStats(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetHistogramStatsOnInterval(
        nahisto: *mut NUMA,
        startx: l_float32,
        deltax: l_float32,
        ifirst: l_int32,
        ilast: l_int32,
        pxmean: *mut l_float32,
        pxmedian: *mut l_float32,
        pxmode: *mut l_float32,
        pxvariance: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaMakeRankFromHistogram(
        startx: l_float32,
        deltax: l_float32,
        nasy: *mut NUMA,
        npts: l_int32,
        pnax: *mut *mut NUMA,
        pnay: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHistogramGetRankFromVal(
        na: *mut NUMA,
        rval: l_float32,
        prank: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaHistogramGetValFromRank(
        na: *mut NUMA,
        rank: l_float32,
        prval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDiscretizeSortedInBins(
        na: *mut NUMA,
        nbins: l_int32,
        pnabinval: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaDiscretizeHistoInBins(
        na: *mut NUMA,
        nbins: l_int32,
        pnabinval: *mut *mut NUMA,
        pnarank: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaGetRankBinValues(na: *mut NUMA, nbins: l_int32, pnam: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaGetUniformBinSizes(ntotal: l_int32, nbins: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn numaSplitDistribution(
        na: *mut NUMA,
        scorefract: l_float32,
        psplitindex: *mut l_int32,
        pave1: *mut l_float32,
        pave2: *mut l_float32,
        pnum1: *mut l_float32,
        pnum2: *mut l_float32,
        pnascore: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn grayHistogramsToEMD(naa1: *mut NUMAA, naa2: *mut NUMAA, pnad: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn numaEarthMoverDistance(na1: *mut NUMA, na2: *mut NUMA, pdist: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn grayInterHistogramStats(
        naa: *mut NUMAA,
        wc: l_int32,
        pnam: *mut *mut NUMA,
        pnams: *mut *mut NUMA,
        pnav: *mut *mut NUMA,
        pnarv: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn numaFindPeaks(
        nas: *mut NUMA,
        nmax: l_int32,
        fract1: l_float32,
        fract2: l_float32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindExtrema(nas: *mut NUMA, delta: l_float32, pnav: *mut *mut NUMA) -> *mut NUMA;
}
extern "C" {
    pub fn numaFindLocForThreshold(
        na: *mut NUMA,
        skip: l_int32,
        pthresh: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaCountReversals(
        nas: *mut NUMA,
        minreversal: l_float32,
        pnr: *mut l_int32,
        prd: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaSelectCrossingThreshold(
        nax: *mut NUMA,
        nay: *mut NUMA,
        estthresh: l_float32,
        pbestthresh: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaCrossingsByThreshold(nax: *mut NUMA, nay: *mut NUMA, thresh: l_float32)
        -> *mut NUMA;
}
extern "C" {
    pub fn numaCrossingsByPeaks(nax: *mut NUMA, nay: *mut NUMA, delta: l_float32) -> *mut NUMA;
}
extern "C" {
    pub fn numaEvalBestHaarParameters(
        nas: *mut NUMA,
        relweight: l_float32,
        nwidth: l_int32,
        nshift: l_int32,
        minwidth: l_float32,
        maxwidth: l_float32,
        pbestwidth: *mut l_float32,
        pbestshift: *mut l_float32,
        pbestscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn numaEvalHaarSum(
        nas: *mut NUMA,
        width: l_float32,
        shift: l_float32,
        relweight: l_float32,
        pscore: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn genConstrainedNumaInRange(
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRegionsBinary(
        pixs: *mut PIX,
        ppixhm: *mut *mut PIX,
        ppixtm: *mut *mut PIX,
        ppixtb: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGenHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        debug: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenerateHalftoneMask(
        pixs: *mut PIX,
        ppixtext: *mut *mut PIX,
        phtfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextlineMask(
        pixs: *mut PIX,
        ppixvws: *mut *mut PIX,
        ptlfound: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixGenTextblockMask(pixs: *mut PIX, pixvws: *mut PIX, pixadb: *mut PIXA) -> *mut PIX;
}
extern "C" {
    pub fn pixFindPageForeground(
        pixs: *mut PIX,
        threshold: l_int32,
        mindist: l_int32,
        erasedist: l_int32,
        showmorph: l_int32,
        pixac: *mut PIXAC,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixSplitIntoCharacters(
        pixs: *mut PIX,
        minw: l_int32,
        minh: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdebug: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSplitComponentWithProfile(
        pixs: *mut PIX,
        delta: l_int32,
        mindel: l_int32,
        ppixdebug: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixExtractTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        minw: l_int32,
        minh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixExtractRawTextlines(
        pixs: *mut PIX,
        maxw: l_int32,
        maxh: l_int32,
        adjw: l_int32,
        adjh: l_int32,
        pixadb: *mut PIXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixCountTextColumns(
        pixs: *mut PIX,
        deltafract: l_float32,
        peakfract: l_float32,
        clipfract: l_float32,
        pncols: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfText(
        pixs: *mut PIX,
        box_: *mut BOX,
        pistext: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindThreshFgExtent(
        pixs: *mut PIX,
        thresh: l_int32,
        ptop: *mut l_int32,
        pbot: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDecideIfTable(
        pixs: *mut PIX,
        box_: *mut BOX,
        orient: l_int32,
        pscore: *mut l_int32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPrepare1bpp(
        pixs: *mut PIX,
        box_: *mut BOX,
        cropfract: l_float32,
        outres: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEstimateBackground(
        pixs: *mut PIX,
        darkthresh: l_int32,
        edgecrop: l_float32,
        pbg: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindLargeRectangles(
        pixs: *mut PIX,
        polarity: l_int32,
        nrect: l_int32,
        pboxa: *mut *mut BOXA,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindLargestRectangle(
        pixs: *mut PIX,
        polarity: l_int32,
        pbox: *mut *mut BOX,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindRectangleInCC(
        pixs: *mut PIX,
        boxs: *mut BOX,
        fract: l_float32,
        dir: l_int32,
        select: l_int32,
        debug: l_int32,
    ) -> *mut BOX;
}
extern "C" {
    pub fn pixAutoPhotoinvert(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixm: *mut *mut PIX,
        pixadb: *mut PIXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetSelectCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayRegionsCmap(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayCmap(
        pixs: *mut PIX,
        box_: *mut BOX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixColorGrayMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn addColorizedGrayToCmap(
        cmap: *mut PIXCMAP,
        type_: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        pna: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetSelectMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        sindex: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetMaskedCmap(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn parseForProtos(
        filein: *const ::std::os::raw::c_char,
        prestring: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn partifyFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nparts: l_int32,
        outroot: *const ::std::os::raw::c_char,
        debugfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn partifyPixac(
        pixac: *mut PIXAC,
        nparts: l_int32,
        outroot: *const ::std::os::raw::c_char,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaGetWhiteblocks(
        boxas: *mut BOXA,
        box_: *mut BOX,
        sortflag: l_int32,
        maxboxes: l_int32,
        maxoverlap: l_float32,
        maxperim: l_int32,
        fract: l_float32,
        maxpops: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn boxaPruneSortedOnOverlap(boxas: *mut BOXA, maxoverlap: l_float32) -> *mut BOXA;
}
extern "C" {
    pub fn convertFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertFilesToPdf(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertFilesToPdfData(
        sa: *mut SARRAY,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn selectDefaultPdfEncoding(pix: *mut PIX, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn convertUnscaledFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdf(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConvertUnscaledFilesToPdfData(
        sa: *mut SARRAY,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertUnscaledToPdfData(
        fname: *const ::std::os::raw::c_char,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToPdf(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToPdfData(
        pixa: *mut PIXA,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdf(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertImageDataToPdf(
        imdata: *mut l_uint8,
        size: size_t,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdfData(
        filein: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertImageDataToPdfData(
        imdata: *mut l_uint8,
        size: size_t,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdf(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        fileout: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPdf(
        fp: *mut FILE,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPdf(
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        pix: *mut PIX,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertSegmentedFilesToPdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        baa: *mut BOXAA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertNumberedMasksToBoxaa(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> *mut BOXAA;
}
extern "C" {
    pub fn convertToPdfSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPdfDataSegmented(
        filein: *const ::std::os::raw::c_char,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfDataSegmented(
        pixs: *mut PIX,
        res: l_int32,
        type_: l_int32,
        thresh: l_int32,
        boxa: *mut BOXA,
        quality: l_int32,
        scalefactor: l_float32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn concatenatePdf(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn saConcatenatePdf(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn ptraConcatenatePdf(pa: *mut L_PTRA, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn concatenatePdfToData(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn saConcatenatePdfToData(
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvertToPdfData(
        pix: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        title: *const ::std::os::raw::c_char,
        plpd: *mut *mut L_PDF_DATA,
        position: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptraConcatenatePdfToData(
        pa_data: *mut L_PTRA,
        sa: *mut SARRAY,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn convertTiffMultipageToPdf(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateCIDataForPdf(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateCIData(
        fname: *const ::std::os::raw::c_char,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateFlateDataPdf(
        fname: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateJpegDataMem(
        data: *mut l_uint8,
        nbytes: size_t,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn l_generateG4Data(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn pixGenerateCIData(
        pixs: *mut PIX,
        type_: l_int32,
        quality: l_int32,
        ascii85: l_int32,
        pcid: *mut *mut L_COMP_DATA,
    ) -> l_ok;
}
extern "C" {
    pub fn l_generateFlateData(
        fname: *const ::std::os::raw::c_char,
        ascii85flag: l_int32,
    ) -> *mut L_COMP_DATA;
}
extern "C" {
    pub fn cidConvertToPdfData(
        cid: *mut L_COMP_DATA,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn l_CIDataDestroy(pcid: *mut *mut L_COMP_DATA);
}
extern "C" {
    pub fn l_pdfSetG4ImageMask(flag: l_int32);
}
extern "C" {
    pub fn l_pdfSetDateAndVersion(flag: l_int32);
}
extern "C" {
    pub fn setPixMemoryManager(allocator: alloc_fn, deallocator: dealloc_fn);
}
extern "C" {
    pub fn pixCreate(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateNoInit(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplate(pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateTemplateNoInit(pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateWithCmap(
        width: l_int32,
        height: l_int32,
        depth: l_int32,
        initcolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateHeader(width: l_int32, height: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixClone(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixDestroy(ppix: *mut *mut PIX);
}
extern "C" {
    pub fn pixCopy(pixd: *mut PIX, pixs: *const PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeImageData(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixCopyColormap(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixTransferAllData(
        pixd: *mut PIX,
        ppixs: *mut *mut PIX,
        copytext: l_int32,
        copyformat: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSwapAndDestroy(ppixd: *mut *mut PIX, ppixs: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetWidth(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWidth(pix: *mut PIX, width: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetHeight(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetHeight(pix: *mut PIX, height: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDepth(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetDepth(pix: *mut PIX, depth: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetDimensions(
        pix: *const PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetDimensions(pix: *mut PIX, w: l_int32, h: l_int32, d: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCopyDimensions(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetSpp(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpp(pix: *mut PIX, spp: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopySpp(pixd: *mut PIX, pixs: *const PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetWpl(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetWpl(pix: *mut PIX, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRefcount(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixChangeRefcount(pix: *mut PIX, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetXRes(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetXRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetYRes(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetYRes(pix: *mut PIX, res: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetResolution(pix: *const PIX, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetResolution(pix: *mut PIX, xres: l_int32, yres: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCopyResolution(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixScaleResolution(pix: *mut PIX, xscale: l_float32, yscale: l_float32) -> l_int32;
}
extern "C" {
    pub fn pixGetInputFormat(pix: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetInputFormat(pix: *mut PIX, informat: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixCopyInputFormat(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixSetSpecial(pix: *mut PIX, special: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetText(pix: *mut PIX) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixSetText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixAddText(pix: *mut PIX, textstring: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixCopyText(pixd: *mut PIX, pixs: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetTextCompNew(pix: *mut PIX, psize: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn pixSetTextCompNew(pix: *mut PIX, data: *const l_uint8, size: size_t) -> l_ok;
}
extern "C" {
    pub fn pixGetColormap(pix: *mut PIX) -> *mut PIXCMAP;
}
extern "C" {
    pub fn pixSetColormap(pix: *mut PIX, colormap: *mut PIXCMAP) -> l_ok;
}
extern "C" {
    pub fn pixDestroyColormap(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetData(pix: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixSetData(pix: *mut PIX, data: *mut l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixExtractData(pixs: *mut PIX) -> *mut l_uint32;
}
extern "C" {
    pub fn pixFreeData(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn pixGetLinePtrs(pix: *mut PIX, psize: *mut l_int32) -> *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixSizesEqual(pix1: *const PIX, pix2: *const PIX) -> l_int32;
}
extern "C" {
    pub fn pixMaxAspectRatio(pixs: *mut PIX, pratio: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixPrintStreamInfo(
        fp: *mut FILE,
        pix: *const PIX,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixel(pix: *mut PIX, x: l_int32, y: l_int32, pval: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetPixel(pix: *mut PIX, x: l_int32, y: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixGetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetRGBPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetCmapPixel(
        pix: *mut PIX,
        x: l_int32,
        y: l_int32,
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRandomPixel(
        pix: *mut PIX,
        pval: *mut l_uint32,
        px: *mut l_int32,
        py: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClearPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixFlipPixel(pix: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn setPixelLow(line: *mut l_uint32, x: l_int32, depth: l_int32, val: l_uint32);
}
extern "C" {
    pub fn pixGetBlackOrWhiteVal(pixs: *mut PIX, op: l_int32, pval: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixClearAll(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSetAll(pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSetAllGray(pix: *mut PIX, grayval: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetAllArbitrary(pix: *mut PIX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetBlackOrWhite(pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetComponentArbitrary(pix: *mut PIX, comp: l_int32, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixClearInRect(pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixSetInRect(pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixSetInRectArbitrary(pix: *mut PIX, box_: *mut BOX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixBlendInRect(pixs: *mut PIX, box_: *mut BOX, val: l_uint32, fract: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixSetPadBits(pix: *mut PIX, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetPadBitsBand(pix: *mut PIX, by: l_int32, bh: l_int32, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetOrClearBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetBorderVal(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetBorderRingVal(pixs: *mut PIX, dist: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCopyBorder(
        pixd: *mut PIX,
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorder(pixs: *mut PIX, npix: l_int32, val: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBlackOrWhiteBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        op: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorder(pixs: *mut PIX, npix: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderGeneral(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMirroredBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRepeatedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddMixedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddContinuedBorder(
        pixs: *mut PIX,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixShiftAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        shiftx: l_float32,
        shifty: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayLayersRGBA(pixs: *mut PIX, val: l_uint32, maxw: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCreateRGBImage(pixr: *mut PIX, pixg: *mut PIX, pixb: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetRGBComponent(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSetRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetRGBComponentCmap(pixs: *mut PIX, comp: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixCopyRGBComponent(pixd: *mut PIX, pixs: *mut PIX, comp: l_int32) -> l_ok;
}
extern "C" {
    pub fn composeRGBPixel(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn composeRGBAPixel(
        rval: l_int32,
        gval: l_int32,
        bval: l_int32,
        aval: l_int32,
        ppixel: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn extractRGBValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractRGBAValues(
        pixel: l_uint32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        paval: *mut l_int32,
    );
}
extern "C" {
    pub fn extractMinMaxComponent(pixel: l_uint32, type_: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixGetRGBLine(
        pixs: *mut PIX,
        row: l_int32,
        bufr: *mut l_uint8,
        bufg: *mut l_uint8,
        bufb: *mut l_uint8,
    ) -> l_ok;
}
extern "C" {
    pub fn setLineDataVal(line: *mut l_uint32, j: l_int32, d: l_int32, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixEndianByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianByteSwap(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn lineEndianByteSwap(datad: *mut l_uint32, datas: *mut l_uint32, wpl: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixEndianTwoByteSwapNew(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixEndianTwoByteSwap(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetRasterData(pixs: *mut PIX, pdata: *mut *mut l_uint8, pnbytes: *mut size_t)
        -> l_ok;
}
extern "C" {
    pub fn pixInferResolution(pix: *mut PIX, longside: l_float32, pres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixAlphaIsOpaque(pix: *mut PIX, popaque: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSetupByteProcessing(
        pix: *mut PIX,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> *mut *mut l_uint8;
}
extern "C" {
    pub fn pixCleanupByteProcessing(pix: *mut PIX, lineptrs: *mut *mut l_uint8) -> l_ok;
}
extern "C" {
    pub fn l_setAlphaMaskBorder(val1: l_float32, val2: l_float32);
}
extern "C" {
    pub fn pixSetMasked(pixd: *mut PIX, pixm: *mut PIX, val: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixSetMaskedGeneral(
        pixd: *mut PIX,
        pixm: *mut PIX,
        val: l_uint32,
        x: l_int32,
        y: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCombineMasked(pixd: *mut PIX, pixs: *mut PIX, pixm: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixCombineMaskedGeneral(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPaintThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        val: l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCopyWithBoxa(pixs: *mut PIX, boxa: *mut BOXA, background: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixPaintSelfThroughMask(
        pixd: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        searchdir: l_int32,
        mindist: l_int32,
        tilesize: l_int32,
        ntiles: l_int32,
        distblend: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeMaskFromVal(pixs: *mut PIX, val: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeMaskFromLUT(pixs: *mut PIX, tab: *mut l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeArbMaskFromRGB(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetUnderTransparency(pixs: *mut PIX, val: l_uint32, debug: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeAlphaFromMask(pixs: *mut PIX, dist: l_int32, pbox: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixGetColorNearMaskBoundary(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pval: *mut l_uint32,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplaySelectedPixels(
        pixs: *mut PIX,
        pixm: *mut PIX,
        sel: *mut SEL,
        val: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInvert(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixOr(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAnd(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixXor(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtract(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixZero(pix: *mut PIX, pempty: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixForegroundFraction(pix: *mut PIX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaCountPixels(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixels(pixs: *mut PIX, pcount: *mut l_int32, tab8: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCountPixelsInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCountByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByRow(pix: *mut PIX, tab8: *mut l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsByColumn(pix: *mut PIX) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountPixelsInRow(
        pix: *mut PIX,
        row: l_int32,
        pcount: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMomentByColumn(pix: *mut PIX, order: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixThresholdPixelSum(
        pix: *mut PIX,
        thresh: l_int32,
        pabove: *mut l_int32,
        tab8: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makePixelSumTab8() -> *mut l_int32;
}
extern "C" {
    pub fn makePixelCentroidTab8() -> *mut l_int32;
}
extern "C" {
    pub fn pixAverageByRow(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageByColumn(pix: *mut PIX, box_: *mut BOX, type_: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageInRect(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        minval: l_int32,
        maxval: l_int32,
        subsamp: l_int32,
        pave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixAverageInRectRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        box_: *mut BOX,
        subsamp: l_int32,
        pave: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixVarianceByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixVarianceInRect(pix: *mut PIX, box_: *mut BOX, prootvar: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixAbsDiffByRow(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffByColumn(pix: *mut PIX, box_: *mut BOX) -> *mut NUMA;
}
extern "C" {
    pub fn pixAbsDiffInRect(
        pix: *mut PIX,
        box_: *mut BOX,
        dir: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixAbsDiffOnLine(
        pix: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        pabsdiff: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCountArbInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        val: l_int32,
        factor: l_int32,
        pcount: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixMirroredTiling(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindRepCloseTile(
        pixs: *mut PIX,
        box_: *mut BOX,
        searchdir: l_int32,
        mindist: l_int32,
        tsize: l_int32,
        ntiles: l_int32,
        pboxtile: *mut *mut BOX,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetGrayHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetGrayHistogramTiled(
        pixs: *mut PIX,
        factor: l_int32,
        nx: l_int32,
        ny: l_int32,
    ) -> *mut NUMAA;
}
extern "C" {
    pub fn pixGetColorHistogram(
        pixs: *mut PIX,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetColorHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pnar: *mut *mut NUMA,
        pnag: *mut *mut NUMA,
        pnab: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetCmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetCmapHistogramInRect(pixs: *mut PIX, box_: *mut BOX, factor: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixCountRGBColorsByHash(pixs: *mut PIX, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixCountRGBColors(pixs: *mut PIX, factor: l_int32, pncolors: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetColorAmapHistogram(pixs: *mut PIX, factor: l_int32) -> *mut L_AMAP;
}
extern "C" {
    pub fn amapGetCountForColor(amap: *mut L_AMAP, val: l_uint32) -> l_int32;
}
extern "C" {
    pub fn pixGetRankValue(
        pixs: *mut PIX,
        factor: l_int32,
        rank: l_float32,
        pvalue: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankValueMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankValueMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        rank: l_float32,
        pval: *mut l_float32,
        pna: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixelAverage(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        pval: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetPixelStats(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        pvalue: *mut l_uint32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageMaskedRGB(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_float32,
        pgval: *mut l_float32,
        pbval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        factor: l_int32,
        type_: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageTiledRGB(
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
        type_: l_int32,
        ppixr: *mut *mut PIX,
        ppixg: *mut *mut PIX,
        ppixb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetAverageTiled(pixs: *mut PIX, sx: l_int32, sy: l_int32, type_: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixRowStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixColumnStats(
        pixs: *mut PIX,
        box_: *mut BOX,
        pnamean: *mut *mut NUMA,
        pnamedian: *mut *mut NUMA,
        pnamode: *mut *mut NUMA,
        pnamodecount: *mut *mut NUMA,
        pnavar: *mut *mut NUMA,
        pnarootvar: *mut *mut NUMA,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetRangeValues(
        pixs: *mut PIX,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetExtremeValue(
        pixs: *mut PIX,
        factor: l_int32,
        type_: l_int32,
        prval: *mut l_int32,
        pgval: *mut l_int32,
        pbval: *mut l_int32,
        pgrayval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMaxValueInRect(
        pixs: *mut PIX,
        box_: *mut BOX,
        pmaxval: *mut l_uint32,
        pxmax: *mut l_int32,
        pymax: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetMaxColorIndex(pixs: *mut PIX, pmaxindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixGetBinnedComponentRange(
        pixs: *mut PIX,
        nbins: l_int32,
        factor: l_int32,
        color: l_int32,
        pminval: *mut l_int32,
        pmaxval: *mut l_int32,
        pcarray: *mut *mut l_uint32,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetRankColorArray(
        pixs: *mut PIX,
        nbins: l_int32,
        type_: l_int32,
        factor: l_int32,
        pcarray: *mut *mut l_uint32,
        pixadb: *mut PIXA,
        fontsize: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetBinnedColor(
        pixs: *mut PIX,
        pixg: *mut PIX,
        factor: l_int32,
        nbins: l_int32,
        pcarray: *mut *mut l_uint32,
        pixadb: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplayColorArray(
        carray: *mut l_uint32,
        ncolors: l_int32,
        side: l_int32,
        ncols: l_int32,
        fontsize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRankBinByStrip(
        pixs: *mut PIX,
        direction: l_int32,
        size: l_int32,
        nbins: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetAlignedStats(
        pixa: *mut PIXA,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaExtractColumnFromEachPix(pixa: *mut PIXA, col: l_int32, pixd: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixGetRowStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        colvect: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixGetColumnStats(
        pixs: *mut PIX,
        type_: l_int32,
        nbins: l_int32,
        thresh: l_int32,
        rowvect: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetPixelColumn(pix: *mut PIX, col: l_int32, colvect: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixThresholdForFgBg(
        pixs: *mut PIX,
        factor: l_int32,
        thresh: l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSplitDistributionFgBg(
        pixs: *mut PIX,
        scorefract: l_float32,
        factor: l_int32,
        pthresh: *mut l_int32,
        pfgval: *mut l_int32,
        pbgval: *mut l_int32,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindDimensions(pixa: *mut PIXA, pnaw: *mut *mut NUMA, pnah: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixFindAreaPerimRatio(pixs: *mut PIX, tab: *mut l_int32, pfract: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixaFindPerimToAreaRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimToAreaRatio(
        pixs: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindPerimSizeRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindPerimSizeRatio(pixs: *mut PIX, tab: *mut l_int32, pratio: *mut l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixaFindAreaFraction(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFraction(pixs: *mut PIX, tab: *mut l_int32, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaFindAreaFractionMasked(pixa: *mut PIXA, pixm: *mut PIX, debug: l_int32)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindAreaFractionMasked(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixm: *mut PIX,
        tab: *mut l_int32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindWidthHeightRatio(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixaFindWidthHeightProduct(pixa: *mut PIXA) -> *mut NUMA;
}
extern "C" {
    pub fn pixFindOverlapFraction(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        x2: l_int32,
        y2: l_int32,
        tab: *mut l_int32,
        pratio: *mut l_float32,
        pnoverlap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindRectangleComps(
        pixs: *mut PIX,
        dist: l_int32,
        minw: l_int32,
        minh: l_int32,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixConformsToRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        dist: l_int32,
        pconforms: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClipRectangles(pixs: *mut PIX, boxa: *mut BOXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixClipRectangle(pixs: *mut PIX, box_: *mut BOX, pboxc: *mut *mut BOX) -> *mut PIX;
}
extern "C" {
    pub fn pixClipRectangleWithBorder(
        pixs: *mut PIX,
        box_: *mut BOX,
        maxbord: l_int32,
        pboxn: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixClipMasked(
        pixs: *mut PIX,
        pixm: *mut PIX,
        x: l_int32,
        y: l_int32,
        outval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixCropToMatch(
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        ppixd1: *mut *mut PIX,
        ppixd2: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCropToSize(pixs: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixResizeToMatch(pixs: *mut PIX, pixt: *mut PIX, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectComponentBySize(
        pixs: *mut PIX,
        rankorder: l_int32,
        type_: l_int32,
        connectivity: l_int32,
        pbox: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFilterComponentBySize(
        pixs: *mut PIX,
        rankorder: l_int32,
        type_: l_int32,
        connectivity: l_int32,
        pbox: *mut *mut BOX,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeSymmetricMask(
        w: l_int32,
        h: l_int32,
        hf: l_float32,
        vf: l_float32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeFrameMask(
        w: l_int32,
        h: l_int32,
        hf1: l_float32,
        hf2: l_float32,
        vf1: l_float32,
        vf2: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMakeCoveringOfRectangles(pixs: *mut PIX, maxiters: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFractionFgInMask(pix1: *mut PIX, pix2: *mut PIX, pfract: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixClipToForeground(pixs: *mut PIX, ppixd: *mut *mut PIX, pbox: *mut *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixTestClipToForeground(pixs: *mut PIX, pcanclip: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixClipBoxToForeground(
        pixs: *mut PIX,
        boxs: *mut BOX,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScanForForeground(
        pixs: *mut PIX,
        box_: *mut BOX,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixClipBoxToEdges(
        pixs: *mut PIX,
        boxs: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        ppixd: *mut *mut PIX,
        pboxd: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScanForEdge(
        pixs: *mut PIX,
        box_: *mut BOX,
        lowthresh: l_int32,
        highthresh: l_int32,
        maxwidth: l_int32,
        factor: l_int32,
        scanflag: l_int32,
        ploc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixExtractOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixAverageOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        factor: l_int32,
    ) -> l_float32;
}
extern "C" {
    pub fn pixAverageIntensityProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixReversalProfile(
        pixs: *mut PIX,
        fract: l_float32,
        dir: l_int32,
        first: l_int32,
        last: l_int32,
        minreversal: l_int32,
        factor1: l_int32,
        factor2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixWindowedVarianceOnLine(
        pixs: *mut PIX,
        dir: l_int32,
        loc: l_int32,
        c1: l_int32,
        c2: l_int32,
        size: l_int32,
        pnad: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMinMaxNearLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
        dist: l_int32,
        direction: l_int32,
        pnamin: *mut *mut NUMA,
        pnamax: *mut *mut NUMA,
        pminave: *mut l_float32,
        pmaxave: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRankRowTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRankColumnTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixaCreate(n: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromPix(
        pixs: *mut PIX,
        n: l_int32,
        cellw: l_int32,
        cellh: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCreateFromBoxa(
        pixs: *mut PIX,
        boxa: *mut BOXA,
        start: l_int32,
        num: l_int32,
        pcropwarn: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitPix(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaDestroy(ppixa: *mut *mut PIXA);
}
extern "C" {
    pub fn pixaCopy(pixa: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPix(pixa: *mut PIXA, pix: *mut PIX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaAddBox(pixa: *mut PIXA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaExtendArrayToSize(pixa: *mut PIXA, size: size_t) -> l_ok;
}
extern "C" {
    pub fn pixaGetCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaChangeRefcount(pixa: *mut PIXA, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetPix(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaGetPixDimensions(
        pixa: *mut PIXA,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetBoxa(pixa: *mut PIXA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaGetBoxaCount(pixa: *mut PIXA) -> l_int32;
}
extern "C" {
    pub fn pixaGetBox(pixa: *mut PIXA, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixaGetBoxGeometry(
        pixa: *mut PIXA,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSetBoxa(pixa: *mut PIXA, boxa: *mut BOXA, accesstype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetPixArray(pixa: *mut PIXA) -> *mut *mut PIX;
}
extern "C" {
    pub fn pixaVerifyDepth(pixa: *mut PIXA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaVerifyDimensions(
        pixa: *mut PIXA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaIsFull(pixa: *mut PIXA, pfullpa: *mut l_int32, pfullba: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaCountText(pixa: *mut PIXA, pntext: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaSetText(
        pixa: *mut PIXA,
        text: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetLinePtrs(
        pixa: *mut PIXA,
        psize: *mut l_int32,
    ) -> *mut *mut *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pixaWriteStreamInfo(fp: *mut FILE, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaReplacePix(pixa: *mut PIXA, index: l_int32, pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaInsertPix(pixa: *mut PIXA, index: l_int32, pixs: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaRemovePix(pixa: *mut PIXA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaRemovePixAndSave(
        pixa: *mut PIXA,
        index: l_int32,
        ppix: *mut *mut PIX,
        pbox: *mut *mut BOX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveSelected(pixa: *mut PIXA, naindex: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixaInitFull(pixa: *mut PIXA, pix: *mut PIX, box_: *mut BOX) -> l_ok;
}
extern "C" {
    pub fn pixaClear(pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaJoin(pixad: *mut PIXA, pixas: *mut PIXA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaInterleave(pixa1: *mut PIXA, pixa2: *mut PIXA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaJoin(paad: *mut PIXAA, paas: *mut PIXAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaCreate(n: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaCreateFromPixa(
        pixa: *mut PIXA,
        n: l_int32,
        type_: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaDestroy(ppaa: *mut *mut PIXAA);
}
extern "C" {
    pub fn pixaaAddPixa(paa: *mut PIXAA, pixa: *mut PIXA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaAddPix(
        paa: *mut PIXAA,
        index: l_int32,
        pix: *mut PIX,
        box_: *mut BOX,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaaAddBox(paa: *mut PIXAA, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaGetCount(paa: *mut PIXAA, pna: *mut *mut NUMA) -> l_int32;
}
extern "C" {
    pub fn pixaaGetPixa(paa: *mut PIXAA, index: l_int32, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaGetBoxa(paa: *mut PIXAA, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixaaGetPix(
        paa: *mut PIXAA,
        index: l_int32,
        ipix: l_int32,
        accessflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaVerifyDepth(paa: *mut PIXAA, psame: *mut l_int32, pmaxd: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaaVerifyDimensions(
        paa: *mut PIXAA,
        psame: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaaIsFull(paa: *mut PIXAA, pfull: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaaInitFull(paa: *mut PIXAA, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaaReplacePixa(paa: *mut PIXAA, index: l_int32, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaaClear(paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaTruncate(paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadStream(fp: *mut FILE) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadMem(data: *const l_uint8, size: size_t) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteDebug(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWrite(filename: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWriteStream(fp: *mut FILE, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaReadBoth(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaReadFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadStream(fp: *mut FILE) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaReadMem(data: *const l_uint8, size: size_t) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaWrite(filename: *const ::std::os::raw::c_char, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaWriteStream(fp: *mut FILE, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaaWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, paa: *mut PIXAA) -> l_ok;
}
extern "C" {
    pub fn pixaccCreate(w: l_int32, h: l_int32, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccCreateFromPix(pix: *mut PIX, negflag: l_int32) -> *mut PIXACC;
}
extern "C" {
    pub fn pixaccDestroy(ppixacc: *mut *mut PIXACC);
}
extern "C" {
    pub fn pixaccFinal(pixacc: *mut PIXACC, outdepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetPix(pixacc: *mut PIXACC) -> *mut PIX;
}
extern "C" {
    pub fn pixaccGetOffset(pixacc: *mut PIXACC) -> l_int32;
}
extern "C" {
    pub fn pixaccAdd(pixacc: *mut PIXACC, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixaccSubtract(pixacc: *mut PIXACC, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixaccMultConst(pixacc: *mut PIXACC, factor: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixaccMultConstAccumulate(pixacc: *mut PIXACC, pix: *mut PIX, factor: l_float32)
        -> l_ok;
}
extern "C" {
    pub fn pixSelectBySize(
        pixs: *mut PIX,
        width: l_int32,
        height: l_int32,
        connectivity: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectBySize(
        pixas: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeSizeIndicator(
        pixa: *mut PIXA,
        width: l_int32,
        height: l_int32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSelectByPerimToAreaRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimToAreaRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByPerimSizeRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByPerimSizeRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByAreaFraction(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByAreaFraction(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByArea(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByArea(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSelectByWidthHeightRatio(
        pixs: *mut PIX,
        thresh: l_float32,
        connectivity: l_int32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaSelectByWidthHeightRatio(
        pixas: *mut PIXA,
        thresh: l_float32,
        type_: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectByNumConnComp(
        pixas: *mut PIXA,
        nmin: l_int32,
        nmax: l_int32,
        connectivity: l_int32,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectWithIndicator(
        pixas: *mut PIXA,
        na: *mut NUMA,
        pchanged: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixRemoveWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixAddWithIndicator(pixs: *mut PIX, pixa: *mut PIXA, na: *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixaSelectWithString(
        pixas: *mut PIXA,
        str_: *const ::std::os::raw::c_char,
        perror: *mut l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRenderComponent(pixs: *mut PIX, pixa: *mut PIXA, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaBinSort(
        pixas: *mut PIXA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSortByIndex(pixas: *mut PIXA, naindex: *mut NUMA, copyflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSort2dByIndex(pixas: *mut PIXA, naa: *mut NUMAA, copyflag: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaSelectRange(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSelectRange(
        paas: *mut PIXAA,
        first: l_int32,
        last: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSize(paas: *mut PIXAA, wd: l_int32, hd: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaaScaleToSizeVar(paas: *mut PIXAA, nawd: *mut NUMA, nahd: *mut NUMA) -> *mut PIXAA;
}
extern "C" {
    pub fn pixaScaleToSize(pixas: *mut PIXA, wd: l_int32, hd: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleToSizeRel(pixas: *mut PIXA, delw: l_int32, delh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScale(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaScaleBySampling(pixas: *mut PIXA, scalex: l_float32, scaley: l_float32)
        -> *mut PIXA;
}
extern "C" {
    pub fn pixaRotate(
        pixas: *mut PIXA,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaRotateOrth(pixas: *mut PIXA, rotation: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaTranslate(
        pixas: *mut PIXA,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddBorderGeneral(
        pixad: *mut PIXA,
        pixas: *mut PIXA,
        left: l_int32,
        right: l_int32,
        top: l_int32,
        bot: l_int32,
        val: l_uint32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaFlattenToPixa(
        paa: *mut PIXAA,
        pnaindex: *mut *mut NUMA,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaaSizeRange(
        paa: *mut PIXAA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSizeRange(
        pixa: *mut PIXA,
        pminw: *mut l_int32,
        pminh: *mut l_int32,
        pmaxw: *mut l_int32,
        pmaxh: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaClipToPix(pixas: *mut PIXA, pixs: *mut PIX) -> *mut PIXA;
}
extern "C" {
    pub fn pixaClipToForeground(
        pixas: *mut PIXA,
        ppixad: *mut *mut PIXA,
        pboxa: *mut *mut BOXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaGetRenderingDepth(pixa: *mut PIXA, pdepth: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaHasColor(pixa: *mut PIXA, phascolor: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaAnyColormaps(pixa: *mut PIXA, phascmap: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaGetDepthInfo(pixa: *mut PIXA, pmaxdepth: *mut l_int32, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaConvertToSameDepth(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToGivenDepth(pixas: *mut PIXA, depth: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaEqual(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        maxdist: l_int32,
        pnaindex: *mut *mut NUMA,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaSetFullSizeBoxa(pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn pixaDisplay(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayRandomCmap(pixa: *mut PIXA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayLinearly(
        pixas: *mut PIXA,
        direction: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayOnLattice(
        pixa: *mut PIXA,
        cellw: l_int32,
        cellh: l_int32,
        pncols: *mut l_int32,
        pboxa: *mut *mut BOXA,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayUnsplit(
        pixa: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        borderwidth: l_int32,
        bordercolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiled(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        background: l_int32,
        spacing: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInRows(
        pixa: *mut PIXA,
        outdepth: l_int32,
        maxwidth: l_int32,
        scalefactor: l_float32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledInColumns(
        pixas: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledAndScaled(
        pixa: *mut PIXA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledWithText(
        pixa: *mut PIXA,
        maxwidth: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayTiledByIndex(
        pixa: *mut PIXA,
        na: *mut NUMA,
        width: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaDisplayPairTiledInColumns(
        pixas1: *mut PIXA,
        pixas2: *mut PIXA,
        nx: l_int32,
        scalefactor: l_float32,
        spacing1: l_int32,
        spacing2: l_int32,
        border1: l_int32,
        border2: l_int32,
        fontsize: l_int32,
        startindex: l_int32,
        sa: *mut SARRAY,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplay(paa: *mut PIXAA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayByPixa(
        paa: *mut PIXAA,
        maxnx: l_int32,
        scalefactor: l_float32,
        hspacing: l_int32,
        vspacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaaDisplayTiledAndScaled(
        paa: *mut PIXAA,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo1(pixas: *mut PIXA, thresh: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8(pixas: *mut PIXA, cmapflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo8Colormap(pixas: *mut PIXA, dither: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertTo32(pixas: *mut PIXA) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConstrainedSelect(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        nmax: l_int32,
        use_pairs: l_int32,
        copyflag: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSelectToPdf(
        pixas: *mut PIXA,
        first: l_int32,
        last: l_int32,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        color: l_uint32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaMakeFromTiledPixa(
        pixas: *mut PIXA,
        w: l_int32,
        h: l_int32,
        nsamp: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaMakeFromTiledPix(
        pixs: *mut PIX,
        w: l_int32,
        h: l_int32,
        start: l_int32,
        num: l_int32,
        boxa: *mut BOXA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixGetTileCount(pix: *mut PIX, pn: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaDisplayMultiTiled(
        pixas: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        maxw: l_int32,
        maxh: l_int32,
        scalefactor: l_float32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaSplitIntoFiles(
        pixas: *mut PIXA,
        nsplit: l_int32,
        scale: l_float32,
        outwidth: l_int32,
        write_pixa: l_int32,
        write_pix: l_int32,
        write_pdf: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToNUpFiles(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToNUpPixa(
        dir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaConvertToNUpPixa(
        pixas: *mut PIXA,
        sa: *mut SARRAY,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaCompareInPdf(
        pixa1: *mut PIXA,
        pixa2: *mut PIXA,
        nx: l_int32,
        ny: l_int32,
        tw: l_int32,
        spacing: l_int32,
        border: l_int32,
        fontsize: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pmsCreate(
        minsize: size_t,
        smallest: size_t,
        numalloc: *mut NUMA,
        logfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pmsDestroy();
}
extern "C" {
    pub fn pmsCustomAlloc(nbytes: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsCustomDealloc(data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pmsGetAlloc(nbytes: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pmsGetLevelForAlloc(nbytes: size_t, plevel: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pmsGetLevelForDealloc(data: *mut ::std::os::raw::c_void, plevel: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pmsLogInfo();
}
extern "C" {
    pub fn pixAddConstantGray(pixs: *mut PIX, val: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixMultConstantGray(pixs: *mut PIX, val: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixAddGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSubtractGray(pixd: *mut PIX, pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMultiplyGray(pixs: *mut PIX, pixg: *mut PIX, norm: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixThresholdToValue(
        pixd: *mut PIX,
        pixs: *mut PIX,
        threshval: l_int32,
        setval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixInitAccumulate(w: l_int32, h: l_int32, offset: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulate(pixs: *mut PIX, offset: l_uint32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFinalAccumulateThreshold(
        pixs: *mut PIX,
        offset: l_uint32,
        threshold: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAccumulate(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixMultConstAccumulate(pixs: *mut PIX, factor: l_float32, offset: l_uint32) -> l_ok;
}
extern "C" {
    pub fn pixAbsDifference(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddRGB(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixMinOrMax(
        pixd: *mut PIX,
        pixs1: *mut PIX,
        pixs2: *mut PIX,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRange(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixMaxDynamicRangeRGB(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn linearScaleRGBVal(sval: l_uint32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn logScaleRGBVal(sval: l_uint32, tab: *mut l_float32, factor: l_float32) -> l_uint32;
}
extern "C" {
    pub fn makeLogBase2Tab() -> *mut l_float32;
}
extern "C" {
    pub fn getLogBase2(val: l_int32, logtab: *mut l_float32) -> l_float32;
}
extern "C" {
    pub fn pixcompCreateFromPix(pix: *mut PIX, comptype: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromString(
        data: *mut l_uint8,
        size: size_t,
        copyflag: l_int32,
    ) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompCreateFromFile(
        filename: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompDestroy(ppixc: *mut *mut PIXC);
}
extern "C" {
    pub fn pixcompCopy(pixcs: *mut PIXC) -> *mut PIXC;
}
extern "C" {
    pub fn pixcompGetDimensions(
        pixc: *mut PIXC,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompGetParameters(
        pixc: *mut PIXC,
        pxres: *mut l_int32,
        pyres: *mut l_int32,
        pcomptype: *mut l_int32,
        pcmapflag: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompDetermineFormat(
        comptype: l_int32,
        d: l_int32,
        cmapflag: l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixCreateFromPixcomp(pixc: *mut PIXC) -> *mut PIX;
}
extern "C" {
    pub fn pixacompCreate(n: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateWithInit(
        n: l_int32,
        offset: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromPixa(
        pixa: *mut PIXA,
        comptype: l_int32,
        accesstype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        comptype: l_int32,
    ) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompCreateFromSA(sa: *mut SARRAY, comptype: l_int32) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompDestroy(ppixac: *mut *mut PIXAC);
}
extern "C" {
    pub fn pixacompAddPix(pixac: *mut PIXAC, pix: *mut PIX, comptype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompAddPixcomp(pixac: *mut PIXAC, pixc: *mut PIXC, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompReplacePix(
        pixac: *mut PIXAC,
        index: l_int32,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompReplacePixcomp(pixac: *mut PIXAC, index: l_int32, pixc: *mut PIXC) -> l_ok;
}
extern "C" {
    pub fn pixacompAddBox(pixac: *mut PIXAC, box_: *mut BOX, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixacompGetCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetPixcomp(pixac: *mut PIXAC, index: l_int32, copyflag: l_int32) -> *mut PIXC;
}
extern "C" {
    pub fn pixacompGetPix(pixac: *mut PIXAC, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixacompGetPixDimensions(
        pixac: *mut PIXAC,
        index: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompGetBoxa(pixac: *mut PIXAC, accesstype: l_int32) -> *mut BOXA;
}
extern "C" {
    pub fn pixacompGetBoxaCount(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompGetBox(pixac: *mut PIXAC, index: l_int32, accesstype: l_int32) -> *mut BOX;
}
extern "C" {
    pub fn pixacompGetBoxGeometry(
        pixac: *mut PIXAC,
        index: l_int32,
        px: *mut l_int32,
        py: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompGetOffset(pixac: *mut PIXAC) -> l_int32;
}
extern "C" {
    pub fn pixacompSetOffset(pixac: *mut PIXAC, offset: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixaCreateFromPixacomp(pixac: *mut PIXAC, accesstype: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixacompJoin(
        pixacd: *mut PIXAC,
        pixacs: *mut PIXAC,
        istart: l_int32,
        iend: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompInterleave(pixac1: *mut PIXAC, pixac2: *mut PIXAC) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompRead(filename: *const ::std::os::raw::c_char) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadStream(fp: *mut FILE) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompReadMem(data: *const l_uint8, size: size_t) -> *mut PIXAC;
}
extern "C" {
    pub fn pixacompWrite(filename: *const ::std::os::raw::c_char, pixac: *mut PIXAC) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteStream(fp: *mut FILE, pixac: *mut PIXAC) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pixac: *mut PIXAC,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompConvertToPdf(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompConvertToPdfData(
        pixac: *mut PIXAC,
        res: l_int32,
        scalefactor: l_float32,
        type_: l_int32,
        quality: l_int32,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompFastConvertToPdfData(
        pixac: *mut PIXAC,
        title: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompWriteStreamInfo(
        fp: *mut FILE,
        pixac: *mut PIXAC,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixcompWriteStreamInfo(
        fp: *mut FILE,
        pixc: *mut PIXC,
        text: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixacompDisplayTiledAndScaled(
        pixac: *mut PIXAC,
        outdepth: l_int32,
        tilewidth: l_int32,
        ncols: l_int32,
        background: l_int32,
        spacing: l_int32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixacompWriteFiles(pixac: *mut PIXAC, subdir: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn pixcompWriteFile(rootname: *const ::std::os::raw::c_char, pixc: *mut PIXC) -> l_ok;
}
extern "C" {
    pub fn pixThreshold8(
        pixs: *mut PIX,
        d: l_int32,
        nlevels: l_int32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormapGeneral(pixs: *mut PIX, type_: l_int32, ifnocmap: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveColormap(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixAddGrayColormap8(pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixAddMinimalGrayColormap8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToLuminance(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayGeneral(
        pixs: *mut PIX,
        type_: l_int32,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGray(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayFast(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayMinMax(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGraySatBoost(pixs: *mut PIX, refval: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToGrayArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToBinaryArb(
        pixs: *mut PIX,
        rc: l_float32,
        gc: l_float32,
        bc: l_float32,
        thresh: l_int32,
        relation: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToColormap8(pixs: *mut PIX, mindepth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixColorizeGray(pixs: *mut PIX, color: l_uint32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertRGBToColormap(pixs: *mut PIX, ditherflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertCmapTo1(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixQuantizeIfFewColors(
        pixs: *mut PIX,
        maxcolors: l_int32,
        mingraycolors: l_int32,
        octlevel: l_int32,
        ppixd: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConvert16To8(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToFalseColor(pixs: *mut PIX, gamma: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixUnpackBinary(pixs: *mut PIX, depth: l_int32, invert: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To16(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint16,
        val1: l_uint16,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To32(
        pixd: *mut PIX,
        pixs: *mut PIX,
        val0: l_uint32,
        val1: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To2(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To4(pixd: *mut PIX, pixs: *mut PIX, val0: l_int32, val1: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8Cmap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert1To8(pixd: *mut PIX, pixs: *mut PIX, val0: l_uint8, val1: l_uint8)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvert2To8(
        pixs: *mut PIX,
        val0: l_uint8,
        val1: l_uint8,
        val2: l_uint8,
        val3: l_uint8,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert4To8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To16(pixs: *mut PIX, leftshift: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To4(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1Adaptive(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1(pixs: *mut PIX, threshold: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo1BySampling(pixs: *mut PIX, factor: l_int32, threshold: l_int32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8(pixs: *mut PIX, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8BySampling(pixs: *mut PIX, factor: l_int32, cmapflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Colormap(pixs: *mut PIX, dither: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo32BySampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert8To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertTo8Or32(pixs: *mut PIX, copyflag: l_int32, warnflag: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert24To32(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To24(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To16(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvert32To8(pixs: *mut PIX, type16: l_int32, type8: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveAlpha(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixAddAlphaTo1bpp(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertLossless(pixs: *mut PIX, d: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertForPSWrap(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertGrayToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixConvertColorToSubpixelRGB(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        order: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_setNeutralBoostVal(val: l_int32);
}
extern "C" {
    pub fn pixConnCompTransform(pixs: *mut PIX, connect: l_int32, depth: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompAreaTransform(pixs: *mut PIX, connect: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixConnCompIncrInit(
        pixs: *mut PIX,
        conn: l_int32,
        ppixd: *mut *mut PIX,
        pptaa: *mut *mut PTAA,
        pncc: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixConnCompIncrAdd(
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pncc: *mut l_int32,
        x: l_float32,
        y: l_float32,
        debug: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixGetSortedNeighborValues(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        conn: l_int32,
        pneigh: *mut *mut l_int32,
        pnvals: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixLocToColorTransform(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingCreate(
        pixs: *mut PIX,
        nx: l_int32,
        ny: l_int32,
        w: l_int32,
        h: l_int32,
        xoverlap: l_int32,
        yoverlap: l_int32,
    ) -> *mut PIXTILING;
}
extern "C" {
    pub fn pixTilingDestroy(ppt: *mut *mut PIXTILING);
}
extern "C" {
    pub fn pixTilingGetCount(pt: *mut PIXTILING, pnx: *mut l_int32, pny: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixTilingGetSize(pt: *mut PIXTILING, pw: *mut l_int32, ph: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixTilingGetTile(pt: *mut PIXTILING, i: l_int32, j: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixTilingNoStripOnPaint(pt: *mut PIXTILING) -> l_ok;
}
extern "C" {
    pub fn pixTilingPaintTile(
        pixd: *mut PIX,
        i: l_int32,
        j: l_int32,
        pixs: *mut PIX,
        pt: *mut PIXTILING,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamPng(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPng(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderPng(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemPng(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetPngResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn isPngInterlaced(
        filename: *const ::std::os::raw::c_char,
        pinterlaced: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fgetPngColormapInfo(
        fp: *mut FILE,
        pcmap: *mut *mut PIXCMAP,
        ptransparency: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWritePng(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPng(fp: *mut FILE, pix: *mut PIX, gamma: l_float32) -> l_ok;
}
extern "C" {
    pub fn pixSetZlibCompression(pix: *mut PIX, compval: l_int32) -> l_ok;
}
extern "C" {
    pub fn l_pngSetReadStrip16To8(flag: l_int32);
}
extern "C" {
    pub fn pixReadMemPng(filedata: *const l_uint8, filesize: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemPng(
        pfiledata: *mut *mut l_uint8,
        pfilesize: *mut size_t,
        pix: *mut PIX,
        gamma: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamPnm(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderPnm(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderPnm(
        fp: *mut FILE,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPnm(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamAsciiPnm(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPam(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixReadMemPnm(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderMemPnm(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pd: *mut l_int32,
        ptype: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPnm(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPam(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixProjectiveSampledPta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveSampled(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePta(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjective(pixs: *mut PIX, vc: *mut l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaColor(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        colorval: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveColor(pixs: *mut PIX, vc: *mut l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaGray(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        grayval: l_uint8,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectiveGray(pixs: *mut PIX, vc: *mut l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixProjectivePtaWithAlpha(
        pixs: *mut PIX,
        ptad: *mut PTA,
        ptas: *mut PTA,
        pixg: *mut PIX,
        fract: l_float32,
        border: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn getProjectiveXformCoeffs(
        ptas: *mut PTA,
        ptad: *mut PTA,
        pvc: *mut *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn projectiveXformSampledPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn projectiveXformPt(
        vc: *mut l_float32,
        x: l_int32,
        y: l_int32,
        pxp: *mut l_float32,
        pyp: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFilesToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertFilesToPS(
        sa: *mut SARRAY,
        res: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFilesFittedToPS(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertFilesFittedToPS(
        sa: *mut SARRAY,
        xpts: l_float32,
        ypts: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn writeImageCompressedToPSFile(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertSegmentedPagesToPS(
        pagedir: *const ::std::os::raw::c_char,
        pagestr: *const ::std::os::raw::c_char,
        page_numpre: l_int32,
        maskdir: *const ::std::os::raw::c_char,
        maskstr: *const ::std::os::raw::c_char,
        mask_numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteSegmentedPageToPS(
        pixs: *mut PIX,
        pixm: *mut PIX,
        textscale: l_float32,
        imagescale: l_float32,
        threshold: l_int32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMixedToPS(
        pixb: *mut PIX,
        pixc: *mut PIX,
        scale: l_float32,
        pageno: l_int32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        level: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteCompressedToPS(
        pixa: *mut PIXA,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteCompressedToPS(
        pix: *mut PIX,
        fileout: *const ::std::os::raw::c_char,
        res: l_int32,
        level: l_int32,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWritePSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamPS(
        fp: *mut FILE,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStringPS(
        pixs: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn generateUncompressedPS(
        hexdata: *mut ::std::os::raw::c_char,
        w: l_int32,
        h: l_int32,
        d: l_int32,
        psbpl: l_int32,
        bps: l_int32,
        xpt: l_float32,
        ypt: l_float32,
        wpt: l_float32,
        hpt: l_float32,
        boxflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertJpegToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertJpegToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertG4ToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertG4ToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        maskflag: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertTiffMultipageToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        fillfract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFlateToPSEmbed(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn convertFlateToPS(
        filein: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        res: l_int32,
        scale: l_float32,
        pageno: l_int32,
        endpage: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemPS(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        box_: *mut BOX,
        res: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn getResLetterPage(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn getResA4Page(w: l_int32, h: l_int32, fillfract: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_psWriteBoundingBox(flag: l_int32);
}
extern "C" {
    pub fn ptaCreate(n: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaCreateFromNuma(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaDestroy(ppta: *mut *mut PTA);
}
extern "C" {
    pub fn ptaCopy(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCopyRange(ptas: *mut PTA, istart: l_int32, iend: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaClone(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEmpty(pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaAddPt(pta: *mut PTA, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaInsertPt(pta: *mut PTA, index: l_int32, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaRemovePt(pta: *mut PTA, index: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaGetRefcount(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaChangeRefcount(pta: *mut PTA, delta: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaGetCount(pta: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaGetPt(pta: *mut PTA, index: l_int32, px: *mut l_float32, py: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaGetIPt(pta: *mut PTA, index: l_int32, px: *mut l_int32, py: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaSetPt(pta: *mut PTA, index: l_int32, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaGetArrays(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn ptaRead(filename: *const ::std::os::raw::c_char) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadStream(fp: *mut FILE) -> *mut PTA;
}
extern "C" {
    pub fn ptaReadMem(data: *const l_uint8, size: size_t) -> *mut PTA;
}
extern "C" {
    pub fn ptaWriteDebug(
        filename: *const ::std::os::raw::c_char,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaWrite(filename: *const ::std::os::raw::c_char, pta: *mut PTA, type_: l_int32)
        -> l_ok;
}
extern "C" {
    pub fn ptaWriteStream(fp: *mut FILE, pta: *mut PTA, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pta: *mut PTA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaCreate(n: l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaDestroy(pptaa: *mut *mut PTAA);
}
extern "C" {
    pub fn ptaaAddPta(ptaa: *mut PTAA, pta: *mut PTA, copyflag: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaGetCount(ptaa: *mut PTAA) -> l_int32;
}
extern "C" {
    pub fn ptaaGetPta(ptaa: *mut PTAA, index: l_int32, accessflag: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetPt(
        ptaa: *mut PTAA,
        ipta: l_int32,
        jpt: l_int32,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaInitFull(ptaa: *mut PTAA, pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaaReplacePta(ptaa: *mut PTAA, index: l_int32, pta: *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaaAddPt(ptaa: *mut PTAA, ipta: l_int32, x: l_float32, y: l_float32) -> l_ok;
}
extern "C" {
    pub fn ptaaTruncate(ptaa: *mut PTAA) -> l_ok;
}
extern "C" {
    pub fn ptaaRead(filename: *const ::std::os::raw::c_char) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadStream(fp: *mut FILE) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaReadMem(data: *const l_uint8, size: size_t) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaWriteDebug(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaWrite(
        filename: *const ::std::os::raw::c_char,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaaWriteStream(fp: *mut FILE, ptaa: *mut PTAA, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        ptaa: *mut PTAA,
        type_: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSubsample(ptas: *mut PTA, subfactor: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaJoin(ptad: *mut PTA, ptas: *mut PTA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaaJoin(ptaad: *mut PTAA, ptaas: *mut PTAA, istart: l_int32, iend: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptaReverse(ptas: *mut PTA, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaTranspose(ptas: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaCyclicPerm(ptas: *mut PTA, xs: l_int32, ys: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaSelectRange(ptas: *mut PTA, first: l_int32, last: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetBoundingRegion(pta: *mut PTA) -> *mut BOX;
}
extern "C" {
    pub fn ptaGetRange(
        pta: *mut PTA,
        pminx: *mut l_float32,
        pmaxx: *mut l_float32,
        pminy: *mut l_float32,
        pmaxy: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetInsideBox(ptas: *mut PTA, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixFindCornerPixels(pixs: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaContainsPt(pta: *mut PTA, x: l_int32, y: l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaTestIntersection(pta1: *mut PTA, pta2: *mut PTA) -> l_int32;
}
extern "C" {
    pub fn ptaTransform(
        ptas: *mut PTA,
        shiftx: l_int32,
        shifty: l_int32,
        scalex: l_float32,
        scaley: l_float32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaPtInsidePolygon(
        pta: *mut PTA,
        x: l_float32,
        y: l_float32,
        pinside: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn l_angleBetweenVectors(
        x1: l_float32,
        y1: l_float32,
        x2: l_float32,
        y2: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn ptaPolygonIsConvex(pta: *mut PTA, pisconvex: *mut l_int32) -> l_int32;
}
extern "C" {
    pub fn ptaGetMinMax(
        pta: *mut PTA,
        pxmin: *mut l_float32,
        pymin: *mut l_float32,
        pxmax: *mut l_float32,
        pymax: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSelectByValue(
        ptas: *mut PTA,
        xth: l_float32,
        yth: l_float32,
        type_: l_int32,
        relation: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaCropToMask(ptas: *mut PTA, pixm: *mut PIX) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetLinearLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetQuadraticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetCubicLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetQuarticLSF(
        pta: *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pd: *mut l_float32,
        pe: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaNoisyLinearLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaNoisyQuadraticLSF(
        pta: *mut PTA,
        factor: l_float32,
        pptad: *mut *mut PTA,
        pa: *mut l_float32,
        pb: *mut l_float32,
        pc: *mut l_float32,
        pmederr: *mut l_float32,
        pnafit: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn applyLinearFit(a: l_float32, b: l_float32, x: l_float32, py: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn applyQuadraticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn applyCubicFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn applyQuarticFit(
        a: l_float32,
        b: l_float32,
        c: l_float32,
        d: l_float32,
        e: l_float32,
        x: l_float32,
        py: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixPlotAlongPta(
        pixs: *mut PIX,
        pta: *mut PTA,
        outformat: l_int32,
        title: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaGetPixelsFromPix(pixs: *mut PIX, box_: *mut BOX) -> *mut PTA;
}
extern "C" {
    pub fn pixGenerateFromPta(pta: *mut PTA, w: l_int32, h: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn ptaGetBoundaryPixels(pixs: *mut PIX, type_: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn ptaaGetBoundaryPixels(
        pixs: *mut PIX,
        type_: l_int32,
        connectivity: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
    ) -> *mut PTAA;
}
extern "C" {
    pub fn ptaaIndexLabeledPixels(pixs: *mut PIX, pncc: *mut l_int32) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetNeighborPixLocs(pixs: *mut PIX, x: l_int32, y: l_int32, conn: l_int32)
        -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta1(na: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn numaConvertToPta2(nax: *mut NUMA, nay: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaConvertToNuma(pta: *mut PTA, pnax: *mut *mut NUMA, pnay: *mut *mut NUMA) -> l_ok;
}
extern "C" {
    pub fn pixDisplayPta(pixd: *mut PIX, pixs: *mut PIX, pta: *mut PTA) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        ptaa: *mut PTAA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDisplayPtaPattern(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pta: *mut PTA,
        pixp: *mut PIX,
        cx: l_int32,
        cy: l_int32,
        color: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn ptaReplicatePattern(
        ptas: *mut PTA,
        pixp: *mut PIX,
        ptap: *mut PTA,
        cx: l_int32,
        cy: l_int32,
        w: l_int32,
        h: l_int32,
    ) -> *mut PTA;
}
extern "C" {
    pub fn pixDisplayPtaa(pixs: *mut PIX, ptaa: *mut PTAA) -> *mut PIX;
}
extern "C" {
    pub fn ptaSort(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> *mut PTA;
}
extern "C" {
    pub fn ptaGetSortIndex(
        ptas: *mut PTA,
        sorttype: l_int32,
        sortorder: l_int32,
        pnaindex: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSortByIndex(ptas: *mut PTA, naindex: *mut NUMA) -> *mut PTA;
}
extern "C" {
    pub fn ptaaSortByIndex(ptaas: *mut PTAA, naindex: *mut NUMA) -> *mut PTAA;
}
extern "C" {
    pub fn ptaGetRankValue(
        pta: *mut PTA,
        fract: l_float32,
        ptasort: *mut PTA,
        sorttype: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaSort2d(pta: *mut PTA) -> *mut PTA;
}
extern "C" {
    pub fn ptaEqual(pta1: *mut PTA, pta2: *mut PTA, psame: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn l_asetCreateFromPta(pta: *mut PTA) -> *mut L_ASET;
}
extern "C" {
    pub fn ptaRemoveDupsByAset(ptas: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaUnionByAset(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaIntersectionByAset(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromPta(pta: *mut PTA) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn ptaRemoveDupsByHmap(
        ptas: *mut PTA,
        pptad: *mut *mut PTA,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn ptaUnionByHmap(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptaIntersectionByHmap(pta1: *mut PTA, pta2: *mut PTA, pptad: *mut *mut PTA) -> l_ok;
}
extern "C" {
    pub fn ptraCreate(n: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraDestroy(ppa: *mut *mut L_PTRA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraAdd(pa: *mut L_PTRA, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn ptraInsert(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        shiftflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ptraRemove(
        pa: *mut L_PTRA,
        index: l_int32,
        flag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraRemoveLast(pa: *mut L_PTRA) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraReplace(
        pa: *mut L_PTRA,
        index: l_int32,
        item: *mut ::std::os::raw::c_void,
        freeflag: l_int32,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraSwap(pa: *mut L_PTRA, index1: l_int32, index2: l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraCompactArray(pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraReverse(pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraJoin(pa1: *mut L_PTRA, pa2: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraGetMaxIndex(pa: *mut L_PTRA, pmaxindex: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraGetActualCount(pa: *mut L_PTRA, pcount: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraGetPtrToItem(pa: *mut L_PTRA, index: l_int32) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn ptraaCreate(n: l_int32) -> *mut L_PTRAA;
}
extern "C" {
    pub fn ptraaDestroy(ppaa: *mut *mut L_PTRAA, freeflag: l_int32, warnflag: l_int32);
}
extern "C" {
    pub fn ptraaGetSize(paa: *mut L_PTRAA, psize: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn ptraaInsertPtra(paa: *mut L_PTRAA, index: l_int32, pa: *mut L_PTRA) -> l_ok;
}
extern "C" {
    pub fn ptraaGetPtra(paa: *mut L_PTRAA, index: l_int32, accessflag: l_int32) -> *mut L_PTRA;
}
extern "C" {
    pub fn ptraaFlattenToPtra(paa: *mut L_PTRAA) -> *mut L_PTRA;
}
extern "C" {
    pub fn pixQuadtreeMean(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        pfpixa: *mut *mut FPIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixQuadtreeVariance(
        pixs: *mut PIX,
        nlevels: l_int32,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pfpixa_v: *mut *mut FPIXA,
        pfpixa_rv: *mut *mut FPIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMeanInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pixma: *mut PIX,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixVarianceInRectangle(
        pixs: *mut PIX,
        box_: *mut BOX,
        pix_ma: *mut PIX,
        dpix_msa: *mut DPIX,
        pvar: *mut l_float32,
        prvar: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn boxaaQuadtreeRegions(w: l_int32, h: l_int32, nlevels: l_int32) -> *mut BOXAA;
}
extern "C" {
    pub fn quadtreeGetParent(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn quadtreeGetChildren(
        fpixa: *mut FPIXA,
        level: l_int32,
        x: l_int32,
        y: l_int32,
        pval00: *mut l_float32,
        pval10: *mut l_float32,
        pval01: *mut l_float32,
        pval11: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn quadtreeMaxLevels(w: l_int32, h: l_int32) -> l_int32;
}
extern "C" {
    pub fn fpixaDisplayQuadtree(fpixa: *mut FPIXA, factor: l_int32, fontsize: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn lqueueCreate(nalloc: l_int32) -> *mut L_QUEUE;
}
extern "C" {
    pub fn lqueueDestroy(plq: *mut *mut L_QUEUE, freeflag: l_int32);
}
extern "C" {
    pub fn lqueueAdd(lq: *mut L_QUEUE, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lqueueRemove(lq: *mut L_QUEUE) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lqueueGetCount(lq: *mut L_QUEUE) -> l_int32;
}
extern "C" {
    pub fn lqueuePrint(fp: *mut FILE, lq: *mut L_QUEUE) -> l_ok;
}
extern "C" {
    pub fn pixRankFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterRGB(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterGray(pixs: *mut PIX, wf: l_int32, hf: l_int32, rank: l_float32)
        -> *mut PIX;
}
extern "C" {
    pub fn pixMedianFilter(pixs: *mut PIX, wf: l_int32, hf: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRankFilterWithScaling(
        pixs: *mut PIX,
        wf: l_int32,
        hf: l_int32,
        rank: l_float32,
        scalefactor: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_rbtreeCreate(keytype: l_int32) -> *mut L_RBTREE;
}
extern "C" {
    pub fn l_rbtreeLookup(t: *mut L_RBTREE, key: RB_TYPE) -> *mut RB_TYPE;
}
extern "C" {
    pub fn l_rbtreeInsert(t: *mut L_RBTREE, key: RB_TYPE, value: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDelete(t: *mut L_RBTREE, key: RB_TYPE);
}
extern "C" {
    pub fn l_rbtreeDestroy(pt: *mut *mut L_RBTREE);
}
extern "C" {
    pub fn l_rbtreeGetFirst(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetNext(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetLast(t: *mut L_RBTREE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetPrev(n: *mut L_RBTREE_NODE) -> *mut L_RBTREE_NODE;
}
extern "C" {
    pub fn l_rbtreeGetCount(t: *mut L_RBTREE) -> l_int32;
}
extern "C" {
    pub fn l_rbtreePrint(fp: *mut FILE, t: *mut L_RBTREE);
}
extern "C" {
    pub fn pixProcessBarcodes(
        pixs: *mut PIX,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixExtractBarcodes(pixs: *mut PIX, debugflag: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn pixReadBarcodes(
        pixa: *mut PIXA,
        format: l_int32,
        method: l_int32,
        psaw: *mut *mut SARRAY,
        debugflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadBarcodeWidths(pixs: *mut PIX, method: l_int32, debugflag: l_int32) -> *mut NUMA;
}
extern "C" {
    pub fn pixLocateBarcodes(
        pixs: *mut PIX,
        thresh: l_int32,
        ppixb: *mut *mut PIX,
        ppixm: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn pixDeskewBarcode(
        pixs: *mut PIX,
        pixb: *mut PIX,
        box_: *mut BOX,
        margin: l_int32,
        threshold: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBarcodeWidths1(
        pixs: *mut PIX,
        thresh: l_float32,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeWidths2(
        pixs: *mut PIX,
        thresh: l_float32,
        pwidth: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixExtractBarcodeCrossings(
        pixs: *mut PIX,
        thresh: l_float32,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWidth(
        nas: *mut NUMA,
        binfract: l_float32,
        pnaehist: *mut *mut NUMA,
        pnaohist: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn numaQuantizeCrossingsByWindow(
        nas: *mut NUMA,
        ratio: l_float32,
        pwidth: *mut l_float32,
        pfirstloc: *mut l_float32,
        pnac: *mut *mut NUMA,
        debugflag: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaReadFiles(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaReadFilesSA(sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn pixRead(filename: *const ::std::os::raw::c_char) -> *mut PIX;
}
extern "C" {
    pub fn pixReadWithHint(filename: *const ::std::os::raw::c_char, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadIndexed(sa: *mut SARRAY, index: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStream(fp: *mut FILE, hint: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeader(
        filename: *const ::std::os::raw::c_char,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn findFileFormat(filename: *const ::std::os::raw::c_char, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn findFileFormatStream(fp: *mut FILE, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn findFileFormatBuffer(buf: *const l_uint8, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn fileFormatIsTiff(fp: *mut FILE) -> l_int32;
}
extern "C" {
    pub fn pixReadMem(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixReadHeaderMem(
        data: *const l_uint8,
        size: size_t,
        pformat: *mut l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn writeImageFileInfo(
        filename: *const ::std::os::raw::c_char,
        fpout: *mut FILE,
        headeronly: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn ioFormatTest(filename: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn recogCreateFromRecog(
        recs: *mut L_RECOG,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixa(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreateFromPixaNoFinish(
        pixa: *mut PIXA,
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogCreate(
        scalew: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        threshold: l_int32,
        maxyshift: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogDestroy(precog: *mut *mut L_RECOG);
}
extern "C" {
    pub fn recogGetCount(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogSetParams(
        recog: *mut L_RECOG,
        type_: l_int32,
        min_nopad: l_int32,
        max_wh_ratio: l_float32,
        max_ht_ratio: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogGetClassIndex(
        recog: *mut L_RECOG,
        val: l_int32,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogStringToIndex(
        recog: *mut L_RECOG,
        text: *mut ::std::os::raw::c_char,
        pindex: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogGetClassString(
        recog: *mut L_RECOG,
        index: l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_convertCharstrToInt(str_: *const ::std::os::raw::c_char, pval: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn recogRead(filename: *const ::std::os::raw::c_char) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadStream(fp: *mut FILE) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogReadMem(data: *const l_uint8, size: size_t) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogWrite(filename: *const ::std::os::raw::c_char, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogWriteStream(fp: *mut FILE, recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, recog: *mut L_RECOG)
        -> l_ok;
}
extern "C" {
    pub fn recogExtractPixa(recog: *mut L_RECOG) -> *mut PIXA;
}
extern "C" {
    pub fn recogDecode(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        nlevels: l_int32,
        ppixdb: *mut *mut PIX,
    ) -> *mut BOXA;
}
extern "C" {
    pub fn recogCreateDid(recog: *mut L_RECOG, pixs: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogDestroyDid(recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn recogDidExists(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogGetDid(recog: *mut L_RECOG) -> *mut L_RDID;
}
extern "C" {
    pub fn recogSetChannelParams(recog: *mut L_RECOG, nlevels: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyMultiple(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        ppixdb: *mut *mut PIX,
        debugsplit: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogSplitIntoCharacters(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        minh: l_int32,
        skipsplit: l_int32,
        pboxa: *mut *mut BOXA,
        ppixa: *mut *mut PIXA,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogCorrelationBestRow(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pboxa: *mut *mut BOXA,
        pnascore: *mut *mut NUMA,
        pnaindex: *mut *mut NUMA,
        psachar: *mut *mut SARRAY,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogCorrelationBestChar(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        pbox: *mut *mut BOX,
        pscore: *mut l_float32,
        pindex: *mut l_int32,
        pcharstr: *mut *mut ::std::os::raw::c_char,
        ppixdb: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyPixa(recog: *mut L_RECOG, pixa: *mut PIXA, ppixdb: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogIdentifyPix(recog: *mut L_RECOG, pixs: *mut PIX, ppixdb: *mut *mut PIX) -> l_ok;
}
extern "C" {
    pub fn recogSkipIdentify(recog: *mut L_RECOG) -> l_ok;
}
extern "C" {
    pub fn rchaDestroy(prcha: *mut *mut L_RCHA);
}
extern "C" {
    pub fn rchDestroy(prch: *mut *mut L_RCH);
}
extern "C" {
    pub fn rchaExtract(
        rcha: *mut L_RCHA,
        pnaindex: *mut *mut NUMA,
        pnascore: *mut *mut NUMA,
        psatext: *mut *mut SARRAY,
        pnasample: *mut *mut NUMA,
        pnaxloc: *mut *mut NUMA,
        pnayloc: *mut *mut NUMA,
        pnawidth: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn rchExtract(
        rch: *mut L_RCH,
        pindex: *mut l_int32,
        pscore: *mut l_float32,
        ptext: *mut *mut ::std::os::raw::c_char,
        psample: *mut l_int32,
        pxloc: *mut l_int32,
        pyloc: *mut l_int32,
        pwidth: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogProcessToIdentify(recog: *mut L_RECOG, pixs: *mut PIX, pad: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn recogExtractNumbers(
        recog: *mut L_RECOG,
        boxas: *mut BOXA,
        scorethresh: l_float32,
        spacethresh: l_int32,
        pbaa: *mut *mut BOXAA,
        pnaa: *mut *mut NUMAA,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn showExtractNumbers(
        pixs: *mut PIX,
        sa: *mut SARRAY,
        baa: *mut BOXAA,
        naa: *mut NUMAA,
        ppixdb: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        debug: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogProcessLabeled(
        recog: *mut L_RECOG,
        pixs: *mut PIX,
        box_: *mut BOX,
        text: *mut ::std::os::raw::c_char,
        ppix: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn recogAddSample(recog: *mut L_RECOG, pix: *mut PIX, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogModifyTemplate(recog: *mut L_RECOG, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn recogAverageSamples(precog: *mut *mut L_RECOG, debug: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixaAccumulateSamples(
        pixa: *mut PIXA,
        pta: *mut PTA,
        ppixd: *mut *mut PIX,
        px: *mut l_float32,
        py: *mut l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn recogTrainingFinished(
        precog: *mut *mut L_RECOG,
        modifyflag: l_int32,
        minsize: l_int32,
        minfract: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogFilterPixaBySize(
        pixas: *mut PIXA,
        setsize: l_int32,
        maxkeep: l_int32,
        max_ht_ratio: l_float32,
        pna: *mut *mut NUMA,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogSortPixaByClass(pixa: *mut PIXA, setsize: l_int32) -> *mut PIXAA;
}
extern "C" {
    pub fn recogRemoveOutliers1(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveOutliers1(
        pixas: *mut PIXA,
        minscore: l_float32,
        mintarget: l_int32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogRemoveOutliers2(
        precog: *mut *mut L_RECOG,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaRemoveOutliers2(
        pixas: *mut PIXA,
        minscore: l_float32,
        minsize: l_int32,
        ppixsave: *mut *mut PIX,
        ppixrem: *mut *mut PIX,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogTrainFromBoot(
        recogboot: *mut L_RECOG,
        pixas: *mut PIXA,
        minscore: l_float32,
        threshold: l_int32,
        debug: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn recogPadDigitTrainingSet(
        precog: *mut *mut L_RECOG,
        scaleh: l_int32,
        linew: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogIsPaddingNeeded(recog: *mut L_RECOG, psa: *mut *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn recogAddDigitPadTemplates(recog: *mut L_RECOG, sa: *mut SARRAY) -> *mut PIXA;
}
extern "C" {
    pub fn recogMakeBootDigitRecog(
        nsamp: l_int32,
        scaleh: l_int32,
        linew: l_int32,
        maxyshift: l_int32,
        debug: l_int32,
    ) -> *mut L_RECOG;
}
extern "C" {
    pub fn recogMakeBootDigitTemplates(nsamp: l_int32, debug: l_int32) -> *mut PIXA;
}
extern "C" {
    pub fn recogShowContent(
        fp: *mut FILE,
        recog: *mut L_RECOG,
        index: l_int32,
        display: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogDebugAverages(precog: *mut *mut L_RECOG, debug: l_int32) -> l_ok;
}
extern "C" {
    pub fn recogShowAverageTemplates(recog: *mut L_RECOG) -> l_int32;
}
extern "C" {
    pub fn recogShowMatchesInRange(
        recog: *mut L_RECOG,
        pixa: *mut PIXA,
        minscore: l_float32,
        maxscore: l_float32,
        display: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn recogShowMatch(
        recog: *mut L_RECOG,
        pix1: *mut PIX,
        pix2: *mut PIX,
        box_: *mut BOX,
        index: l_int32,
        score: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn regTestSetup(
        argc: l_int32,
        argv: *mut *mut ::std::os::raw::c_char,
        prp: *mut *mut L_REGPARAMS,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCleanup(rp: *mut L_REGPARAMS) -> l_ok;
}
extern "C" {
    pub fn regTestCompareValues(
        rp: *mut L_REGPARAMS,
        val1: l_float32,
        val2: l_float32,
        delta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCompareStrings(
        rp: *mut L_REGPARAMS,
        string1: *mut l_uint8,
        bytes1: size_t,
        string2: *mut l_uint8,
        bytes2: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestComparePix(rp: *mut L_REGPARAMS, pix1: *mut PIX, pix2: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn regTestCompareSimilarPix(
        rp: *mut L_REGPARAMS,
        pix1: *mut PIX,
        pix2: *mut PIX,
        mindiff: l_int32,
        maxfract: l_float32,
        printstats: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestCheckFile(rp: *mut L_REGPARAMS, localname: *const ::std::os::raw::c_char)
        -> l_ok;
}
extern "C" {
    pub fn regTestCompareFiles(rp: *mut L_REGPARAMS, index1: l_int32, index2: l_int32) -> l_ok;
}
extern "C" {
    pub fn regTestWritePixAndCheck(rp: *mut L_REGPARAMS, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn regTestWriteDataAndCheck(
        rp: *mut L_REGPARAMS,
        data: *mut ::std::os::raw::c_void,
        nbytes: size_t,
        ext: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn regTestGenLocalFilename(
        rp: *mut L_REGPARAMS,
        index: l_int32,
        format: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixRasterop(
        pixd: *mut PIX,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        pixs: *mut PIX,
        sx: l_int32,
        sy: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropVip(
        pixd: *mut PIX,
        bx: l_int32,
        bw: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropHip(
        pixd: *mut PIX,
        by: l_int32,
        bh: l_int32,
        hshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixTranslate(
        pixd: *mut PIX,
        pixs: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRasteropIP(
        pixd: *mut PIX,
        hshift: l_int32,
        vshift: l_int32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRasteropFullImage(pixd: *mut PIX, pixs: *mut PIX, op: l_int32) -> l_ok;
}
extern "C" {
    pub fn rasteropUniLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
    );
}
extern "C" {
    pub fn rasteropLow(
        datad: *mut l_uint32,
        dpixw: l_int32,
        dpixh: l_int32,
        depth: l_int32,
        dwpl: l_int32,
        dx: l_int32,
        dy: l_int32,
        dw: l_int32,
        dh: l_int32,
        op: l_int32,
        datas: *mut l_uint32,
        spixw: l_int32,
        spixh: l_int32,
        swpl: l_int32,
        sx: l_int32,
        sy: l_int32,
    );
}
extern "C" {
    pub fn rasteropVipLow(
        data: *mut l_uint32,
        pixw: l_int32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        x: l_int32,
        w: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn rasteropHipLow(
        data: *mut l_uint32,
        pixh: l_int32,
        depth: l_int32,
        wpl: l_int32,
        y: l_int32,
        h: l_int32,
        shift: l_int32,
    );
}
extern "C" {
    pub fn pixRotate(
        pixs: *mut PIX,
        angle: l_float32,
        type_: l_int32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixEmbedForRotation(
        pixs: *mut PIX,
        angle: l_float32,
        incolor: l_int32,
        width: l_int32,
        height: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBySampling(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateBinaryNice(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateWithAlpha(
        pixs: *mut PIX,
        angle: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAM(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColor(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGray(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMCorner(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorCorner(pixs: *mut PIX, angle: l_float32, fillval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMGrayCorner(pixs: *mut PIX, angle: l_float32, grayval: l_uint8) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateAMColorFast(pixs: *mut PIX, angle: l_float32, colorval: l_uint32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateOrth(pixs: *mut PIX, quads: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate180(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate90(pixs: *mut PIX, direction: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipLR(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixFlipTB(pixd: *mut PIX, pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate2Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotate3Shear(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearIP(
        pixs: *mut PIX,
        xcen: l_int32,
        ycen: l_int32,
        angle: l_float32,
        incolor: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRotateShearCenter(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRotateShearCenterIP(pixs: *mut PIX, angle: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixStrokeWidthTransform(
        pixs: *mut PIX,
        color: l_int32,
        depth: l_int32,
        nangles: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRunlengthTransform(
        pixs: *mut PIX,
        color: l_int32,
        direction: l_int32,
        depth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindHorizontalRuns(
        pix: *mut PIX,
        y: l_int32,
        xstart: *mut l_int32,
        xend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindVerticalRuns(
        pix: *mut PIX,
        x: l_int32,
        ystart: *mut l_int32,
        yend: *mut l_int32,
        pn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindMaxRuns(pix: *mut PIX, direction: l_int32, pnastart: *mut *mut NUMA)
        -> *mut NUMA;
}
extern "C" {
    pub fn pixFindMaxHorizontalRunOnLine(
        pix: *mut PIX,
        y: l_int32,
        pxstart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindMaxVerticalRunOnLine(
        pix: *mut PIX,
        x: l_int32,
        pystart: *mut l_int32,
        psize: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn runlengthMembershipOnLine(
        buffer: *mut l_int32,
        size: l_int32,
        depth: l_int32,
        start: *mut l_int32,
        end: *mut l_int32,
        n: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn makeMSBitLocTab(bitval: l_int32) -> *mut l_int32;
}
extern "C" {
    pub fn sarrayCreate(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateInitialized(
        n: l_int32,
        initstr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateWordsFromString(string: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayCreateLinesFromString(
        string: *const ::std::os::raw::c_char,
        blankflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayDestroy(psa: *mut *mut SARRAY);
}
extern "C" {
    pub fn sarrayCopy(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayClone(sa: *mut SARRAY) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayAddString(
        sa: *mut SARRAY,
        string: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayRemoveString(sa: *mut SARRAY, index: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayReplaceString(
        sa: *mut SARRAY,
        index: l_int32,
        newstr: *mut ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayClear(sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayGetCount(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayGetArray(
        sa: *mut SARRAY,
        pnalloc: *mut l_int32,
        pn: *mut l_int32,
    ) -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayGetString(
        sa: *mut SARRAY,
        index: l_int32,
        copyflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayGetRefcount(sa: *mut SARRAY) -> l_int32;
}
extern "C" {
    pub fn sarrayChangeRefcount(sa: *mut SARRAY, delta: l_int32) -> l_ok;
}
extern "C" {
    pub fn sarrayToString(sa: *mut SARRAY, addnlflag: l_int32) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayToStringRange(
        sa: *mut SARRAY,
        first: l_int32,
        nstrings: l_int32,
        addnlflag: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn sarrayConcatUniformly(sa: *mut SARRAY, n: l_int32, addnlflag: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayJoin(sa1: *mut SARRAY, sa2: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayAppendRange(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        start: l_int32,
        end: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayPadToSameSize(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        padstring: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayConvertWordsToLines(sa: *mut SARRAY, linesize: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySplitString(
        sa: *mut SARRAY,
        str_: *const ::std::os::raw::c_char,
        separators: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn sarraySelectBySubstring(
        sain: *mut SARRAY,
        substr: *const ::std::os::raw::c_char,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySelectRange(sain: *mut SARRAY, first: l_int32, last: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayParseRange(
        sa: *mut SARRAY,
        start: l_int32,
        pactualstart: *mut l_int32,
        pend: *mut l_int32,
        pnewstart: *mut l_int32,
        substr: *const ::std::os::raw::c_char,
        loc: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn sarrayRead(filename: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadStream(fp: *mut FILE) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayReadMem(data: *const l_uint8, size: size_t) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayWrite(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteStream(fp: *mut FILE, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteStderr(sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayWriteMem(pdata: *mut *mut l_uint8, psize: *mut size_t, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayAppend(filename: *const ::std::os::raw::c_char, sa: *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn getNumberedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getSortedPathnamesInDirectory(
        dirname: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        first: l_int32,
        nfiles: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn convertSortedToNumberedPathnames(
        sa: *mut SARRAY,
        numpre: l_int32,
        numpost: l_int32,
        maxnum: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn getFilenamesInDirectory(dirname: *const ::std::os::raw::c_char) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySort(saout: *mut SARRAY, sain: *mut SARRAY, sortorder: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarraySortByIndex(sain: *mut SARRAY, naindex: *mut NUMA) -> *mut SARRAY;
}
extern "C" {
    pub fn stringCompareLexical(
        str1: *const ::std::os::raw::c_char,
        str2: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_asetCreateFromSarray(sa: *mut SARRAY) -> *mut L_ASET;
}
extern "C" {
    pub fn sarrayRemoveDupsByAset(sas: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayUnionByAset(sa1: *mut SARRAY, sa2: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayIntersectionByAset(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        psad: *mut *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn l_hmapCreateFromSarray(sa: *mut SARRAY) -> *mut L_HASHMAP;
}
extern "C" {
    pub fn sarrayRemoveDupsByHmap(
        sas: *mut SARRAY,
        psad: *mut *mut SARRAY,
        phmap: *mut *mut L_HASHMAP,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayUnionByHmap(sa1: *mut SARRAY, sa2: *mut SARRAY, psad: *mut *mut SARRAY) -> l_ok;
}
extern "C" {
    pub fn sarrayIntersectionByHmap(
        sa1: *mut SARRAY,
        sa2: *mut SARRAY,
        psad: *mut *mut SARRAY,
    ) -> l_ok;
}
extern "C" {
    pub fn sarrayGenerateIntegers(n: l_int32) -> *mut SARRAY;
}
extern "C" {
    pub fn sarrayLookupCSKV(
        sa: *mut SARRAY,
        keystring: *const ::std::os::raw::c_char,
        pvalstring: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScale(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSizeRel(pixs: *mut PIX, delw: l_int32, delh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToResolution(
        pixs: *mut PIX,
        target: l_float32,
        assumed: l_float32,
        pscalefact: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGeneral(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        sharpfract: l_float32,
        sharpwidth: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColorLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleColor4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayLI(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLI(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray2xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIThresh(pixs: *mut PIX, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGray4xLIDither(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySampling(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBySamplingToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleByIntSampling(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGrayFast(pixs: *mut PIX, factor: l_int32, color: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayToBinaryFast(pixs: *mut PIX, factor: l_int32, thresh: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmooth(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleSmoothToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleRGBToGray2(
        pixs: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap(pix: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMap2(pix: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAreaMapToSize(pixs: *mut PIX, wd: l_int32, hd: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleBinary(pixs: *mut PIX, scalex: l_float32, scaley: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayFast(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray2(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray3(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray4(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray6(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray8(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGray16(pixs: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleToGrayMipmap(pixs: *mut PIX, scalefactor: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleMipmap(pixs1: *mut PIX, pixs2: *mut PIX, scale: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixExpandReplicate(pixs: *mut PIX, factor: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax(
        pixs: *mut PIX,
        xfact: l_int32,
        yfact: l_int32,
        type_: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayMinMax2(pixs: *mut PIX, type_: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRankCascade(
        pixs: *mut PIX,
        level1: l_int32,
        level2: l_int32,
        level3: l_int32,
        level4: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleGrayRank2(pixs: *mut PIX, rank: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixScaleAndTransferAlpha(
        pixd: *mut PIX,
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixScaleWithAlpha(
        pixs: *mut PIX,
        scalex: l_float32,
        scaley: l_float32,
        pixg: *mut PIX,
        fract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinary(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillBinaryRestricted(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        xmax: l_int32,
        ymax: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHolesByFilling(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillClosedBorders(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixExtractBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixRemoveBorderConnComps(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillBgFromBorder(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFillHolesToBoundingRect(
        pixs: *mut PIX,
        minsize: l_int32,
        maxhfract: l_float32,
        minfgfract: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedfillGray(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayInv(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGraySimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayInvSimple(pixs: *mut PIX, pixm: *mut PIX, connectivity: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixSeedfillGrayBasin(
        pixb: *mut PIX,
        pixm: *mut PIX,
        delta: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDistanceFunction(
        pixs: *mut PIX,
        connectivity: l_int32,
        outdepth: l_int32,
        boundcond: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSeedspread(pixs: *mut PIX, connectivity: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixLocalExtrema(
        pixs: *mut PIX,
        maxmin: l_int32,
        minmax: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSelectedLocalExtrema(
        pixs: *mut PIX,
        mindist: l_int32,
        ppixmin: *mut *mut PIX,
        ppixmax: *mut *mut PIX,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindEqualValues(pixs1: *mut PIX, pixs2: *mut PIX) -> *mut PIX;
}
extern "C" {
    pub fn pixSelectMinInConnComp(
        pixs: *mut PIX,
        pixm: *mut PIX,
        ppta: *mut *mut PTA,
        pnav: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixRemoveSeededComponents(
        pixd: *mut PIX,
        pixs: *mut PIX,
        pixm: *mut PIX,
        connectivity: l_int32,
        bordersize: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaCreate(n: l_int32) -> *mut SELA;
}
extern "C" {
    pub fn selaDestroy(psela: *mut *mut SELA);
}
extern "C" {
    pub fn selCreate(
        height: l_int32,
        width: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selDestroy(psel: *mut *mut SEL);
}
extern "C" {
    pub fn selCopy(sel: *mut SEL) -> *mut SEL;
}
extern "C" {
    pub fn selCreateBrick(
        h: l_int32,
        w: l_int32,
        cy: l_int32,
        cx: l_int32,
        type_: l_int32,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateComb(factor1: l_int32, factor2: l_int32, direction: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn create2dIntArray(sy: l_int32, sx: l_int32) -> *mut *mut l_int32;
}
extern "C" {
    pub fn selaAddSel(
        sela: *mut SELA,
        sel: *mut SEL,
        selname: *const ::std::os::raw::c_char,
        copyflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selaGetCount(sela: *mut SELA) -> l_int32;
}
extern "C" {
    pub fn selaGetSel(sela: *mut SELA, i: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selGetName(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selSetName(sel: *mut SEL, name: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn selaFindSelByName(
        sela: *mut SELA,
        name: *const ::std::os::raw::c_char,
        pindex: *mut l_int32,
        psel: *mut *mut SEL,
    ) -> l_ok;
}
extern "C" {
    pub fn selGetElement(sel: *mut SEL, row: l_int32, col: l_int32, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn selSetElement(sel: *mut SEL, row: l_int32, col: l_int32, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn selGetParameters(
        sel: *mut SEL,
        psy: *mut l_int32,
        psx: *mut l_int32,
        pcy: *mut l_int32,
        pcx: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selSetOrigin(sel: *mut SEL, cy: l_int32, cx: l_int32) -> l_ok;
}
extern "C" {
    pub fn selGetTypeAtOrigin(sel: *mut SEL, ptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn selaGetBrickName(
        sela: *mut SELA,
        hsize: l_int32,
        vsize: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaGetCombName(
        sela: *mut SELA,
        size: l_int32,
        direction: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getCompositeParameters(
        size: l_int32,
        psize1: *mut l_int32,
        psize2: *mut l_int32,
        pnameh1: *mut *mut ::std::os::raw::c_char,
        pnameh2: *mut *mut ::std::os::raw::c_char,
        pnamev1: *mut *mut ::std::os::raw::c_char,
        pnamev2: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn selaGetSelnames(sela: *mut SELA) -> *mut SARRAY;
}
extern "C" {
    pub fn selFindMaxTranslations(
        sel: *mut SEL,
        pxp: *mut l_int32,
        pyp: *mut l_int32,
        pxn: *mut l_int32,
        pyn: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn selRotateOrth(sel: *mut SEL, quads: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn selaRead(fname: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selaReadStream(fp: *mut FILE) -> *mut SELA;
}
extern "C" {
    pub fn selRead(fname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selReadStream(fp: *mut FILE) -> *mut SEL;
}
extern "C" {
    pub fn selaWrite(fname: *const ::std::os::raw::c_char, sela: *mut SELA) -> l_ok;
}
extern "C" {
    pub fn selaWriteStream(fp: *mut FILE, sela: *mut SELA) -> l_ok;
}
extern "C" {
    pub fn selWrite(fname: *const ::std::os::raw::c_char, sel: *mut SEL) -> l_ok;
}
extern "C" {
    pub fn selWriteStream(fp: *mut FILE, sel: *mut SEL) -> l_ok;
}
extern "C" {
    pub fn selCreateFromString(
        text: *const ::std::os::raw::c_char,
        h: l_int32,
        w: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selPrintToString(sel: *mut SEL) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn selaCreateFromFile(filename: *const ::std::os::raw::c_char) -> *mut SELA;
}
extern "C" {
    pub fn selCreateFromPta(
        pta: *mut PTA,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromPix(
        pix: *mut PIX,
        cy: l_int32,
        cx: l_int32,
        name: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selReadFromColorImage(pathname: *const ::std::os::raw::c_char) -> *mut SEL;
}
extern "C" {
    pub fn selCreateFromColorPix(
        pixs: *mut PIX,
        selname: *const ::std::os::raw::c_char,
    ) -> *mut SEL;
}
extern "C" {
    pub fn selaCreateFromColorPixa(pixa: *mut PIXA, sa: *mut SARRAY) -> *mut SELA;
}
extern "C" {
    pub fn selDisplayInPix(sel: *mut SEL, size: l_int32, gthick: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn selaDisplayInPix(
        sela: *mut SELA,
        size: l_int32,
        gthick: l_int32,
        spacing: l_int32,
        ncols: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn selaAddBasic(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddHitMiss(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaLinear(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddDwaCombs(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selaAddCrossJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn selaAddTJunctions(
        sela: *mut SELA,
        hlsize: l_float32,
        mdist: l_float32,
        norient: l_int32,
        debugflag: l_int32,
    ) -> *mut SELA;
}
extern "C" {
    pub fn sela4ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn sela4and8ccThin(sela: *mut SELA) -> *mut SELA;
}
extern "C" {
    pub fn selMakePlusSign(size: l_int32, linewidth: l_int32) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelWithRuns(
        pixs: *mut PIX,
        nhlines: l_int32,
        nvlines: l_int32,
        distance: l_int32,
        minlength: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelRandom(
        pixs: *mut PIX,
        hitfract: l_float32,
        missfract: l_float32,
        distance: l_int32,
        toppix: l_int32,
        botpix: l_int32,
        leftpix: l_int32,
        rightpix: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGenerateSelBoundary(
        pixs: *mut PIX,
        hitdist: l_int32,
        missdist: l_int32,
        hitskip: l_int32,
        missskip: l_int32,
        topflag: l_int32,
        botflag: l_int32,
        leftflag: l_int32,
        rightflag: l_int32,
        ppixe: *mut *mut PIX,
    ) -> *mut SEL;
}
extern "C" {
    pub fn pixGetRunCentersOnLine(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        minlength: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixGetRunsOnLine(
        pixs: *mut PIX,
        x1: l_int32,
        y1: l_int32,
        x2: l_int32,
        y2: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixSubsampleBoundaryPixels(pixs: *mut PIX, skip: l_int32) -> *mut PTA;
}
extern "C" {
    pub fn adjacentOnPixelInRaster(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        pxa: *mut l_int32,
        pya: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixDisplayHitMissSel(
        pixs: *mut PIX,
        sel: *mut SEL,
        scalefactor: l_int32,
        hitcolor: l_uint32,
        misscolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShear(
        pixd: *mut PIX,
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCorner(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearCenter(
        pixd: *mut PIX,
        pixs: *mut PIX,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixHShearIP(pixs: *mut PIX, yloc: l_int32, radang: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixVShearIP(pixs: *mut PIX, xloc: l_int32, radang: l_float32, incolor: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixHShearLI(
        pixs: *mut PIX,
        yloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixVShearLI(
        pixs: *mut PIX,
        xloc: l_int32,
        radang: l_float32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewBoth(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskew(pixs: *mut PIX, redsearch: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkewAndDeskew(
        pixs: *mut PIX,
        redsearch: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixDeskewGeneral(
        pixs: *mut PIX,
        redsweep: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        redsearch: l_int32,
        thresh: l_int32,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixFindSkew(pixs: *mut PIX, pangle: *mut l_float32, pconf: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweep(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        reduction: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearch(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScore(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewSweepAndSearchScorePivot(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        pendscore: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweepcenter: l_float32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        pivot: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixFindSkewOrthogonalRange(
        pixs: *mut PIX,
        pangle: *mut l_float32,
        pconf: *mut l_float32,
        redsweep: l_int32,
        redsearch: l_int32,
        sweeprange: l_float32,
        sweepdelta: l_float32,
        minbsdelta: l_float32,
        confprior: l_float32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindDifferentialSquareSum(pixs: *mut PIX, psum: *mut l_float32) -> l_ok;
}
extern "C" {
    pub fn pixFindNormalizedSquareSum(
        pixs: *mut PIX,
        phratio: *mut l_float32,
        pvratio: *mut l_float32,
        pfract: *mut l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamSpix(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderSpix(
        filename: *const ::std::os::raw::c_char,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderSpix(
        fp: *mut FILE,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn sreadHeaderSpix(
        data: *const l_uint32,
        size: size_t,
        pwidth: *mut l_int32,
        pheight: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        piscmap: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamSpix(fp: *mut FILE, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixReadMemSpix(data: *const l_uint8, size: size_t) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteMemSpix(pdata: *mut *mut l_uint8, psize: *mut size_t, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixSerializeToMemory(
        pixs: *mut PIX,
        pdata: *mut *mut l_uint32,
        pnbytes: *mut size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDeserializeFromMemory(data: *const l_uint32, nbytes: size_t) -> *mut PIX;
}
extern "C" {
    pub fn lstackCreate(n: l_int32) -> *mut L_STACK;
}
extern "C" {
    pub fn lstackDestroy(plstack: *mut *mut L_STACK, freeflag: l_int32);
}
extern "C" {
    pub fn lstackAdd(lstack: *mut L_STACK, item: *mut ::std::os::raw::c_void) -> l_ok;
}
extern "C" {
    pub fn lstackRemove(lstack: *mut L_STACK) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lstackGetCount(lstack: *mut L_STACK) -> l_int32;
}
extern "C" {
    pub fn lstackPrint(fp: *mut FILE, lstack: *mut L_STACK) -> l_ok;
}
extern "C" {
    pub fn strcodeCreate(fileno: l_int32) -> *mut L_STRCODE;
}
extern "C" {
    pub fn strcodeCreateFromFile(
        filein: *const ::std::os::raw::c_char,
        fileno: l_int32,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn strcodeGenerate(
        strcode: *mut L_STRCODE,
        filein: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn strcodeFinalize(
        pstrcode: *mut *mut L_STRCODE,
        outdir: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn l_getStructStrFromFile(
        filename: *const ::std::os::raw::c_char,
        field: l_int32,
        pstr: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn pixFindStrokeLength(pixs: *mut PIX, tab8: *mut l_int32, plength: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn pixFindStrokeWidth(
        pixs: *mut PIX,
        thresh: l_float32,
        tab8: *mut l_int32,
        pwidth: *mut l_float32,
        pnahisto: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaFindStrokeWidth(
        pixa: *mut PIXA,
        thresh: l_float32,
        tab8: *mut l_int32,
        debug: l_int32,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn pixaModifyStrokeWidth(pixas: *mut PIXA, targetw: l_float32) -> *mut PIXA;
}
extern "C" {
    pub fn pixModifyStrokeWidth(pixs: *mut PIX, width: l_float32, targetw: l_float32) -> *mut PIX;
}
extern "C" {
    pub fn pixaSetStrokeWidth(
        pixas: *mut PIXA,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixSetStrokeWidth(
        pixs: *mut PIX,
        width: l_int32,
        thinfirst: l_int32,
        connectivity: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn sudokuReadFile(filename: *const ::std::os::raw::c_char) -> *mut l_int32;
}
extern "C" {
    pub fn sudokuReadString(str_: *const ::std::os::raw::c_char) -> *mut l_int32;
}
extern "C" {
    pub fn sudokuCreate(array: *mut l_int32) -> *mut L_SUDOKU;
}
extern "C" {
    pub fn sudokuDestroy(psud: *mut *mut L_SUDOKU);
}
extern "C" {
    pub fn sudokuSolve(sud: *mut L_SUDOKU) -> l_int32;
}
extern "C" {
    pub fn sudokuTestUniqueness(array: *mut l_int32, punique: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn sudokuGenerate(
        array: *mut l_int32,
        seed: l_int32,
        minelems: l_int32,
        maxtries: l_int32,
    ) -> *mut L_SUDOKU;
}
extern "C" {
    pub fn sudokuOutput(sud: *mut L_SUDOKU, arraytype: l_int32) -> l_int32;
}
extern "C" {
    pub fn pixAddSingleTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
        poverflow: *mut l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixAddTextlines(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixSetTextblock(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        wtext: l_int32,
        firstindent: l_int32,
        poverflow: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixSetTextline(
        pixs: *mut PIX,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        x0: l_int32,
        y0: l_int32,
        pwidth: *mut l_int32,
        poverflow: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaAddTextNumber(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        na: *mut NUMA,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddTextlines(
        pixas: *mut PIXA,
        bmf: *mut L_BMF,
        sa: *mut SARRAY,
        val: l_uint32,
        location: l_int32,
    ) -> *mut PIXA;
}
extern "C" {
    pub fn pixaAddPixWithText(
        pixa: *mut PIXA,
        pixs: *mut PIX,
        reduction: l_int32,
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        val: l_uint32,
        location: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn bmfGetLineStrings(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        maxw: l_int32,
        firstindent: l_int32,
        ph: *mut l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn bmfGetWordWidths(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        sa: *mut SARRAY,
    ) -> *mut NUMA;
}
extern "C" {
    pub fn bmfGetStringWidth(
        bmf: *mut L_BMF,
        textstr: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn splitStringToParagraphs(
        textstr: *mut ::std::os::raw::c_char,
        splitflag: l_int32,
    ) -> *mut SARRAY;
}
extern "C" {
    pub fn pixReadTiff(filename: *const ::std::os::raw::c_char, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadStreamTiff(fp: *mut FILE, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixWriteTiff(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteTiffCustom(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamTiff(fp: *mut FILE, pix: *mut PIX, comptype: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamTiffWA(
        fp: *mut FILE,
        pix: *mut PIX,
        comptype: l_int32,
        modestr: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadFromMultipageTiff(
        fname: *const ::std::os::raw::c_char,
        poffset: *mut size_t,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMultipageTiff(filename: *const ::std::os::raw::c_char) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMultipageTiff(fname: *const ::std::os::raw::c_char, pixa: *mut PIXA) -> l_ok;
}
extern "C" {
    pub fn writeMultipageTiff(
        dirin: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn writeMultipageTiffSA(sa: *mut SARRAY, fileout: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn fprintTiffInfo(fpout: *mut FILE, tiffile: *const ::std::os::raw::c_char) -> l_ok;
}
extern "C" {
    pub fn tiffGetCount(fp: *mut FILE, pn: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn getTiffResolution(fp: *mut FILE, pxres: *mut l_int32, pyres: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn readHeaderTiff(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn freadHeaderTiff(
        fp: *mut FILE,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemTiff(
        cdata: *const l_uint8,
        size: size_t,
        n: l_int32,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pbps: *mut l_int32,
        pspp: *mut l_int32,
        pres: *mut l_int32,
        pcmap: *mut l_int32,
        pformat: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn findTiffCompression(fp: *mut FILE, pcomptype: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn extractG4DataFromFile(
        filein: *const ::std::os::raw::c_char,
        pdata: *mut *mut l_uint8,
        pnbytes: *mut size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pminisblack: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadMemTiff(cdata: *const l_uint8, size: size_t, n: l_int32) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemFromMultipageTiff(
        cdata: *const l_uint8,
        size: size_t,
        poffset: *mut size_t,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixaReadMemMultipageTiff(data: *const l_uint8, size: size_t) -> *mut PIXA;
}
extern "C" {
    pub fn pixaWriteMemMultipageTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pixa: *mut PIXA,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemTiff(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        comptype: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemTiffCustom(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        comptype: l_int32,
        natags: *mut NUMA,
        savals: *mut SARRAY,
        satypes: *mut SARRAY,
        nasizes: *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn setMsgSeverity(newsev: l_int32) -> l_int32;
}
extern "C" {
    pub fn returnErrorInt(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        ival: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn returnErrorFloat(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        fval: l_float32,
    ) -> l_float32;
}
extern "C" {
    pub fn returnErrorPtr(
        msg: *const ::std::os::raw::c_char,
        procname: *const ::std::os::raw::c_char,
        pval: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn leptSetStderrHandler(
        handler: ::std::option::Option<unsafe extern "C" fn(arg1: *const ::std::os::raw::c_char)>,
    );
}
extern "C" {
    pub fn lept_stderr(fmt: *const ::std::os::raw::c_char, ...);
}
extern "C" {
    pub fn filesAreIdentical(
        fname1: *const ::std::os::raw::c_char,
        fname2: *const ::std::os::raw::c_char,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn convertOnLittleEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnBigEnd16(shortin: l_uint16) -> l_uint16;
}
extern "C" {
    pub fn convertOnLittleEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertOnBigEnd32(wordin: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn fileCorruptByDeletion(
        filein: *const ::std::os::raw::c_char,
        loc: l_float32,
        size: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileCorruptByMutation(
        filein: *const ::std::os::raw::c_char,
        loc: l_float32,
        size: l_float32,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileReplaceBytes(
        filein: *const ::std::os::raw::c_char,
        start: l_int32,
        nbytes: l_int32,
        newdata: *mut l_uint8,
        newsize: size_t,
        fileout: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn genRandomIntOnInterval(
        start: l_int32,
        end: l_int32,
        seed: l_int32,
        pval: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn lept_roundftoi(fval: l_float32) -> l_int32;
}
extern "C" {
    pub fn l_hashStringToUint64(str_: *const ::std::os::raw::c_char, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn l_hashStringToUint64Fast(
        str_: *const ::std::os::raw::c_char,
        phash: *mut l_uint64,
    ) -> l_ok;
}
extern "C" {
    pub fn l_hashPtToUint64(x: l_int32, y: l_int32, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn l_hashFloat64ToUint64(val: l_float64, phash: *mut l_uint64) -> l_ok;
}
extern "C" {
    pub fn findNextLargerPrime(start: l_int32, pprime: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn lept_isPrime(n: l_uint64, pis_prime: *mut l_int32, pfactor: *mut l_uint32) -> l_ok;
}
extern "C" {
    pub fn convertIntToGrayCode(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn convertGrayCodeToInt(val: l_uint32) -> l_uint32;
}
extern "C" {
    pub fn getLeptonicaVersion() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn startTimer();
}
extern "C" {
    pub fn stopTimer() -> l_float32;
}
extern "C" {
    pub fn startTimerNested() -> L_TIMER;
}
extern "C" {
    pub fn stopTimerNested(rusage_start: L_TIMER) -> l_float32;
}
extern "C" {
    pub fn l_getCurrentTime(sec: *mut l_int32, usec: *mut l_int32);
}
extern "C" {
    pub fn startWallTimer() -> *mut L_WALLTIMER;
}
extern "C" {
    pub fn stopWallTimer(ptimer: *mut *mut L_WALLTIMER) -> l_float32;
}
extern "C" {
    pub fn l_getFormattedDate() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringNew(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringCopy(
        dest: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        n: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn stringCopySegment(
        src: *const ::std::os::raw::c_char,
        start: l_int32,
        nbytes: l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplace(
        pdest: *mut *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringLength(src: *const ::std::os::raw::c_char, size: size_t) -> l_int32;
}
extern "C" {
    pub fn stringCat(
        dest: *mut ::std::os::raw::c_char,
        size: size_t,
        src: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn stringConcatNew(
        first: *const ::std::os::raw::c_char,
        ...
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoin(
        src1: *const ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringJoinIP(
        psrc1: *mut *mut ::std::os::raw::c_char,
        src2: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringReverse(src: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtokSafe(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        psaveptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringSplitOnToken(
        cstr: *mut ::std::os::raw::c_char,
        seps: *const ::std::os::raw::c_char,
        phead: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn stringCheckForChars(
        src: *const ::std::os::raw::c_char,
        chars: *const ::std::os::raw::c_char,
        pfound: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn stringRemoveChars(
        src: *const ::std::os::raw::c_char,
        remchars: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        pcount: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringReplaceSubstr(
        src: *const ::std::os::raw::c_char,
        sub1: *const ::std::os::raw::c_char,
        sub2: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
        pfound: *mut l_int32,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stringFindEachSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn stringFindSubstr(
        src: *const ::std::os::raw::c_char,
        sub: *const ::std::os::raw::c_char,
        ploc: *mut l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn arrayReplaceEachSequence(
        datas: *const l_uint8,
        dataslen: size_t,
        seq: *const l_uint8,
        seqlen: size_t,
        newseq: *const l_uint8,
        newseqlen: size_t,
        pdatadlen: *mut size_t,
        pcount: *mut l_int32,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn arrayFindEachSequence(
        data: *const l_uint8,
        datalen: size_t,
        sequence: *const l_uint8,
        seqlen: size_t,
    ) -> *mut L_DNA;
}
extern "C" {
    pub fn arrayFindSequence(
        data: *const l_uint8,
        datalen: size_t,
        sequence: *const l_uint8,
        seqlen: size_t,
        poffset: *mut l_int32,
        pfound: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn reallocNew(
        pindata: *mut *mut ::std::os::raw::c_void,
        oldsize: size_t,
        newsize: size_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn l_binaryRead(
        filename: *const ::std::os::raw::c_char,
        pnbytes: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadStream(fp: *mut FILE, pnbytes: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelect(
        filename: *const ::std::os::raw::c_char,
        start: size_t,
        nbytes: size_t,
        pnread: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryReadSelectStream(
        fp: *mut FILE,
        start: size_t,
        nbytes: size_t,
        pnread: *mut size_t,
    ) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryWrite(
        filename: *const ::std::os::raw::c_char,
        operation: *const ::std::os::raw::c_char,
        data: *const ::std::os::raw::c_void,
        nbytes: size_t,
    ) -> l_ok;
}
extern "C" {
    pub fn nbytesInFile(filename: *const ::std::os::raw::c_char) -> size_t;
}
extern "C" {
    pub fn fnbytesInFile(fp: *mut FILE) -> size_t;
}
extern "C" {
    pub fn l_binaryCopy(datas: *const l_uint8, size: size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn l_binaryCompare(
        data1: *const l_uint8,
        size1: size_t,
        data2: *const l_uint8,
        size2: size_t,
        psame: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn fileCopy(
        srcfile: *const ::std::os::raw::c_char,
        newfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileConcatenate(
        srcfile: *const ::std::os::raw::c_char,
        destfile: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileAppendString(
        filename: *const ::std::os::raw::c_char,
        str_: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fileSplitLinesUniform(
        filename: *const ::std::os::raw::c_char,
        n: l_int32,
        save_empty: l_int32,
        rootpath: *const ::std::os::raw::c_char,
        ext: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn fopenReadStream(filename: *const ::std::os::raw::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fopenWriteStream(
        filename: *const ::std::os::raw::c_char,
        modestring: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fopenReadFromMemory(data: *const l_uint8, size: size_t) -> *mut FILE;
}
extern "C" {
    pub fn fopenWriteWinTempfile() -> *mut FILE;
}
extern "C" {
    pub fn lept_fopen(
        filename: *const ::std::os::raw::c_char,
        mode: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn lept_fclose(fp: *mut FILE) -> l_ok;
}
extern "C" {
    pub fn lept_calloc(nmemb: size_t, size: size_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lept_free(ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lept_mkdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_rmdir(subdir: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_direxists(dir: *const ::std::os::raw::c_char, pexists: *mut l_int32);
}
extern "C" {
    pub fn lept_rm_match(
        subdir: *const ::std::os::raw::c_char,
        substr: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rm(
        subdir: *const ::std::os::raw::c_char,
        tail: *const ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_rmfile(filepath: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn lept_mv(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn lept_cp(
        srcfile: *const ::std::os::raw::c_char,
        newdir: *const ::std::os::raw::c_char,
        newtail: *const ::std::os::raw::c_char,
        pnewpath: *mut *mut ::std::os::raw::c_char,
    ) -> l_int32;
}
extern "C" {
    pub fn callSystemDebug(cmd: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn splitPathAtDirectory(
        pathname: *const ::std::os::raw::c_char,
        pdir: *mut *mut ::std::os::raw::c_char,
        ptail: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn splitPathAtExtension(
        pathname: *const ::std::os::raw::c_char,
        pbasename: *mut *mut ::std::os::raw::c_char,
        pextension: *mut *mut ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn pathJoin(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn appendSubdirs(
        basedir: *const ::std::os::raw::c_char,
        subdirs: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn convertSepCharsInPath(path: *mut ::std::os::raw::c_char, type_: l_int32) -> l_ok;
}
extern "C" {
    pub fn genPathname(
        dir: *const ::std::os::raw::c_char,
        fname: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn makeTempDirname(
        result: *mut ::std::os::raw::c_char,
        nbytes: size_t,
        subdir: *const ::std::os::raw::c_char,
    ) -> l_ok;
}
extern "C" {
    pub fn modifyTrailingSlash(
        path: *mut ::std::os::raw::c_char,
        nbytes: size_t,
        flag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_makeTempFilename() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn extractNumberFromFilename(
        fname: *const ::std::os::raw::c_char,
        numpre: l_int32,
        numpost: l_int32,
    ) -> l_int32;
}
extern "C" {
    pub fn pixSimpleCaptcha(
        pixs: *mut PIX,
        border: l_int32,
        nterms: l_int32,
        seed: l_uint32,
        color: l_uint32,
        cmapflag: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixRandomHarmonicWarp(
        pixs: *mut PIX,
        xmag: l_float32,
        ymag: l_float32,
        xfreq: l_float32,
        yfreq: l_float32,
        nx: l_int32,
        ny: l_int32,
        seed: l_uint32,
        grayval: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixWarpStereoscopic(
        pixs: *mut PIX,
        zbend: l_int32,
        zshiftt: l_int32,
        zshiftb: l_int32,
        ybendt: l_int32,
        ybendb: l_int32,
        redleft: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontal(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalSampled(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStretchHorizontalLI(
        pixs: *mut PIX,
        dir: l_int32,
        type_: l_int32,
        hmax: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShear(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        operation: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearSampled(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixQuadraticVShearLI(
        pixs: *mut PIX,
        dir: l_int32,
        vmaxt: l_int32,
        vmaxb: l_int32,
        incolor: l_int32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn pixStereoFromPair(
        pix1: *mut PIX,
        pix2: *mut PIX,
        rwt: l_float32,
        gwt: l_float32,
        bwt: l_float32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn wshedCreate(
        pixs: *mut PIX,
        pixm: *mut PIX,
        mindepth: l_int32,
        debugflag: l_int32,
    ) -> *mut L_WSHED;
}
extern "C" {
    pub fn wshedDestroy(pwshed: *mut *mut L_WSHED);
}
extern "C" {
    pub fn wshedApply(wshed: *mut L_WSHED) -> l_ok;
}
extern "C" {
    pub fn wshedBasins(
        wshed: *mut L_WSHED,
        ppixa: *mut *mut PIXA,
        pnalevels: *mut *mut NUMA,
    ) -> l_ok;
}
extern "C" {
    pub fn wshedRenderFill(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn wshedRenderColors(wshed: *mut L_WSHED) -> *mut PIX;
}
extern "C" {
    pub fn pixaWriteWebPAnim(
        filename: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteStreamWebPAnim(
        fp: *mut FILE,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixaWriteMemWebPAnim(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut size_t,
        pixa: *mut PIXA,
        loopcount: l_int32,
        duration: l_int32,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixReadStreamWebP(fp: *mut FILE) -> *mut PIX;
}
extern "C" {
    pub fn pixReadMemWebP(filedata: *const l_uint8, filesize: size_t) -> *mut PIX;
}
extern "C" {
    pub fn readHeaderWebP(
        filename: *const ::std::os::raw::c_char,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn readHeaderMemWebP(
        data: *const l_uint8,
        size: size_t,
        pw: *mut l_int32,
        ph: *mut l_int32,
        pspp: *mut l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteWebP(
        filename: *const ::std::os::raw::c_char,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteStreamWebP(
        fp: *mut FILE,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteMemWebP(
        pencdata: *mut *mut l_uint8,
        pencsize: *mut size_t,
        pixs: *mut PIX,
        quality: l_int32,
        lossless: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_jpegSetQuality(new_quality: l_int32) -> l_int32;
}
extern "C" {
    pub fn setLeptDebugOK(allow: l_int32);
}
extern "C" {
    pub fn pixaWriteFiles(
        rootname: *const ::std::os::raw::c_char,
        pixa: *mut PIXA,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWriteDebug(
        fname: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixWrite(fname: *const ::std::os::raw::c_char, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteAutoFormat(filename: *const ::std::os::raw::c_char, pix: *mut PIX) -> l_ok;
}
extern "C" {
    pub fn pixWriteStream(fp: *mut FILE, pix: *mut PIX, format: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixWriteImpliedFormat(
        filename: *const ::std::os::raw::c_char,
        pix: *mut PIX,
        quality: l_int32,
        progressive: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixChooseOutputFormat(pix: *mut PIX) -> l_int32;
}
extern "C" {
    pub fn getImpliedFileFormat(filename: *const ::std::os::raw::c_char) -> l_int32;
}
extern "C" {
    pub fn pixGetAutoFormat(pix: *mut PIX, pformat: *mut l_int32) -> l_ok;
}
extern "C" {
    pub fn getFormatExtension(format: l_int32) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pixWriteMem(
        pdata: *mut *mut l_uint8,
        psize: *mut size_t,
        pix: *mut PIX,
        format: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn l_fileDisplay(
        fname: *const ::std::os::raw::c_char,
        x: l_int32,
        y: l_int32,
        scale: l_float32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixDisplay(pixs: *mut PIX, x: l_int32, y: l_int32) -> l_ok;
}
extern "C" {
    pub fn pixDisplayWithTitle(
        pixs: *mut PIX,
        x: l_int32,
        y: l_int32,
        title: *const ::std::os::raw::c_char,
        dispflag: l_int32,
    ) -> l_ok;
}
extern "C" {
    pub fn pixMakeColorSquare(
        color: l_uint32,
        size: l_int32,
        addlabel: l_int32,
        location: l_int32,
        textcolor: l_uint32,
    ) -> *mut PIX;
}
extern "C" {
    pub fn l_chooseDisplayProg(selection: l_int32);
}
extern "C" {
    pub fn changeFormatForMissingLib(pformat: *mut l_int32);
}
extern "C" {
    pub fn pixDisplayWrite(pixs: *mut PIX, reduction: l_int32) -> l_ok;
}
extern "C" {
    pub fn zlibCompress(datain: *const l_uint8, nin: size_t, pnout: *mut size_t) -> *mut l_uint8;
}
extern "C" {
    pub fn zlibUncompress(datain: *const l_uint8, nin: size_t, pnout: *mut size_t) -> *mut l_uint8;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
